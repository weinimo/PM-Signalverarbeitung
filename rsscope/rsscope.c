/*****************************************************************************
 *  Rohde&Schwarz RTO Instrument Driver                               
 *  LabWindows/CVI Instrument Driver                                     
 *  Original Release: 2010-12-17                                 
 *  By: Jiri Kominek, Martin Krcmar, Petr Berger
 *                                                                           
 *  Modification History:                                                    
 *                                                                           
 *       See ChangeLog
 *                                                                           
 *****************************************************************************/

#include <string.h>
#include <stdio.h>  
#include <stdlib.h>
#include <math.h>
#include "rsscope.h"

ViStatus _VI_FUNC  rsscope_RsClose (ViSession vi);

/*****************************************************************************
 *- Value Definition and Range Tables ---------------------------------------*
 *****************************************************************************/
static ViString eyeMeasArr[] = {"","","ExtRatioPct","ExtRatiodBm","EyeHeight","EyeWidth","EyeTop",
                                "EyeBase","","","QFactor","","","","NoiseInRMS","SNR","DCycleDistortion",
                                "EyeRTime","EyeFTime","EyeBitRate","EyeAmplitude","","","","","","","",
                                "P2PJitter","StdDevJitter","RMSJitter"};
static ViString searchSource_Arr[] = {"NONE", "C1W1", "C1W2", "C1W3", "C2W1", "C2W2", "C2W3", "C3W1", 
                                      "C3W2", "C3W3", "C4W1", "C4W2", "C4W3", "M1", "M2", 
                                      "M3", "M4", "R1", "R2", "R3", "R4"};
static ViString source_Arr[] = {"NONE", "C1W1", "C1W2", "C1W3", "C2W1", "C2W2", "C2W3", "C3W1", "C3W2",
                                "C3W3", "C4W1", "C4W2", "C4W3", "M1", "M2", "M3", "M4", "R1", "R2", "R3",
                                "R4", "XY1", "XY2", "XY3", "XY4", "MRES1", "MRES2", "MRES3", "MRES4", 
                                "MRES5", "MRES6", "MRES7", "MRES8", "SBUS1", "SBUS2", "SBUS3", "SBUS4"};
static ViString position_Arr[] = {"NONE", "HOR", "VERT", "TAB"};
static ViString searchPolarity_Arr[] = {"POS", "NEG", "EITH"};
static ViString searchCondition_Arr[] = {"SHOR", "LONG", "WITH", "OUTS"};
static ViString searchSlewCondition_Arr[] = {"LTH", "GTH", "INSR", "OUTR"};
static ViString searchMode_Arr[] = {"ABS", "REL"};
static ViString protocolFrameStatus_Arr[] = {"OK", "INCF", "INCL", "INS", VI_NULL};
static ViString protocolI2CAddressType_Arr[] = {"AUTO", "BIT7", "BIT7_RW", "BIT10", "ANY", VI_NULL};
static ViString protocolI2CRWBit_Arr[] = {"EITH", "READ", "WRIT", "INC", VI_NULL};
static ViString protocolI2CAckBit_Arr[] = {"EITH", "ACK", "NACK", "INC", VI_NULL};
static ViString protocolUARTLine_Arr[] = {"RX", "TX", VI_NULL};
static ViString protocolUARTStatus_Arr[] = {"OK", "FRST", "FREN", "FRME", "STER", "SPER", "PRER", "INS","BRE", VI_NULL};
static ViString protocolLINVersion_Arr[] = {"UNK", "V1X", "V2X", VI_NULL};
static ViString protocolLINFrameStatus_Arr[] = {"OK", "VERS", "SPER", "PRER", "INS", "CHCK", "LENER", "WAK", "UART", VI_NULL};
static ViString protocolLINFieldStatus_Arr[] = {"OK", "STER", "SPER", "PRER", "INS", "UVAL", VI_NULL};
static ViString protocolCANFrameStatus_Arr[] = {"OK", "BTST", "CRCD", "CRC", "EOFD", "ACKD", "NOACK", "INS", VI_NULL};
static ViString protocolCANFieldStatus_Arr[] = {"OK", "UNDF", VI_NULL};
static ViString protocolCANFrameType_Arr[] = {"DATA", "REM", "ERR", "OVLD", VI_NULL};
static ViString protocolCANIDType_Arr[] = {"B11", "B29", "ANY", VI_NULL};
static ViString typeArr[] = {"Edge","Glitch","Width","Runt","Window","Timeout","Interval","Slew Rate","Data2Clock",VI_NULL};
static ViString polarityArr[] = {"Negative","Positive"};
static ViString qualifyChannelArr[] =  {"", "A", "B", "C", "D", VI_NULL};
static ViString qualifyMultiChannelArr[] =  {"", "AB", "CD", "ABCD", VI_NULL}; 
static ViString qualifyChannelLogicArr[] =  {"DIR", "NOT", VI_NULL};
static ViString qualifyMultiChannelLogicArr[] =  {"AND", "OR", "NAND", "NOR", VI_NULL};
static ViString patternModeArr[] =  {"OFF", "TIM", "WIDT", VI_NULL}; 
static ViString timeoutConditionArr[] =  {"LOW", "HIGH", "EITH", VI_NULL};
static ViString patternConditionArr[] =  {"SHOR", "LONG", "WITH", "OUTS", VI_NULL}; 

/*****************************************************************************
 *- Callback Declarations ---------------------------------------------------*
 *****************************************************************************/

/*****************************************************************************
 *- User-Callable Functions (Exportable Functions) --------------------------*
 *****************************************************************************/

/*****************************************************************************
 * Function: 
 rsscope_init
 * Purpose:  VXIplug&play required function. Calls the
 *           rsscope_InitWithOptions function.
 *****************************************************************************/
ViStatus _VI_FUNC rsscope_init (ViRsrc resourceName, ViBoolean IDQuery,
                                 ViBoolean resetDevice, ViSession *newInstrSession)
{
    ViStatus    error = VI_SUCCESS;

    if (newInstrSession == VI_NULL)
        {
        (void) Rs_SetErrorInfo (VI_NULL, VI_FALSE, RS_ERROR_INVALID_PARAMETER,
                          VI_ERROR_PARAMETER4, "Null address for Instrument Handle");
        checkErr( RS_ERROR_INVALID_PARAMETER);
        }

    checkErr( rsscope_InitWithOptions (resourceName, IDQuery, resetDevice,
                                      "QueryInstrStatus=1", newInstrSession));

Error:
    return error;
}

/*****************************************************************************
 * Function: rsscope_InitWithOptions
 * Purpose:  This function creates a new RS session and calls the
 *           RsInit function.
 *****************************************************************************/
ViStatus _VI_FUNC rsscope_InitWithOptions(
    ViRsrc          resourceName,
    ViBoolean       IDQuery,
    ViBoolean       resetDevice,
    ViString        optionString,
    ViSession      *newInstrSession
)
{
    ViStatus                error = VI_SUCCESS;
    ViChar                  newResourceName[RS_MAX_MESSAGE_BUF_SIZE] = "";
    ViChar                  newOptionString[RS_MAX_MESSAGE_BUF_SIZE] = "";
    ViBoolean               isLogicalName = 0;
    ViSession               instrSession = 0, rmSession = 0;
    RsAttrPropertiesPtr     *attrList=NULL;
    RsRepCapPtr             repCapTable = NULL;
    
    if (newInstrSession == VI_NULL)
        {
        (void) Rs_SetErrorInfo (VI_NULL, VI_FALSE, RS_ERROR_INVALID_PARAMETER,
                         VI_ERROR_PARAMETER5, "Null address for Instrument Handle");
        checkErr( RS_ERROR_INVALID_PARAMETER);
        }

    /* Prepare resource manager session handle */
    checkErr (viOpenDefaultRM (&rmSession));

    /* Establish communication session with the instrument */

    viCheckErr( viOpen (rmSession, resourceName, VI_NULL, VI_NULL, &instrSession));
    
    /* Configure VISA Formatted I/O */
    viCheckErr( viSetAttribute (instrSession, VI_ATTR_TMO_VALUE, 30000 ));
    viCheckErr( viSetBuf (instrSession, (ViUInt16) (VI_READ_BUF | VI_WRITE_BUF), 4000));
    viCheckErr( viSetAttribute (instrSession, VI_ATTR_WR_BUF_OPER_MODE, VI_FLUSH_ON_ACCESS));
    viCheckErr( viSetAttribute (instrSession, VI_ATTR_RD_BUF_OPER_MODE, VI_FLUSH_ON_ACCESS));

    checkErr( Rs_GetInfoFromResourceName (resourceName,
                                          (ViString)optionString,
                                          newResourceName,
                                          newOptionString,
                                          &isLogicalName));
    
    ATTRLIST(attrList,rsscope);  
    checkErr( Rs_SpecificDriverNew (instrSession, "rsscope", newOptionString, attrList));
    
    /* Build repeated capability table */
    REPCAPTABLE(repCapTable,rsscope);
    checkErr( Rs_BuildRepCapTable (instrSession, repCapTable));

    checkErr (Rs_SetAttribute (instrSession, "", RS_ATTR_VISA_RM_SESSION, 0, &rmSession));
    checkErr (Rs_SetAttribute (instrSession, "", RS_ATTR_IO_SESSION, 0, &instrSession));

    /* With remote control via Ethernet, remote control is not automatically
       set by means of a command. The instrument must be explicitly set to
       the REMOTE state, e.g. by sending the intf command &GTR
    */
    checkErr (viWrite (instrSession, (ViBuf) "&GTR\n", 5, NULL));
    
    /*- Reset instrument ----------------------------------------------------*/
    if (resetDevice == VI_TRUE)
    {
        checkErr( rsscope_reset (instrSession));
    }
    else  /*- Send Default Instrument Setup ---------------------------------*/
	{
        checkErr( rsscope_DefaultInstrSetup (instrSession));
	}

    /*- Identification Query ------------------------------------------------*/
    if (IDQuery == VI_TRUE)
        {
        ViChar rdBuffer[RSSCOPE_IO_BUFFER_SIZE] = "";

        checkErr( Rs_GetAttribute (instrSession, VI_NULL, (ViAttr) RSSCOPE_ATTR_ID_QUERY_RESPONSE,
                                   0, RSSCOPE_IO_BUFFER_SIZE, rdBuffer));

        if (strncmp (rdBuffer, RSSCOPE_VALID_ID_RESPONSE_STRING, strlen(RSSCOPE_VALID_ID_RESPONSE_STRING)) != 0)
            {
            viCheckErr( VI_ERROR_FAIL_ID_QUERY);
            }
        }

    if (isLogicalName == VI_FALSE)
        {
        ViInt32 oldFlag = 0;

        checkErr (Rs_GetAttributeFlags (instrSession, RS_ATTR_IO_RESOURCE_DESCRIPTOR, &oldFlag));
        checkErr (Rs_SetAttributeFlags (instrSession, RS_ATTR_IO_RESOURCE_DESCRIPTOR, oldFlag & 0xfffb | 0x0010));
        checkErr (Rs_SetAttribute (instrSession, "", RS_ATTR_IO_RESOURCE_DESCRIPTOR, 0, newResourceName));
        }
    
    if (isLogicalName == VI_TRUE)
        checkErr( Rs_ApplyDefaultSetup (instrSession));

    /* Instrument session accessible by the end user is native VISA session,
       or when simulated virtual instrument (instrSession) session. */
    checkErr( rsscope_CheckStatus (instrSession));

Error:

    if (error < VI_SUCCESS)
    {
        ViSession   rmSess = VI_NULL;
        
        (void) Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_VISA_RM_SESSION, 0, (ViInt32) sizeof (rmSess), &rmSess);
        (void) Rs_Dispose (instrSession); 
        if (instrSession != 0)
            (void) viClose (instrSession);
        (void) viClose (rmSess);
    }
    else
    {
        *newInstrSession = instrSession;
    }
    
    return error;
    
}

/// HIFN  Selects the histogram on which the measurement is based.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Selects the histogram on which the measurement is based.
ViStatus _VI_FUNC rsscope_SelectHistogram(
    ViSession    instrSession,
    ViInt32        measurement,
    ViString    measurementType
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_SELECT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_HISTOGRAM_SELECT, measurementType
                                                ), 3, "Measurement Type");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the histogram measurement probability domain 
/// HIFN  marker settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR reference/Defines the marker reference in the probability domain.
/// HIPAR delta/Defines a range around the probability marker.
ViStatus _VI_FUNC rsscope_ConfigureHistogramProbabilityDomainMarkerSettings(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        reference,
    ViInt32        delta
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_PROBABILITY_TYPE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HISTOGRAM_PROBABILITY_TYPE, reference
                                               ), 3, "Reference");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HISTOGRAM_PROBABILITY_LIMIT, delta
                                               ), 4, "Delta");    

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables or disables limit checking for histogram measurements in the 
/// HIFN  specified measurement channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Histogram measurement type.
/// HIPAR limitCheck/Enables or disables limit checking for histogram measurements in the 
/// HIPAR limitCheck/specified measurement channel.
ViStatus _VI_FUNC rsscope_ConfigureHistogramLimitCheck(
    ViSession    instrSession,
    ViInt32    measurement,
    ViInt32    measurementType,
    ViInt32    limitCheck
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_LIMIT_CHECK,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");     
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_LIMIT_CHECK,
                                                 "HistogramMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    

    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HISTOGRAM_LIMIT_CHECK, limitCheck
                                               ), 4, "Limit Check");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper limit for limit checking, respectively.
/// HIFN  MEASurement<Measurement>:HISTogram:LCHeck<HistogramMeasurementType>:<LowUpp>:LIMit
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Histogram measurement type.
/// HIPAR lowerLimit/Define the lower limit for limit checking.
/// HIPAR upperLimit/Define the upper limit for limit checking.
ViStatus _VI_FUNC rsscope_ConfigureHistogramLimitCheckLimits(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerLimit,
    ViReal64    upperLimit
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_LIMIT_VALUE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_LIMIT_VALUE,
                                                 "HistogramMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_HISTOGRAM_LIMIT_VALUE, lowerLimit
                                                ), 4, "Lower Limit");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_HISTOGRAM_LIMIT_VALUE, upperLimit
                                                ), 5, "Upper Limit");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper margins for the limit check, respectively. 
/// HIFN  Margins are not as strict as limits and must be within the valid value 
/// HIFN  range.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Histogram measurement type.
/// HIPAR lowerMargin/Define the lower margin for the limit check. Margins are not as strict 
/// HIPAR lowerMargin/as limits and must be within the valid value range.
/// HIPAR upperMargin/Define the upper margins for the limit check. Margins are not as 
/// HIPAR upperMargin/strict as limits and must be within the valid value range.
ViStatus _VI_FUNC rsscope_ConfigureHistogramLimitCheckMargins(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerMargin,
    ViReal64    upperMargin
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_LIMIT_MARGIN,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_LIMIT_MARGIN,
                                                 "HistogramMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_HISTOGRAM_LIMIT_MARGIN, lowerMargin
                                                ), 4, "Lower Margin");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_HISTOGRAM_LIMIT_MARGIN, upperMargin
                                                ), 5, "Upper Margin");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function displays a histogram for the source of the selected 
/// HIFN  measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR displaySourceHistogram/Displays a histogram for the source of the selected measurement.
ViStatus _VI_FUNC rsscope_ConfigureHistogramDisplay(
    ViSession    instrSession,
    ViInt32        measurement,
    ViBoolean    displaySourceHistogram
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   rep_cap[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_DISPLAY,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap), 2, "Measurement");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HISTOGRAM_DISPLAY,
                                               displaySourceHistogram
                                               ), 3, "Display Source Histogram");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines and displays a new histogram for the specified source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/Defines the histogram name which is displayed in the Histogram
/// HIPAR histogramSource/Data source of the histogram
/// HIPAR relativeValues/Defines whether relative or absolute values are used for the value 
/// HIPAR relativeValues/range definition.
/// HIPAR xStart/Defines the start value of the x-value range.
/// HIPAR xStop/Defines the stop value of the x-value range.
/// HIPAR yStart/Defines the start value of the y-value range.
/// HIPAR yStop/Defines the stop value of the y-value range.
ViStatus _VI_FUNC rsscope_CreateNewHistogram(
    ViSession    instrSession,
    ViString    histogramName,
    ViInt32        histogramSource,
    ViBoolean    relativeValues,
    ViReal64    xStart,
    ViReal64    xStop,
    ViReal64    yStart,
    ViReal64    yStop
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, histogramSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE, RSSCOPE_VAL_MEASUREMENT_SOURCE_R4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Histogram Source");
    }    
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:ADD '%s',%s,%.12lG,%.12lG,%.12lG,%.12lG,%s\n", histogramName, 
                                                                                                 searchSource_Arr[histogramSource],
                                                                                                xStart,
                                                                                                xStop,
                                                                                                yStart,
                                                                                                yStop,
                                                                                                relativeValues?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the source of the histogram. Any input signal, math or 
/// HIFN  reference waveform can be selected.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/The name of the histogram.
/// HIPAR histogramSource/Defines the source of the histogram. Any input signal, math or 
/// HIPAR histogramSource/reference waveform can be selected.
ViStatus _VI_FUNC rsscope_ConfigureHistogramSource(
    ViSession    instrSession,
    ViString    histogramName,
    ViInt32        histogramSource
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, histogramSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE, RSSCOPE_VAL_MEASUREMENT_SOURCE_R4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Histogram Source");
    }    
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:SOUR '%s',%s\n", histogramName, searchSource_Arr[histogramSource]));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Resets the values to begin a new histogram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/The name of the histogram.
ViStatus _VI_FUNC rsscope_ResetHistogram(
    ViSession    instrSession,
    ViString    histogramName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_RESET_HISTOGRAM,
                                                histogramName
                                                ), 2, "Histogram Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Removes the specified histogram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/The name of the histogram.
ViStatus _VI_FUNC rsscope_RemoveHistogram(
    ViSession    instrSession,
    ViString    histogramName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_REMOVE_HISTOGRAM,
                                                histogramName
                                                ), 2, "Histogram Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the type of histogram
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/The name of the histogram.
/// HIPAR type/Selects the type of histogram.
ViStatus _VI_FUNC rsscope_ConfigureHistogramType(
    ViSession    instrSession,
    ViString    histogramName,
    ViInt32        type
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:MODE '%s',%s\n", histogramName, type?"HOR":"VERT"));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical settings of histogram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/The name of the histogram.
/// HIPAR mode/Defines whether the vertical histogram settings are configured using 
/// HIPAR mode/absolute or relative values.
/// HIPAR start/Defines the vertical start value of the histogram.
/// HIPAR stop/Defines the vertical stop value of the histogram.
ViStatus _VI_FUNC rsscope_ConfigureHistogramVertical(
    ViSession    instrSession,
    ViString    histogramName,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:VERT:MODE '%s',%s\n", histogramName, mode?"REL":"ABS"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:VERT:%s:STAR '%s',%.12lG\n", mode?"REL":"ABS", histogramName, start));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:VERT:%s:STOP '%s',%.12lG\n", mode?"REL":"ABS", histogramName, stop));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the horizontal settings of histogram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR histogramName/The name of the histogram.
/// HIPAR mode/Defines whether the hozirontal histogram settings are configured using 
/// HIPAR mode/absolute or relative values.
/// HIPAR start/Defines the hozirontal start value of the histogram.
/// HIPAR stop/Defines the hozirontal stop value of the histogram.
ViStatus _VI_FUNC rsscope_ConfigureHistogramHorizontal(
    ViSession    instrSession,
    ViString    histogramName,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:HORZ:MODE '%s',%s\n", histogramName, mode?"REL":"ABS"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:HORZ:%s:STAR '%s',%.12lG\n", mode?"REL":"ABS", histogramName, start));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:HIST:HORZ:%s:STOP '%s',%.12lG\n", mode?"REL":"ABS", histogramName, stop));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the state of the gating.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR useGate/Enables gating.
ViStatus _VI_FUNC rsscope_ConfigureGateState(
    ViSession    instrSession,
    ViInt32    measurement,
    ViBoolean    useGate
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GATING_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_GATING_ENABLED,useGate
                                                 ), 3, "Use Gate");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether the gate area is displayed in the 
/// HIFN  source diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR showGate/Indicates the gate area in the source diagram.
ViStatus _VI_FUNC rsscope_ConfigureGateShow(
    ViSession    instrSession,
    ViInt32    measurement,
    ViBoolean    showGate
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
        
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GATING_SHOW_GATE_AREA,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_GATING_SHOW_GATE_AREA,showGate
                                                 ), 3, "Show Gate");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether the gate area is defined identically 
/// HIFN  to the zoom area for the selected active zoom diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR zoomCoupling/If enabled, the gate area is defined identically to the zoom area for 
/// HIPAR zoomCoupling/the zoom diagram.
/// HIPAR zoomDiagram/This control is reserved for future use.
ViStatus _VI_FUNC rsscope_ConfigureGateDefinitionZoom(
    ViSession    instrSession,
    ViInt32    measurement,
    ViBoolean    zoomCoupling,
    ViInt32    zoomDiagram
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";
    zoomDiagram;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GATING_ZOOM_COUPLING_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_GATING_ZOOM_COUPLING_ENABLED,zoomCoupling
                                                 ), 3, "Zoom Coupling");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the start and end values for the gate.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR start/Defines the starting value for the gate.
/// HIPAR stop/Defines the ending value for the gate.
ViStatus _VI_FUNC rsscope_ConfigureGateDefinitionStartStop(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Mode");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GATING_MODE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");     
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GATING_START,
                                                 "AbsRel",
                                                 mode,
                                                 15,
                                                 rep_cap_t), 3, "Mode");    

    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_m,
                                                RSSCOPE_ATTR_GATING_MODE, mode
                                                ), 3, "Mode");    
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_GATING_START, start
                                                ), 4, "Start");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_GATING_STOP, stop
                                                ), 5, "Stop");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the noise evaluation area.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR evaluationArea/Selects the noise evaluation area.
ViStatus _VI_FUNC rsscope_ConfigureGateNoise(
    ViSession    instrSession,
    ViInt32    measurement,
    ViInt32    evaluationArea
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GATING_NOISE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_GATING_NOISE, evaluationArea
                                               ), 3, "EvaluationArea");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables long term measurement for a defined number of measurement 
/// HIFN  points or a specified time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR longTermState/Enables long term measurement for a defined number of measurement 
/// HIPAR longTermState/points or a specified time.
ViStatus _VI_FUNC rsscope_ConfigureLongTermState(
    ViSession    instrSession,
    ViInt32    measurement,
    ViBoolean    longTermState
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_LONG_TERM_MEASUREMENT_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_LONG_TERM_MEASUREMENT_ENABLED, longTermState
                                                 ), 3, "Long Term State");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the total duration of the long term 
/// HIFN  measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR totalMeasurementTime/Defines the total duration of the long term measurement.
ViStatus _VI_FUNC rsscope_ConfigureLongTermTotalMeasurementTime(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32    totalMeasurementTime
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_LONG_TERM_DURATION,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");        

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_LONG_TERM_DURATION, totalMeasurementTime
                                                ), 3, "Total Measurement Time");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the total number of points to be measured during the long term 
/// HIFN  measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementPoints/Defines the total number of points to be measured during the long term 
/// HIPAR measurementPoints/measurement.
ViStatus _VI_FUNC rsscope_ConfigureLongTermMeasurementPoints(
    ViSession    instrSession,
    ViInt32    measurement,
    ViInt32    measurementPoints
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
     
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_LONG_TERM_COUNT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_LONG_TERM_COUNT, measurementPoints
                                               ), 3, "Measurement Points");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical scale and offset.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR verticalScale/Defines the vertical scaling per division, so that the scaling can be 
/// HIPAR verticalScale/adapted automatically during the long term measurement period.
/// HIPAR verticalOffset/Defines a vertical offset for the long term measurement.
ViStatus _VI_FUNC rsscope_ConfigureLongTermVerticalScaling(
    ViSession    instrSession,
    ViInt32    measurement,
    ViReal64    verticalScale,
    ViReal64    verticalOffset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_LONG_TERM_VERTICAL_SCALING,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");         

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_LONG_TERM_VERTICAL_SCALING,verticalScale
                                                ), 3, "Vertical Scale");

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_LONG_TERM_VERTICAL_OFFSET, verticalOffset
                                                ), 4, "Vertical Offset");
        
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Automatically adapts vertical scaling to the current measurement 
/// HIFN  results during the long term measurement period.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
ViStatus _VI_FUNC rsscope_LongTermVerticalAutoScale(
    ViSession    instrSession,
    ViInt32        measurement
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_LONG_TERM_VERTICAL_AUTOSCALE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");       

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_LONG_TERM_VERTICAL_AUTOSCALE, NULL));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables statistics calculation for the measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR statistics/Enables statistics calculation for the measurement.
ViStatus _VI_FUNC rsscope_ConfigureStatisticsState(
    ViSession    instrSession,
    ViInt32        measurement,
    ViBoolean    statistics
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_STATISTICS_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");      

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_STATISTICS_ENABLED, statistics
                                                 ), 3, "Statistics");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function displays histogram of the statistical results.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR showHistogram/Enables statistics histogram for the measurement.
ViStatus _VI_FUNC rsscope_ConfigureHistogramState (ViSession instrSession,
                                                   ViInt32 measurement,
                                                   ViBoolean showHistogram)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_STATISTICS_HISTOGRAM_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");      

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_STATISTICS_HISTOGRAM_ENABLED, showHistogram
                                                 ), 3, "showHistogram");

Error:
    Rs_UnlockSession (instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the reset statistics settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR resetStatisticsMode/Defines when the statistics for long term measurements are reset.
/// HIPAR resetTime/Defines the time or period after which the statistics are reset.
/// HIPAR resetCount/Defines the number of measurements after which the statistics are 
/// HIPAR resetCount/reset.
ViStatus _VI_FUNC rsscope_ConfigureResetStatisticsSettings(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        resetStatisticsMode,
    ViReal64    resetTime,
    ViInt32        resetCount
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_STATISTICS_RESET_MODE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_STATISTICS_RESET_MODE, resetStatisticsMode
                                               ), 3, "Reset Statistics Mode");

    switch(resetStatisticsMode) 
    {
        case RSSCOPE_VAL_STAT_MODE_TIME:
            viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                        RSSCOPE_ATTR_STATISTICS_RESET_TIME, resetTime
                                                        ), 4, "Reset Time");
            
        break;
            
        case RSSCOPE_VAL_STAT_MODE_WAVEFORMS:
            viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                       RSSCOPE_ATTR_STATISTICS_RESET_COUNT, resetCount
                                                       ), 5, "Reset Count");
        break;
            
        default: 
        break;
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function resets the statistics.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
ViStatus _VI_FUNC rsscope_ResetStatistics(
    ViSession    instrSession,
    ViInt32        measurement
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
     
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_STATISTICS_RESET,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");       

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_STATISTICS_RESET, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the number of measurements for which the 
/// HIFN  statistical average is calculated.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR statisticsAverageCount/Defines the number of measurements for which the statistical average 
/// HIPAR statisticsAverageCount/is calculated.
ViStatus _VI_FUNC rsscope_ConfigureStatisticsAverageCount(
    ViSession    instrSession,
    ViInt32    measurement,
    ViInt32    statisticsAverageCount
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_STATISTICS_WEIGHT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");         

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_STATISTICS_WEIGHT, statisticsAverageCount
                                               ), 3, "Statistics Average Count");  

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables the evaluation of a connected environment sensor.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR useSensor/Enables the evaluation of a connected environment sensor.
ViStatus _VI_FUNC rsscope_ConfigureEnvironmentSensorState(
    ViSession    instrSession,
    ViInt32        measurement,
    ViBoolean    useSensor
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_LONG_TERM_ENVIRONMENT_SENSOR_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_LONG_TERM_ENVIRONMENT_SENSOR_ENABLED, useSensor
                                                 ), 3, "Use Sensor");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the reference level settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR referenceLevelMode/Defines whether the reference level is configured manually or 
/// HIPAR referenceLevelMode/automatically.
/// HIPAR levelDefinition/Defines whether the reference is configured using absolute or relative 
/// HIPAR levelDefinition/values.
/// HIPAR userLevelSelection/Defines whether the user-defined signal levels or user-defined 
/// HIPAR userLevelSelection/reference levels are used for the measurements.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevel(
    ViSession    instrSession,
    ViInt32    source,
    ViInt32    referenceLevelMode,
    ViInt32    levelDefinition,
    ViInt32    userLevelSelection
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_MODE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");   
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_LEVEL_MODE, referenceLevelMode
                                               ), 3, "Reference Level Mode");
    
    if (referenceLevelMode == RSSCOPE_VAL_MANUAL)
    {
        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                   RSSCOPE_ATTR_REFERENCE_LEVEL_DEFINITION, levelDefinition
                                                   ), 4, "Level Definition");

        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                   RSSCOPE_ATTR_REFERENCE_LEVEL_USER_LEVEL, userLevelSelection
                                                   ), 5, "User Level Selection");
    }
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the reference level automatic configuration 
/// HIFN  settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR signalLevelMode/Defines which signal level is used as a reference.
/// HIPAR histogramAveraging/Enables averaging over several histograms to determine the reference 
/// HIPAR histogramAveraging/levels.
/// HIPAR averageCount/Defines the number of histograms to calculate the average from.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevelAutoSettings(
    ViSession    instrSession,
    ViInt32        source,
    ViInt32        signalLevelMode,
    ViBoolean    histogramAveraging,
    ViInt32        averageCount
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_AUTO_MODE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_LEVEL_AUTO_MODE, signalLevelMode
                                               ), 3, "Signal Level Mode");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_AVERAGING_ENABLED, histogramAveraging
                                                 ), 4, "Histogram Averaging");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                   RSSCOPE_ATTR_REFERENCE_LEVEL_AVERAGING_COUNT, averageCount
                                                   ), 5, "Average Count");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the user signal level settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR topDistance/The distance between the high signal level and the upper reference 
/// HIPAR topDistance/level.
/// HIPAR bottomDistance/The distance between the lower reference level and the low signal 
/// HIPAR bottomDistance/value.
/// HIPAR highSignalLevel/The signal value that represents a high level.
/// HIPAR lowSignalLevel/The signal value that represents a high level.
ViStatus _VI_FUNC rsscope_ConfigureReferenceUserSignalLevel(
    ViSession    instrSession,
    ViInt32    source,
    ViReal64    topDistance,
    ViReal64    bottomDistance,
    ViReal64    highSignalLevel,
    ViReal64    lowSignalLevel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_USER_TOP_DISTANCE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_USER_TOP_DISTANCE, topDistance
                                                ), 3, "Top Distance");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_USER_BOTTOM_DISTANCE, bottomDistance
                                                ), 4, "Bottom Distance");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_USER_SIGNAL_HIGH, highSignalLevel
                                                ), 5, "High Signal Level");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_USER_SIGNAL_LOW, lowSignalLevel
                                                ), 6, "Low Signal Level");    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the user reference level settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR topDistance/The distance between the high signal level and the upper reference 
/// HIPAR topDistance/level.
/// HIPAR bottomDistance/The distance between the lower reference level and the low signal 
/// HIPAR bottomDistance/value.
/// HIPAR upperLevel/The upper reference level, required e.g. to determine a rise.
/// HIPAR lowerLevel/The lower reference level, required e.g. to determine a fall.
ViStatus _VI_FUNC rsscope_ConfigureUserReferenceLevel(
    ViSession    instrSession,
    ViInt32        source,
    ViReal64    topDistance,
    ViReal64    bottomDistance,
    ViReal64    upperLevel,
    ViReal64    lowerLevel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_USER_TOP_DISTANCE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_USER_TOP_DISTANCE, topDistance
                                                ), 3, "Top Distance");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_USER_BOTTOM_DISTANCE, bottomDistance
                                                ), 4, "Bottom Distance");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_UPPER_LEVEL, upperLevel
                                                ), 5, "Upper Level");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_LOWER_LEVEL, lowerLevel
                                                ), 6, "Lower Level");    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the user middle reference level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR middleLevel/The middle reference level.
ViStatus _VI_FUNC rsscope_ConfigureUserMiddleReferenceLevel (ViSession instrSession,
                                                             ViInt32 source,
                                                             ViReal64 middleLevel)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_USER_TOP_DISTANCE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_MIDDLE_LEVEL, middleLevel
                                                ), 3, "Middle Level");    
                                                              
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the lower, middle and upper reference levels, 
/// HIFN  defined as percentages of the high signal level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR relativeLevels/The lower, middle and upper reference levels, defined as percentages 
/// HIPAR relativeLevels/of the high signal level.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevelRelativeLevels(
    ViSession    instrSession,
    ViInt32        source,
    ViInt32        relativeLevels
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_RELATIVE_LEVELS,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_LEVEL_RELATIVE_LEVELS, relativeLevels
                                               ), 3, "Relative Levels");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the lower, middle and upper reference levels, 
/// HIFN  defined as percentages of the high signal level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR upperLevel/The upper relative reference level.
/// HIPAR middleLevel/The middle relative reference level.
/// HIPAR lowerLevel/The middle relative reference level.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevelRelativeUserLevels(
    ViSession   instrSession,
    ViInt32     source,
    ViInt32 upperLevel,
    ViInt32 middleLevel,
    ViInt32 lowerLevel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

     if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_C1W1, RSSCOPE_VAL_WAV_R4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    } 

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_RELATIVE_LEVELS,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 3, "Source"); 
                                                 
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_RELATIVE_LEVELS,
                                                 RSSCOPE_VAL_USER_LEVEL));
                                   
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_RELATIVE_LOWER_LEVEL,
                                                lowerLevel
                                                ), 6, "Lower Level");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_RELATIVE_MIDDLE_LEVEL,
                                                middleLevel
                                                ), 5, "Middle Level");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_RELATIVE_UPPER_LEVEL,
                                                upperLevel
                                                ), 4, "Upper Level");
    
    

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the hysteresis for measurements that 
/// HIFN  determine zero-crossings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR hysteresis/Defines a hysteresis for the middle reference level. A rise or fall 
/// HIPAR hysteresis/from the middle reference value that does not exceed the hysteresis is 
/// HIPAR hysteresis/rejected as noise.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevelHysteresis(
    ViSession    instrSession,
    ViInt32        source,
    ViReal64    hysteresis
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_USER_REFERENCE_HYSTERESIS,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_USER_REFERENCE_HYSTERESIS, hysteresis
                                                ), 3, "Hysteresis");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures an area of signal.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR topOuter/Defines an area above the high signal level which is still considered 
/// HIPAR topOuter/to be high level.
/// HIPAR topInner/Defines an area beneath the high signal level which is still 
/// HIPAR topInner/considered to be high level.
/// HIPAR bottomInner/Defines an area above the low signal level which is still considered 
/// HIPAR bottomInner/to be low level.
/// HIPAR bottomOuter/Defines an area beneath the low signal level which is still considered 
/// HIPAR bottomOuter/to be low level.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevelTube(
    ViSession    instrSession,
    ViInt32        source,
    ViReal64    topOuter,
    ViReal64    topInner,
    ViReal64    bottomInner,
    ViReal64    bottomOuter
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_src[15] = "";
    ViChar    rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TUBE_ABSOLUTE_OUTER_DISTANCE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap_src), 2, "source");
    
    sprintf (rep_cap, "%s,TopOuter", rep_cap_src);
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_TUBE_ABSOLUTE_OUTER_DISTANCE, topOuter
                                                ), 3, "Top Outer");

    sprintf (rep_cap, "%s,TopInner", rep_cap_src);
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_TUBE_ABSOLUTE_OUTER_DISTANCE, topInner
                                                ), 4, "Top Inner");
    
    sprintf (rep_cap, "%s,BottomOuter", rep_cap_src);
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_TUBE_ABSOLUTE_OUTER_DISTANCE, bottomInner
                                                ), 5, "Bottom Inner");

    sprintf (rep_cap, "%s,BottomInner", rep_cap_src);
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_TUBE_ABSOLUTE_OUTER_DISTANCE, bottomOuter
                                                ), 6, "Bottom Outer");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures a percentage of the signal level by which the 
/// HIFN  absolute signal level may be different than the signal level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Defines the source from which the reference is taken.
/// HIPAR relativeOuter/Defines a percentage of the signal level by which the absolute signal 
/// HIPAR relativeOuter/level may be larger than the high signal level or lower than the low 
/// HIPAR relativeOuter/signal level to be considered high or low, respectively.
/// HIPAR relativeInner/Defines a percentage of the signal level by which the absolute signal 
/// HIPAR relativeInner/level may be higher than the low signal level or lower than the high 
/// HIPAR relativeInner/signal level to be considered low or high, respectively.
ViStatus _VI_FUNC rsscope_ConfigureReferenceLevelTubeRelative(
    ViSession    instrSession,
    ViInt32    source,
    ViInt32    relativeOuter,
    ViInt32    relativeInner
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TUBE_RELATIVE_OUTER_DISTANCE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "source");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_TUBE_RELATIVE_OUTER_DISTANCE, relativeOuter
                                               ), 3, "Relative Outer");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_TUBE_RELATIVE_INNER_DISTANCE, relativeInner
                                               ), 4, "Relative Inner");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the record length, the number of recorded 
/// HIFN  waveform points that build the waveform across the acquisition time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR actualRecordLength/Returns the actual number of points the oscilloscope acquires for each 
/// HIPAR actualRecordLength/channel.  The value is equal to or greater than the minimum number of 
/// HIPAR actualRecordLength/points you specify in the rsscope_ConfigureAcquisitionRecord function.  
ViStatus _VI_FUNC rsscope_ActualRecordLength(
    ViSession   instrSession,
    ViInt32*    actualRecordLength
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_HORZ_RECORD_LENGTH,
                                               actualRecordLength), 2, "Actual Record Length");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the sample mode the oscilloscope is currently 
/// HIFN  using.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR sampleMode/Returns the method of adding waveform points to the samples of the ADC 
/// HIPAR sampleMode/in order to fill the record length.
ViStatus _VI_FUNC rsscope_SampleMode(
    ViSession   instrSession,
    ViInt32*    sampleMode
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SAMPLE_MODE,
                                               sampleMode), 2, "SampleMode");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the effective sample rate of the acquired 
/// HIFN  waveform using the current configuration in samples per second.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR sampleRate/Return the sample rate, that is the number of recorded waveform 
/// HIPAR sampleRate/samples per second.
ViStatus _VI_FUNC rsscope_SampleRate(
    ViSession   instrSession,
    ViReal64*   sampleRate
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeViReal64 (instrSession, "",
                                                RSSCOPE_ATTR_HORZ_SAMPLE_RATE,
                                                sampleRate), 2, "Sample Rate");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the attenuation of the probe.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR autoProbeSenseValue/Queries the attenuation of the probe.
ViStatus _VI_FUNC rsscope_AutoProbeSenseValue(
    ViSession   instrSession,
    ViInt32 channel,
    ViInt32 bufferSize,
    ViChar   autoProbeSenseValue[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_ATTENUATION,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_ATTENUATION,
                                                bufferSize,
                                                autoProbeSenseValue), 3, "Auto Probe Sense Value");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function performs an autoset process: analyzes the enabled channel signals, and obtains appropriate horizontal, vertical, and trigger settings to display stable waveforms.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
ViStatus _VI_FUNC rsscope_Autoset(
    ViSession   instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr(rsscope_SetAttributeViString(instrSession, "",RSSCOPE_ATTR_AUTOSCALE, VI_NULL));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures how the oscilloscope acquires data and fills the waveform record.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR acquisitionType/Specify the manner in which you want the oscilloscope to acquire data and fill the waveform record.
ViStatus _VI_FUNC rsscope_ConfigureAcquisitionType(
    ViSession instrSession,
    ViInt32   channel,
    ViInt32   waveform,
    ViInt32   acquisitionType
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[15] = "";
    ViChar   rep_cap_w[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_ACQUISITION_TYPE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_ACQUISITION_TYPE,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_w), 3, "Waveform");
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_w);
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_ACQUISITION_TYPE, acquisitionType), 4, "Acquisition Type");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the common attributes of the acquisition subsystem.  These attributes are the time per record and acquisition start time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR timePerRecord/Pass the time in seconds that corresponds to the record length.  
/// HIPAR acquisitionStartTime_Offset/Specifies the length of time from the trigger event to the first point in the waveform record.  If the value is positive, the first point in the waveform record occurs after the trigger event.  If the 
///           value is negative, the first point in the waveform record occurs before the trigger event.
ViStatus _VI_FUNC rsscope_ConfigureAcquisitionRecord(
    ViSession   instrSession,
    ViReal64    timePerRecord,
    ViReal64    acquisitionStartTime_Offset
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_HORZ_TIME_PER_RECORD, timePerRecord), 2, "Time Per Record");
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_ACQUSITION_START_TIME, acquisitionStartTime_Offset), 3, "Acqusition Start Time");  
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the basic settings for the time axis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR timeScale/Sets the horizontal scale - the time per division on the x-axis - for all channel and math waveforms.
/// HIPAR referencePoint/Sets the reference point of the time scale in % of the display.
/// HIPAR restrictOffset/Ensures that the trigger occurs within within one acquisition cycle.
ViStatus _VI_FUNC rsscope_ConfigureTimeBase(
    ViSession   instrSession,
    ViReal64    timeScale,
    ViInt32     referencePoint,
    ViBoolean   restrictOffset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      model [RSSCOPE_IO_BUFFER_SIZE] = ""; 

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_HORZ_SCALE, timeScale), 2, "Time Scale");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_HORZ_REFERENCE, referencePoint), 3, "Reference Point");

    viCheckErr (rsscope_GetAttributeViString (instrSession, "",
                                               RSSCOPE_ATTR_INSTRUMENT_MODEL,
                                               RSSCOPE_IO_BUFFER_SIZE, model));
    if (strstr(model,"RTO")!=NULL)
    {
        viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
            RSSCOPE_ATTR_ACQUISITION_RESTRICT_OFFSET, restrictOffset), 4, "Restrict Offset");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the roll mode settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR mode/Activates the automatic roll mode.
/// HIPAR minRollModeGain/The roll mode is enabled automatically if the acquisition time exceeds the given value, and if the Mode is set to AUTO.
ViStatus _VI_FUNC rsscope_ConfigureRollMode(
    ViSession   instrSession,
    ViInt32 mode,
    ViInt32 minRollModeGain
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_ROLL_MODE_AUTO, mode), 2, "Roll Mode Auto");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_ROLL_MODE_THRESHOLD, minRollModeGain), 3, "Roll Mode Threshold");  
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the number of horizontal divisions on the screen.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR divisions/Queries the number of horizontal divisions on the screen
ViStatus _VI_FUNC rsscope_QueryDivisions(
    ViSession   instrSession,
    ViInt32*    divisions
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_GetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_HORZ_DIVISIONS, divisions), 2, "Divisions");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the selection to change either the resolution or the record length. The other value remains constant and cannot be changed.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR timeSelectDependency/Selection to change either the resolution or the record length.  
ViStatus _VI_FUNC rsscope_ConfigureTimeSelectDependency(
    ViSession   instrSession,
    ViInt32 timeSelectDependency
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_HORZ_RECORD_SELECTION, timeSelectDependency), 2, "Time Select Dependency");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the sample rate, that is the number of recorded waveform samples per second.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR sampleRate/Sets the sample rate, that is the number of recorded waveform samples per second.
ViStatus _VI_FUNC rsscope_ConfigureSampleRate(
    ViSession   instrSession,
    ViReal64    sampleRate
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_HORZ_SAMPLE_RATE, sampleRate), 2, "Sample Rate");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the time between two waveform points in the record.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR resolution/Sets the time between two waveform points in the record.
ViStatus _VI_FUNC rsscope_ConfigureResolution(
    ViSession   instrSession,
    ViReal64    resolution
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_HORZ_RESOLUTION, resolution), 2, "Resolution");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the sample rate of the ADC, that is the number of points that are sampled by the ADC in one second.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR adcSampleRate/Returns the sample rate of the ADC, that is the number of points that are sampled by the ADC in one second.
ViStatus _VI_FUNC rsscope_QueryADCSampleRate(
    ViSession   instrSession,
    ViReal64*   adcSampleRate
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_HORZ_ADC_SAMPLE_RATE, adcSampleRate), 2, "ADC Sample Rate");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the record length, the number of recorded waveform points that build the waveform across the acquisition time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR recordLength/Sets the record length, the number of recorded waveform 
ViStatus _VI_FUNC rsscope_ConfigureRecordLength(
    ViSession    instrSession,
    ViInt32      recordLength
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_HORZ_RECORD_LENGTH, recordLength), 2, "Record Length");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the limit for the record length to prevent 
/// HIFN  very large records. If you increase the time scale, the resolution 
/// HIFN  remains constant and the record length increases until the limit is 
/// HIFN  reached. Further increase of the time scale changes the resolution and 
/// HIFN  keeps the record length limit.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR lengthLimit/Sets a limit for the record length.
ViStatus _VI_FUNC rsscope_ConfigureRecordLengthLimit(
    ViSession   instrSession,
    ViInt32     lengthLimit
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_HORZ_RECORD_LENGTH_LIMIT, lengthLimit), 2, "Length Limit");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;

}

/// HIFN  This function configures the time of one acquisition, that is the time across the 10 divisions of the diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR acquisitionTime/Sets the time of one acquisition.  
ViStatus _VI_FUNC rsscope_ConfigureAcquisitionTime(
    ViSession   instrSession,
    ViReal64    acquisitionTime
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_HORZ_TIME_PER_RECORD, acquisitionTime), 2, "Acquisition Time");    

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the method of adding waveform points to the samples of the ADC in order to fill the record length.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR resolutionEnhancement/Selects the method of adding waveform points to the samples of the ADC in order to fill the record length.
ViStatus _VI_FUNC rsscope_ConfigureResolutionEnhancement(
    ViSession   instrSession,
    ViInt32     resolutionEnhancement
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_SAMPLE_MODE, resolutionEnhancement), 2, "Resolution Enhancement");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the interpolation method the oscilloscope uses when it cannot sample a voltage for a point in the waveform record.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR interpolation/Pass the interpolation method you want the oscilloscope to 
ViStatus _VI_FUNC rsscope_ConfigureInterpolation(
    ViSession   instrSession,
    ViInt32     interpolation
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_INTERPOLATION, interpolation), 2, "Interpolation");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function activates or deactivates the individual waveforms of the selected channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR enableWaveform/Activates or deactivates a waveform.
ViStatus _VI_FUNC rsscope_ConfigureWaveformState(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViBoolean   enableWaveform
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   rep_cap_channel[25] = "";
    ViChar   rep_cap_wfm[25] = "";
    ViChar   rep_cap[75] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WAVEFORM_STATE,
                                                 "Channel",
                                                 channel-1,
                                                 25,
                                                 rep_cap_channel), 2, "Channel");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WAVEFORM_STATE,
                                                 "Waveform",
                                                 waveform,
                                                 25,
                                                 rep_cap_wfm), 3, "Waveform");

    strcpy (rep_cap, rep_cap_channel);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_wfm);

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_WAVEFORM_STATE, enableWaveform), 3, "Enable Waveform");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the method to reduce the data stream of the ADC to a stream of waveform points with lower sample rate.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR arithmetic/Selects the method to reduce the data stream of the ADC to a stream of waveform points with lower sample rate.
ViStatus _VI_FUNC rsscope_ConfigureWaveformArithmetic(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViInt32     arithmetic
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[15] = "";
    ViChar   rep_cap_w[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WAVEFORM_ACQUISITION_TYPE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WAVEFORM_ACQUISITION_TYPE,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_w), 3, "Waveform");
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_w);

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_WAVEFORM_ACQUISITION_TYPE, arithmetic), 4, "Arithmetic");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the number of waveforms that the oscilloscope  acquires and averages.  After the oscilloscope acquires as many waveforms as you specify, it returns to the idle state.  
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR numberofAverages/Pass the number of waveforms you want the oscilloscope to acquire and to average. After the oscilloscope acquires as many waveforms as you specify, it returns to the idle state.
ViStatus _VI_FUNC rsscope_ConfigureNumberOfAverages(
    ViSession    instrSession,
    ViInt32      numberofAverages
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_NUM_AVERAGES, numberofAverages), 2, "Number of Averages");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the ultra segmentation.  
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR ultraSegmentationEnabled/Switches the Ultra Segmentation mode on and off.
/// HIPAR ultraSegmentationDependecy/The number of acquisitions in a Ultra Segmentation acquisition series depends on the record length.
ViStatus _VI_FUNC rsscope_ConfigureUltraSegmentation(
    ViSession   instrSession,
    ViBoolean   ultraSegmentationEnabled,
    ViBoolean   ultraSegmentationDependecy
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_ULTRA_SEGMENTATION_ENABLED, ultraSegmentationEnabled), 2, "Ultra Segmentation Enabled");
    
    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_ULTRA_SEGMENTATION_DEPENDENCY, ultraSegmentationDependecy), 3, "Ultra Segmentation Dependency");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  If enabled, the instrument starts processing and displaying the data 
/// HIFN  as soon as the acquisition series is captured completely. Depending on 
/// HIFN  the number of acquisitions, it may take some time until the acquisition 
/// HIFN  series is displayed. If the setting is disabled, the instrument only 
/// HIFN  captures the data and stores it in the sample memory.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR autoReplay/Switches auto replay On or Off.
ViStatus _VI_FUNC rsscope_ConfigureUltraSegmentationAutoReplay (ViSession instrSession,
                                                                ViBoolean autoReplay)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_ULTRA_SEGMENTATION_AUTO_REPLAY, autoReplay), 2, "Auto Replay");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the common attributes of the oscilloscope's channel subsystem for a particular channel.  These attributes are the vertical range, vertical offset, coupling, probe attenuation, 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR verticalRange/Sets the voltage range across the 10 vertical divisions of the diagram.
/// HIPAR verticalOffset/Pass the location of the center of the range that you specify with for the Vertical Range parameter. Express the value with respect to ground.
/// HIPAR verticalCoupling/Specify how you want the oscilloscope to couple the input signal for the channel.
/// HIPAR channelEnabled/Switches the channel signal on or off.
ViStatus _VI_FUNC rsscope_ConfigureChannel(
    ViSession    instrSession,
    ViInt32      channel,
    ViBoolean    channelEnabled,
    ViReal64     verticalRange,
    ViReal64     verticalOffset,
    ViInt32      verticalCoupling
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CHANNEL_ENABLED,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_CHANNEL_ENABLED, channelEnabled), 3, "Channel Enabled");
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_VERTICAL_RANGE, verticalRange), 4, "Vertical Range");
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_VERTICAL_OFFSET, verticalOffset), 5, "Vertical Offset"); 

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_VERTICAL_COUPLING, verticalCoupling), 6, "Vertical Coupling");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the connection of the signal to the ground.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR groundConnection/Connects the signal to the ground.
ViStatus _VI_FUNC rsscope_ConfigureChannelGroundConnection(
    ViSession   instrSession,
    ViInt32     channel,
    ViBoolean   groundConnection
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GROUND_CONNECTION_ENABLED,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_GROUND_CONNECTION_ENABLED, groundConnection), 3, "Ground Connection");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the offset voltage. The offset is subtracted to correct an offset-affected signal.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR offset/Sets the offset voltage.
ViStatus _VI_FUNC rsscope_ConfigureChannelOffset(
    ViSession   instrSession,
    ViInt32     channel,
    ViReal64    offset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CHANNEL_OFFSET,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CHANNEL_OFFSET, offset), 3, "Offset");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical scale for the indicated channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR verticalScale/Sets the vertical scale for the indicated channel.
ViStatus _VI_FUNC rsscope_ConfigureChannelVerticalScale(
    ViSession    instrSession,
    ViInt32      channel,
    ViReal64     verticalScale
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_VERTICAL_SCALE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_VERTICAL_SCALE, verticalScale), 3, "Vertical Scale");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the bandwidth limit for the indicated channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR bandwidth/Selects the bandwidth limit for the indicated channel.
ViStatus _VI_FUNC rsscope_ConfigureChannelBandwidth(
    ViSession    instrSession,
    ViInt32      channel,
    ViInt32      bandwidth
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CHANNEL_BANDWIDTH_LIMIT,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_CHANNEL_BANDWIDTH_LIMIT, bandwidth), 3, "Bandwidth");  
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the impedance of the channel for power calculations and measurements.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR inputImpedance/Sets the impedance of the channel for power calculations and measurements.
ViStatus _VI_FUNC rsscope_ConfigureChannelMeasurementImpedance(
    ViSession   instrSession,
    ViInt32     channel,
    ViReal64    inputImpedance
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_INPUT_IMPEDANCE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_INPUT_IMPEDANCE, inputImpedance), 3, "Input Impedance");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the overload status of the specified channel from the status bit.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR overload/Retrieves the overload status of the specified channel from the status bit. When the overload problem is solved, the command resets the status bit. Use VI_FALSE to clear the overload condition.
ViStatus _VI_FUNC rsscope_ConfigureChannelOverload(
    ViSession   instrSession,
    ViInt32     channel,
    ViBoolean   overload
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CHANNEL_OVERLOAD,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_CHANNEL_OVERLOAD, overload), 3, "Overload");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures Digital Signal Processing (DSP) filtering of 
/// HIFN  the acquisition channels.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR enable/Enables the DSP filter.
/// HIPAR cutOff/Sets the limit frequency of the Lowpass filter for input channels.
ViStatus _VI_FUNC rsscope_ConfigureChannelDigitalFilter(
    ViSession   instrSession,
    ViInt32     channel,
    ViBoolean   enable,
    ViReal64    cutOff
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_DIGITAL_FILTER_STATE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_DIGITAL_FILTER_STATE, enable), 3, "Enable");
    
    if (enable)
    {
        viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
            RSSCOPE_ATTR_DIGITAL_FILTER_CUT_OFF, cutOff), 4, "Cut Off");
        
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the filter for the trigger channel(s).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR channel/This control selects the channel.
/// HIPAR coupling/This control selects the channel.
/// HIPAR rfrejectBW/Sets the limit frequency.
ViStatus _VI_FUNC rsscope_ConfigureChannelDigitalFilterTrigger(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     channel,
    ViInt32     coupling,
    ViReal64    rfrejectBW
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[30] = "";
    ViChar      rep_cap_ch[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_DIGITAL_FILTER_TRIGGER_COUPLING,
                                                 "Trigger",
                                                 trigger-1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_DIGITAL_FILTER_TRIGGER_COUPLING,
                                                     coupling
                                                     ), 3, "Coupling");
    
    if(coupling == RSSCOPE_VAL_DSP_TRIGGER_RF_REFECT)
    {
        viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_DIGITAL_FILTER_TRIGGER_RF_REJECT,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap_ch), 2, "Channel");
        
        strcat(rep_cap, ",");
        strcat(rep_cap, rep_cap_ch);
        
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_DIGITAL_FILTER_TRIGGER_RF_REJECT,
                                                    rfrejectBW
                                                    ), 4, "RF Reject BW");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the voltage divider that is part of the DUT 
/// HIFN  before the measuring point. The external attenuation is included in the 
/// HIFN  measurement, and the instrument shows the results that would be 
/// HIFN  measured before the divider.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR attenuation/Sets the attenuation of an external voltage divider.
/// HIPAR scale/This control selects the attenuation scale for an external divider.
ViStatus _VI_FUNC rsscope_ConfigureChannelExternalAttenuation(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     scale,
    ViReal64    attenuation
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EXTERNAL_ATTENUATION_SCALE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_EXTERNAL_ATTENUATION_SCALE,
                                                     scale
                                                     ), 3, "Scale");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_EXTERNAL_ATTENUATION_VALUE,
                                                     attenuation
                                                     ), 4, "Attenuation");

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the probe settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR channelVisible/Switches the channel signal on or off.
/// HIPAR offset/Sets the offset voltage.
ViStatus _VI_FUNC rsscope_ConfigureProbe(
    ViSession    instrSession,
    ViInt32      channel,
    ViBoolean    channelVisible,
    ViReal64     offset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CHANNEL_ENABLED,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_CHANNEL_ENABLED,
                                                 channelVisible), 3, "Channel Visible");

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_CHANNEL_OFFSET,
                                                offset), 4, "Offset");    

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries if the probe at the specified input channel is active 
/// HIFN  (detected) or not active (not detected).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR state/Queries if the probe at the specified input channel is active 
/// HIPAR state/(detected) or not active (not detected).
ViStatus _VI_FUNC rsscope_QueryProbeState(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32*    state
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_STATE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROBE_STATE,
                                                 state), 3, "State");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the probe characteristics.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the Name 
/// HIPAR bufferSize/and Attenuation values.
/// HIPAR type/Queries the type of the probe.
/// HIPAR name/Queries the name of the probe.
/// HIPAR inputImpedance/Queries the termination of the probe.
/// HIPAR inputCapacitance/Queries the input capacitance of the probe.
/// HIPAR attenuation/Queries the attenuation of the probe.
/// HIPAR bandwidth/Queries the bandwidth of the probe.
ViStatus _VI_FUNC rsscope_QueryProbeCharacteristics(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32        bufferSize,
    ViChar        type[],
    ViChar        name[],
    ViReal64*    inputImpedance,
    ViReal64*    inputCapacitance,
    ViChar        attenuation[],
    ViReal64*    bandwidth
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_TYPE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_TYPE,
                                               bufferSize,
                                               type), 4, "Type");
    
    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_NAME,
                                                bufferSize,
                                                name), 5, "Name");
    
    viCheckParm (rsscope_GetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_INPUT_IMPEDANCE,
                                                inputImpedance), 6, "Input Impedance");
    
    viCheckParm (rsscope_GetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_INPUT_CAPACITANCE,
                                                inputCapacitance), 7, "Input Capacitance");
    
    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_ATTENUATION,
                                                bufferSize,
                                                attenuation), 8, "Attenuation");    
    
    viCheckParm (rsscope_GetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_BANDWIDTH,
                                                bandwidth), 9, "Bandwidth");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the action that is started with the micro 
/// HIFN  button on the probe head.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR microButtonAction/Select the action that is started with the micro button on the probe 
/// HIPAR microButtonAction/head.
ViStatus _VI_FUNC rsscope_ConfigureProbeMicroButtonAction(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32        microButtonAction
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_MICRO_BUTTON_ACTION,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_MICRO_BUTTON_ACTION,
                                               microButtonAction), 3, "Micro Button Action");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function selects the input voltage that is measured by the differential active probe.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR measurementType/Selects the input voltage that is measured by the differential active probe.
ViStatus _VI_FUNC rsscope_ConfigureProbeMeasurementType (ViSession instrSession,
                                                         ViInt32 channel,
                                                         ViInt32 measurementType)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_MICRO_BUTTON_ACTION,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_MEASUREMENT_TYPE,
                                               measurementType), 3, "Measurement Type");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function performs an automatic correction of the zero error. If 
/// HIFN  the DUT is ground-referenced, the Auto Zero function can improve the 
/// HIFN  measurement results.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
ViStatus _VI_FUNC rsscope_ProbeAutoZero(
    ViSession    instrSession,
    ViInt32        channel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_AUTO_ZERO,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_AUTO_ZERO, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function performs an automatic compensation for a DC component of 
/// HIFN  the specified input signal using the result of a background mean 
/// HIFN  measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
ViStatus _VI_FUNC rsscope_ProbeSetOffsetToMean(
    ViSession    instrSession,
    ViInt32        channel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_SET_OFFSET_TO_MEAN,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_SET_OFFSET_TO_MEAN, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the probe attributes.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the 
/// HIPAR bufferSize/Software Version, Production Date, Part Number and Serial Number 
/// HIPAR bufferSize/values.
/// HIPAR softwareVersion/Queries the version of the probe firmware.
/// HIPAR productionDate/Queries the production date of the probe.
/// HIPAR partNumber/Queries the R&S part number of the probe.
/// HIPAR serialNumber/Queries the serial number of the probe.
ViStatus _VI_FUNC rsscope_QueryProbeAttributes(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32        bufferSize,
    ViChar      softwareVersion[],
    ViChar      productionDate[],
    ViChar      partNumber[],
    ViChar      serialNumber[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_SOFTWARE_VERSION,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 

    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_SOFTWARE_VERSION,
                                                bufferSize,
                                                softwareVersion), 4, "Software Version");
    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_PRODUCTION_DATE,
                                                bufferSize,
                                                productionDate), 5, "Production Date");
    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_PART_NUMBER,
                                                bufferSize,
                                                partNumber), 6, "Part Number");
    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_SERIAL_NUMBER,
                                                bufferSize,
                                                serialNumber), 7, "Serial Number");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the path and file name of the update package.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR firmwarePath/Configures the path and file name of the update package.
ViStatus _VI_FUNC rsscope_ConfigureProbeFirmwarePath(
    ViSession    instrSession,
    ViInt32        channel,
    ViString    firmwarePath
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_FIRMWARE_PATH,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROBE_FIRMWARE_PATH,
                                                firmwarePath), 3, "Firmware Path");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function starts the update of the probe firmware.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
ViStatus _VI_FUNC rsscope_UpdateProbeFirmware(
    ViSession    instrSession,
    ViInt32        channel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_FIRMWARE_UPDATE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_FIRMWARE_UPDATE, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the update status of the probe firmware.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR firmwareUpdateStatus/Queries the update status of the probe firmware.
ViStatus _VI_FUNC rsscope_QueryProbeFirmwareUpdateStatus(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32*    firmwareUpdateStatus
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_FIRMWARE_UPDATE_STATUS,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_FIRMWARE_UPDATE_STATUS,
                                               firmwareUpdateStatus), 3, "Firmware Update Status");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function starts the selftest of the probe connected to the 
/// HIFN  specified channel input.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
ViStatus _VI_FUNC rsscope_ProbeSelftest(
    ViSession    instrSession,
    ViInt32        channel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_SELFTEST,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_SELFTEST, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the result of a probe selftest for the specified 
/// HIFN  channel input.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the 
/// HIPAR bufferSize/Selftest Results value.
/// HIPAR selftestResult/Queries the pass/fail results of all steps of the probe
ViStatus _VI_FUNC rsscope_QueryProbeSelftestResult(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32        bufferSize,
    ViChar      selftestResult[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   *p2data  = NULL;
    ViUInt32     count = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckErr (viPrintf(instrSession, "PROB%ld:SERV:STES:RES?\n", channel));
    
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2data, &count));
    
    memcpy (selftestResult, p2data, bufferSize);

    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
	if (p2data) free (p2data);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the status of a probe selftest for the specified 
/// HIFN  channel input. When the selftest has finished, the status is passed or 
/// HIFN  failed, otherwise it is undefined.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR selftestStatus/Queries the status of a probe selftest for the specified channel 
/// HIPAR selftestStatus/input. When the selftest has finished, the status is passed or failed, 
/// HIPAR selftestStatus/otherwise it is undefined.
ViStatus _VI_FUNC rsscope_QueryProbeSelftestStatus(
    ViSession    instrSession,
    ViInt32        channel,
    ViInt32*    selftestStatus
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_SELFTEST_STATUS,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_SELFTEST_STATUS,
                                               selftestStatus), 3, "Selftest Status");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures the probe detection mode. Active and
/// HIFN passive voltage probes from Rohde & Schwarz, and also many
/// HIFN common passive voltage probes are detected by the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR mode/This control sets mode of probe detection.
ViStatus _VI_FUNC rsscope_ConfigureProbeDetection (
    ViSession instrSession,
    ViInt32   channel, 
    ViInt32   mode
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_DETECTION_MODE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_DETECTION_MODE,
                                               mode), 3, "Mode");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the probe attenuation. Active and passive 
/// HIFN  voltage probes from Rohde & Schwarz, and also many common passive 
/// HIFN  voltage probes are detected by the instrument. For other probes, you 
/// HIFN  can set the unit and attenuation manually.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR verticalUnit/This control sets the unit for the connected probe type.
/// HIPAR attenuation/Sets the attenuation for the connected probe.
ViStatus _VI_FUNC rsscope_ConfigureProbeAttenuation(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     verticalUnit,
    ViReal64    attenuation
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_VERTICAL_UNIT,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
                                                 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROBE_VERTICAL_UNIT,
                                                     verticalUnit
                                                     ), 4, "Vertical Unit");
                                                 
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_PROBE_ATTENUATION_MANUAL,
                                                    attenuation
                                                    ), 5, "Attenuation");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures the probe gain manually.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR gain/Sets the gain of a current probe.
ViStatus _VI_FUNC rsscope_ConfigureProbeGain (ViSession instrSession,
                                              ViInt32 channel, ViReal64 gain)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_GAIN_MANUAL,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
                                                 
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_PROBE_GAIN_MANUAL,
                                                    gain), 4, "Gain");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures the current probes. Current probes are
/// HIFN not recognized automatically but the parameters of R&S current
/// HIFN probes (R&S RT-ZCxx) are known to the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR predefinedProbe/Document parameter here.
ViStatus _VI_FUNC rsscope_ConfigureCurrentProbePredefined (ViSession instrSession,
                                                           ViInt32 channel,
                                                           ViInt32 predefinedProbe)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROBE_PREDEFINED_CURRENT_PROBE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROBE_PREDEFINED_CURRENT_PROBE,
                                               predefinedProbe), 3, "Predefined Probe");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the calibration settings to align channels if 
/// HIFN  cables of different length are connected to the input connectors.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR sourceFrequency/Frequency value of the internal calibration source. Possible values 
/// HIPAR sourceFrequency/are a 1 GHz sine wave or a 10 MHz square wave.
/// HIPAR operatingMode/Sets the calibration operating mode. To determine the skew offset, use 
/// HIPAR operatingMode/the "Skew" operating mode. It uses the internal channel alignment for 
/// HIPAR operatingMode/best results.
/// HIPAR destination/Sets the output for the calbration signal.
ViStatus _VI_FUNC rsscope_ConfigureCalibration(
    ViSession    instrSession,
    ViInt32        sourceFrequency,
    ViInt32        operatingMode,
    ViInt32        destination
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_CALIBRATION_SOURCE_FREQUENCY,
                                               sourceFrequency
                                               ), 2, "Source Frequency");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_CALIBRATION_OPERATING_MODE,
                                               operatingMode
                                               ), 3, "Operating Mode");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_CALIBRATION_DESTINATION,
                                               destination
                                               ), 4, "Destination");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the extrenal reference oscilator.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR externalReference/Sets the frequency of an external reference input signal that is 
/// HIPAR externalReference/connected to the external reference input on the rear panel.
/// HIPAR useExternalReference/Enables the use of the external reference signal instead of the 
/// HIPAR useExternalReference/internal OCXO reference.
ViStatus _VI_FUNC rsscope_ConfigureReferenceOscillator(
    ViSession   instrSession,
    ViBoolean   useExternalReference,
    ViReal64    externalReference
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_REF_OSCILLATOR_SOURCE,
                                                 useExternalReference?RSSCOPE_VAL_EXT:RSSCOPE_VAL_INT
                                                 ), 2, "Use External Reference");

    if (useExternalReference) 
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                    RSSCOPE_ATTR_REF_OSCILLATOR_FREQUENCY,
                                                    externalReference
                                                    ), 3, "External Reference");
    }

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures skew.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR useSkewOffset/Enables/disables skewOffset.
/// HIPAR skewOffset/Sets an delay value, that is known from the circuit specifics
/// HIPAR skewOffset/but cannot be compensated by the instrument automatically.
ViStatus _VI_FUNC rsscope_ConfigureSkew (ViSession instrSession,
                                         ViInt32 channel,
                                         ViBoolean useSkewOffset,
                                         ViReal64 skewOffset)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SKEW_OFFSET_STATE,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap), 2, "Channel");

    viCheckParm(rsscope_SetAttributeViBoolean (instrSession, rep_cap,
        					RSSCOPE_ATTR_SKEW_OFFSET_STATE, useSkewOffset), 3, "Use Skew Offset");
	
	if (useSkewOffset == VI_TRUE)
	{
		viCheckParm(rsscope_SetAttributeViReal64 (instrSession, rep_cap,
        					RSSCOPE_ATTR_SKEW_OFFSET, skewOffset), 3, "Skew Offset");
	}
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the common attributes of the trigger subsystem.  These attributes are the trigger type and holdoff.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerType/Sets the trigger type.
ViStatus _VI_FUNC rsscope_ConfigureTrigger(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerType
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_TYPE, triggerType), 3, "Trigger Type");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Sets coupling of the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR eventCoupling/Sets the trigger levels of the channels to the values of the indicated event.
/// HIPAR sourceCoupling/Sets the trigger levels of all channels to the value of channel 1 for the indicated trigger event.
ViStatus _VI_FUNC rsscope_ConfigureTriggerCoupling(
    ViSession  instrSession,
    ViInt32    trigger,
    ViBoolean  eventCoupling,
    ViBoolean  sourceCoupling
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_EVENT_COUPLING,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_EVENT_COUPLING, eventCoupling), 3, "Event Coupling");
    
    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE_COUPLING, sourceCoupling), 4, "Source Coupling");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Sets the trigger mode. The trigger mode determines the behaviour of the instrument if no trigger occurs.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerModifier/Sets the trigger mode. The trigger mode determines the behaviour of the instrument if no trigger occurs.
ViStatus _VI_FUNC rsscope_ConfigureTriggerModifier(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerModifier
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_MODIFIER,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_MODIFIER, triggerModifier), 3, "Trigger Modifier");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Sets the trigger level automatically. The attribute is not available for an external trigger source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
ViStatus _VI_FUNC rsscope_TriggerLevelAutoFind(
    ViSession   instrSession,
    ViInt32     trigger
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_LEVEL_AUTO_FIND,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViString(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_LEVEL_AUTO_FIND, VI_NULL), 3, "Trigger");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures the "robust trigger".
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions 
/// HIPAR instrSession/function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR robustTriggerState/Switches the "robust trigger" setting ON or OFF.
ViStatus _VI_FUNC rsscope_ConfigureRobustTriggerState (ViSession instrSession,
                                                       ViInt32 trigger,
                                                       ViBoolean robustTriggerState)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_ROBUST_TRIGGER_STATE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViBoolean (instrSession, rep_cap,
        RSSCOPE_ATTR_ROBUST_TRIGGER_STATE, robustTriggerState), 3, "Robust Trigger State");

Error:
    Rs_UnlockSession (instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures selected trigger level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR channel/Sets the trigger source for the selected trigger type.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and channel.
ViStatus _VI_FUNC rsscope_ConfigureTriggerChannelLevel (ViSession instrSession,
                                                        ViInt32 trigger,
                                                        ViInt32 channel,
                                                        ViReal64 triggerLevel)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_trigger[15] = "";
    ViChar   rep_cap_channel[15] = "";
    ViChar   rep_cap[50] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_LEVEL,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap_trigger), 2, "Trigger");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_LEVEL,
                                                 "Channel",
                                                 channel-1,
                                                 15,
                                                 rep_cap_channel), 2, "Channel");
    strcpy (rep_cap, rep_cap_trigger);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_channel);
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_LEVEL, triggerLevel), 4, "Trigger Level");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the edge trigger.  An edge trigger occurs when the trigger signal passes through the voltage threshold that you specify with the Trigger Level parameter and has the slope that 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and source.
/// HIPAR triggerSlope/Sets the slope for the edge trigger.
ViStatus _VI_FUNC rsscope_ConfigureEdgeTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    triggerLevel,
    ViInt32     triggerSlope
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
    checkErr(rsscope_ConfigureTrigger(instrSession, trigger, RSSCOPE_VAL_EDGE_TRIGGER))

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    if ((triggerSource != RSSCOPE_VAL_EXTERNAL) && (triggerSource != RSSCOPE_VAL_SBUS))
    {
	    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
	        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");        
        
        viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
            RSSCOPE_ATTR_TRIGGER_SLOPE, triggerSlope), 5, "Trigger Slope");

        viCheckParm (rsscope_ConfigureTriggerChannelLevel (instrSession, trigger, triggerSource, triggerLevel), 4, "Trigger Level");

    }
    else
    {
        viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
            RSSCOPE_ATTR_EXTERNAL_TRIGGER_LEVEL, triggerLevel), 4, "Trigger Level"); 
    
        viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
            RSSCOPE_ATTR_EXTERNAL_TRIGGER_SLOPE, triggerSlope), 5, "Trigger Slope"); 
    }
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures parameters of edge trigger for external source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
ViStatus _VI_FUNC rsscope_ConfigureEdgeExternalTrigger (
    ViSession instrSession,
    ViInt32   coupling, 
    ViInt32   filter,
    ViInt32   cutOffFrequency
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_EXTERNAL_TRIGGER_COUPLING, coupling), 2, "Coupling");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_EXTERNAL_TRIGGER_FILTER, filter), 3, "Filter");
        
    if (rsscope_invalidViInt32Range (instrSession, filter, RSSCOPE_VAL_FILTER_LOW_PASS, RSSCOPE_VAL_FILTER_HIGH_PASS) != VI_TRUE)
    {
        viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EXTERNAL_TRIGGER_FILTER_CUT_OFF_FREQENCY,
                                                 "FilterType",
                                                 filter-1,
                                                 15,
                                                 rep_cap), 3, "Filter Type");
    
        viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
            RSSCOPE_ATTR_EXTERNAL_TRIGGER_FILTER_CUT_OFF_FREQENCY, cutOffFrequency), 4, "Cut-Off Frequency");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Connects the analog signal to the ground.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.
/// HIPAR instrSession/instrument session.
/// HIPAR connectToGround/Connects the analog signal to the ground.
ViStatus _VI_FUNC rsscope_ConfigureEdgeExternalTriggerGround(
    ViSession   instrSession,
    ViBoolean   connectToGround
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_EXTERNAL_TRIGGER_GROUND_CONNECTION_ENABLED, connectToGround),
        2, "External Trigger Ground Connection Enabled");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the runt trigger.  A runt trigger occurs when 
/// HIFN  the trigger signal crosses one of the runt thresholds twice without 
/// HIFN  crossing the other runt threshold.  You specify the runt thresholds 
/// HIFN  with the  Runt Low Threshold and Runt High Threshold parameters.  You 
/// HIFN  specify the polarity of the runt with the Runt Polarity parameter.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR runtLowThreshold/Sets the lower voltage threshold.
/// HIPAR runtHighThreshold/Sets the upper voltage threshold.
/// HIPAR runtPolarity/Defines the polarity of a pulse, that is the direction of the first 
/// HIPAR runtPolarity/pulse slope.
ViStatus _VI_FUNC rsscope_ConfigureRuntTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    runtLowThreshold,
    ViReal64    runtHighThreshold,
    ViInt32     runtPolarity
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[30] = "";
    ViChar   rep_cap_c[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (trigger!=RSSCOPE_VAL_TRIGGER_A && trigger!=RSSCOPE_VAL_TRIGGER_R)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_RUNT_LOW_THRESHOLD,
                                                 "TriggerSource",
                                                 triggerSource-1,
                                                 15,
                                                 rep_cap_c), 3, "Trigger Source");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");
    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_RUNT_TRIGGER));

    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_RUNT_POLARITY, runtPolarity), 3, "Runt Polarity"); 

    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_c);
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_RUNT_LOW_THRESHOLD, runtLowThreshold), 4, "Runt Low Threshold");   

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_RUNT_HIGH_THRESHOLD, runtHighThreshold), 4, "Runt High Threshold");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Configures Runt trigger range and condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR trigger/runtWidth/Defines the upper or lower voltage threshold.
/// HIPAR trigger/runtDelta/Defines a range around the runt width specified using Runt Width. This 
/// HIPAR trigger/control is only available if Runt Condition is set to Within or Outside
/// HIPAR trigger/runtCondition/Defines the time limit of the runt pulse in relation to the Runt Width 
/// HIPAR trigger/and Runt Delta settings.
ViStatus _VI_FUNC rsscope_ConfigureRuntTriggerRange(
    ViSession   instrSession,
    ViInt32     trigger,
    ViReal64    runtWidth,
    ViReal64    runtDelta,
    ViInt32     runtCondition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_RUNT_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_RUNT_CONDITION, runtCondition), 5, "Runt Condition");  
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_RUNT_WIDTH, runtWidth), 3, "Runt Width");  
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_RUNT_DELTA, runtDelta), 4, "Runt Delta");  

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the glitch trigger.  A glitch trigger occurs 
/// HIFN  when the trigger signal has a pulse with a width that is less than the 
/// HIFN  glitch width.  You specify the glitch width in the Glitch Width 
/// HIFN  parameter.  You specify the polarity of the pulse with the Glitch 
/// HIFN  Polarity parameter.  The trigger does not actually occur until the edge 
/// HIFN  of a pulse that corresponds to the Glitch Width and Glitch Polarity 
/// HIFN  crosses the threshold you specify in the Trigger Level parameter. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and source.
/// HIPAR glitchWidth/Sets the length of a glitch. The instrument triggers on pulses shorter 
/// HIPAR glitchWidth/ or longer than this value.
/// HIPAR glitchPolarity/Defines the polarity of a pulse, that is the direction of the first 
/// HIPAR glitchPolarity/ pulse slope.
/// HIPAR glitchCondition/Selects which glitches are identified: shorter or longer than the 
/// HIPAR glitchPolarity/ width.
ViStatus _VI_FUNC rsscope_ConfigureGlitchTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    triggerLevel,
    ViReal64    glitchWidth,
    ViInt32     glitchPolarity,
    ViInt32     glitchCondition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (trigger!=RSSCOPE_VAL_TRIGGER_A && trigger!=RSSCOPE_VAL_TRIGGER_R)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");

    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_GLITCH_TRIGGER));
    viCheckParm(rsscope_ConfigureTriggerChannelLevel(instrSession, trigger, triggerSource, triggerLevel), 4, "Trigger Level"); 
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_GLITCH_WIDTH, glitchWidth), 5, "Glitch Width");    

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_GLITCH_POLARITY, glitchPolarity), 6, "Glitch Polarity");   
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_GLITCH_CONDITION, glitchCondition), 7, "Glitch Condition");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the width trigger.  A width trigger occurs 
/// HIFN  when the oscilloscope detects a positive or negative pulse with a width 
/// HIFN  between, or optionally outside, the width thresholds.  You specify the 
/// HIFN  width thresholds with the Width Low Threshold and Width High Threshold 
/// HIFN  parameters.  You specify whether the oscilloscope triggers on pulse 
/// HIFN  widths that are within or outside the width thresholds with the Width 
/// HIFN  Condition parameter.  You specify the polarity of the pulse with the 
/// HIFN  Width Polarity parameter.  The trigger does not actually occur until 
/// HIFN  the edge of a pulse that corresponds to the Width Low Threshold, Width 
/// HIFN  High Threshold, Width Condition, and Width Polarity crosses the 
/// HIFN  threshold you specify in the Trigger Level parameter.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR width/For the ranges "Within" and "Outside", the width defines the center of 
/// HIPAR width/ a range which is defined by the limits "+/-Delta". For the ranges 
/// HIPAR width/ "Shorter" and "Longer", the width defines the maximum and minimum pulse 
/// HIPAR width/ width, respectively.
/// HIPAR widthDelta/Defines a range around the width value.
/// HIPAR trigger/Selects trigger event.
/// HIPAR widthPolarity/Sets the polarity of the pulse.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR widthCondition/Sets how the measured pulse width is compared with the given limit(s).
ViStatus _VI_FUNC rsscope_ConfigureWidthTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    triggerLevel,
    ViReal64    width,
    ViReal64    widthDelta,
    ViInt32     widthPolarity,
    ViInt32     widthCondition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (trigger!=RSSCOPE_VAL_TRIGGER_A && trigger!=RSSCOPE_VAL_TRIGGER_R)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");
    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
											 RSSCOPE_ATTR_TRIGGER_TYPE,
											 RSSCOPE_VAL_WIDTH_TRIGGER));

    viCheckParm(rsscope_ConfigureTriggerChannelLevel(instrSession, trigger, triggerSource, triggerLevel), 4, "Trigger Level");  
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_WIDTH, width), 5, "Width");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_WIDTH_DELTA, widthDelta), 6, "Width Delta");   

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_WIDTH_POLARITY, widthPolarity), 7, "Width Polarity");  

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_WIDTH_CONDITION, widthCondition), 8, "Width Condition");   

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the window trigger. The window trigger checks 
/// HIFN  the signal run in relation to a "window". The window is formed by the 
/// HIFN  upper and lower voltage levels. The event condition is fulfilled, if 
/// HIFN  the waveform enters or leaves the window, or if the waveform stays 
/// HIFN  inside or outside for a time longer or shorter than specified. With the 
/// HIFN  window trigger, you can display longer transient effects.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR windowLowerLimit/Sets the lower voltage limit for the window.
/// HIPAR windowUpperLimit/Sets the upper voltage limit for the window.
/// HIPAR windowWidth/For the ranges "Within" and "Outside", the width defines the center of 
/// HIPAR windowWidth/ a time range which is defined by the limits "Delta".
/// HIPAR windowDelta/Defines a range around the "Width" value.
/// HIPAR windowCondition/Defines the signal run in relation to the window.
ViStatus _VI_FUNC rsscope_ConfigureWindowTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    windowLowerLimit,
    ViReal64    windowUpperLimit,
    ViReal64    windowWidth,
    ViReal64    windowDelta,
    ViInt32     windowCondition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   rep_cap[30] = "";
    ViChar   rep_cap_c[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (trigger!=RSSCOPE_VAL_TRIGGER_A && trigger!=RSSCOPE_VAL_TRIGGER_R)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WINDOW_UPPER_LIMIT,
                                                 "TriggerSource",
                                                 triggerSource-1,
                                                 15,
                                                 rep_cap_c), 3, "Trigger Source");
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");

    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_WINDOW_TRIGGER));
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_WINDOW_CONDITION, windowCondition), 8, "Window Condition");
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_WINDOW_WIDTH, windowWidth), 6, "Window Width");
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_WINDOW_DELTA, windowDelta), 7, "Window Delta");    

    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_c);

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_WINDOW_UPPER_LIMIT, windowUpperLimit), 4, "Window Upper Limit");   

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_WINDOW_LOWER_LIMIT, windowLowerLimit), 3, "Window Lower Limit");   
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error; 
}

/// HIFN  This function configures the timeout trigger. The timeout trigger 
/// HIFN  event checks if the signal stays above or below the threshold voltage 
/// HIFN  for a specified time lapse. In other words, the event occurs if the 
/// HIFN  trigger source does not have the expected transition within the 
/// HIFN  specified time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and source.
/// HIPAR timeoutValue/Defines the time limit for the timeout at which the instrument 
/// HIPAR timeoutValue/ triggers.
/// HIPAR timeoutCondition/Defines the relation of the signal level to the trigger level.
ViStatus _VI_FUNC rsscope_ConfigureTimeoutTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    triggerLevel,
    ViReal64    timeoutValue,
    ViInt32     timeoutCondition
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (trigger!=RSSCOPE_VAL_TRIGGER_A && trigger!=RSSCOPE_VAL_TRIGGER_R)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");

    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_TIMEOUT_TRIGGER));

	viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_TIMEOUT_VALUE, timeoutValue), 5, "Timeout Value"); 
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TIMEOUT_CONDITION, timeoutCondition), 6, "Timeout Condition"); 

    viCheckParm(rsscope_ConfigureTriggerChannelLevel(instrSession, trigger,
        triggerSource, triggerLevel), 4, "Trigger Level");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The interval trigger analyzes the time between two pulses. While the 
/// HIFN  interval trigger can only analyze either positive or negative polarity, 
/// HIFN  searching for an interval is also possible for both polarities at the 
/// HIFN  same time ("Either").
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and source.
/// HIPAR intervalWidth/Defines the time between two pulses.
/// HIPAR intervalDelta/Defines a range around the "Interval width" value.
/// HIPAR intervalPolarity/Defines the polarity of a pulse, that is the direction of the first 
/// HIPAR intervalPolarity/ pulse slope.
/// HIPAR intervalCondition/Defines the range of an interval in relation to the interval width.
ViStatus _VI_FUNC rsscope_ConfigureIntervalTriggerSource(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     triggerSource,
    ViReal64    triggerLevel,
    ViReal64    intervalWidth,
    ViReal64    intervalDelta,
    ViInt32     intervalPolarity,
    ViInt32     intervalCondition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (trigger!=RSSCOPE_VAL_TRIGGER_A && trigger!=RSSCOPE_VAL_TRIGGER_R)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");

    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_INTERVAL_TRIGGER));
    viCheckParm(rsscope_ConfigureTriggerChannelLevel(instrSession, trigger,
        triggerSource, triggerLevel), 4, "Trigger Level");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_INTERVAL_WIDTH, intervalWidth), 5, "Interval Width");  
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_INTERVAL_DELTA, intervalDelta), 6, "Interval Delta");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_INTERVAL_POLARITY, intervalPolarity), 7, "Interval Polarity");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_INTERVAL_CONDITION, intervalCondition), 8, "Interval Condition");  
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The slew rate trigger, also known as transition trigger, can detect 
/// HIFN  fast or slow edges selectively. It triggers on edges, if the transition 
/// HIFN  time from the lower to higher voltage level (or vice versa) is shorter 
/// HIFN  or longer as defined, or outside a specified time range. The trigger 
/// HIFN  event finds slew rates faster than expected or permissible to avoid 
/// HIFN  overshooting and other interfering effects. It also detects very slow 
/// HIFN  edges violating the timing in pulse series.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR slewRateCondition/Defines the time limit for the slew rate in relation to the upper or lower trigger level.
/// HIPAR slewRateUpperLimit/Defines the upper voltage threshold.
/// HIPAR slewRatePolarity/Selects the edge type for the trigger event.
/// HIPAR slewRateLowerLimit/Defines the lower voltage threshold.
ViStatus _VI_FUNC rsscope_ConfigureSlewRateTriggerSource(
    ViSession   instrSession,
    ViInt32 trigger,
    ViInt32 triggerSource,
    ViReal64    slewRateLowerLimit,
    ViReal64    slewRateUpperLimit,
    ViInt32 slewRatePolarity,
    ViInt32 slewRateCondition
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[30] = "";
    ViChar   rep_cap_c[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_SOURCE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SLEW_UPPER_LIMIT,
                                                 "TriggerSource",
                                                 triggerSource-1,
                                                 15,
                                                 rep_cap_c), 3, "Trigger Source");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 3, "Trigger Source");
    
    checkErr(rsscope_SetAttributeViInt32 (instrSession, rep_cap,
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_SLEW_RATE_TRIGGER));
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_SLEW_POLARITY, slewRatePolarity), 6, "Slew Rate Polarity");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_SLEW_CONDITION, slewRateCondition), 7, "Slew Rate Condition");

    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_c);

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_SLEW_UPPER_LIMIT, slewRateUpperLimit), 5, "Slew Rate Upper Limit");    
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
        RSSCOPE_ATTR_SLEW_LOWER_LIMIT, slewRateLowerLimit), 4, "Slew Rate Lower Limit");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configure the slew rate range.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR slewRate/For the ranges "Within" and "Outside", the slew rate defines the 
/// HIPAR slewRate/ center of a range which is defined by the limits "Delta".
/// HIPAR slewRateDelta/Defines a time range around the slew rate.
ViStatus _VI_FUNC rsscope_ConfigureSlewRateTriggerRange(
    ViSession   instrSession,
    ViInt32 trigger,
    ViReal64    slewRate,
    ViReal64    slewRateDelta
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SLEW_RATE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_SLEW_RATE, slewRate), 3, "Slew Rate"); 

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
        RSSCOPE_ATTR_SLEW_DELTA, slewRateDelta), 4, "Slew Rate Delta");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  With the Data2Clock event - also known as setup/hold - you can analyze 
/// HIFN  the relative timing between two signals: a data signal and the 
/// HIFN  synchronous clock signal. Many systems require, that the data signal 
/// HIFN  must be steady for some time before and after the clock edge, for 
/// HIFN  example, the data transmission on parallel interfaces. With this 
/// HIFN  trigger type, you can also test the time correlation of sideband and 
/// HIFN  inband signals. The event occurs if the data signal crosses the data 
/// HIFN  level during the setup and hold time. The reference point for the time 
/// HIFN  measurement is defined by clock level and clock edge.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR holdTime/Sets the minimum time after the clock edge while the data signal must 
/// HIPAR holdTime/ stay steady above or below the data level. The hold time can be 
/// HIPAR holdTime/ negative. In this case, the setup time is always positive. The 
/// HIPAR holdTime/hold interval starts before the clock edge (setup time) and ends 
/// HIPAR holdTime/ before the clock edge (hold time). If you change the negative hold 
/// HIPAR holdTime/ time, the setup time is adjusted by the intrument.
/// HIPAR setupTime/Sets the minimum time before the clock edge while the data signal must 
/// HIPAR setupTime/ stay steady above or below the data level. The setup time can be 
/// HIPAR setupTime/ negative. In this case, the hold time is always positive. The 
/// HIPAR setupTime/ hold interval starts after the clock edge (setup time) and ends 
/// HIPAR setupTime/ after the clock edge (hold time). If you change the negative setup 
/// HIPAR setupTime/ time, the hold time is adjusted by the intrument.
/// HIPAR clockLevel/Sets the voltage level for the clock signal.
/// HIPAR data2ClockPolarity/Sets the edge of the clock signal to define the time reference point 
/// HIPAR data2ClockPolarity/ for the setup and hold time.
/// HIPAR clockSource/Sets the source of clock signal.
/// HIPAR dataLevel/Sets the voltage level of data signal.
ViStatus _VI_FUNC rsscope_ConfigureData2ClockTriggerSource (ViSession instrSession,
                                                            ViInt32 triggerSource,
                                                            ViReal64 dataLevel,
                                                            ViInt32 clockSource,
                                                            ViReal64 clockLevel,
                                                            ViReal64 holdTime,
                                                            ViReal64 setupTime,
                                                            ViInt32 data2ClockPolarity)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "TrigA",
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 2, "Trigger Source");
    
    checkErr(rsscope_SetAttributeViInt32 (instrSession, "TrigA",
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_DATA_TO_CLOCK_TRIGGER));

	viCheckParm (rsscope_ConfigureTriggerChannelLevel (instrSession,
                                                       RSSCOPE_VAL_TRIGGER_A,
                                                       triggerSource, dataLevel), 3, "Data Level");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_DATA2CLOCK_SOURCE, clockSource), 4, "Clock Source");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
        RSSCOPE_ATTR_DATA2CLOCK_LEVEL, clockLevel), 5, "Clock Level");  
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
        RSSCOPE_ATTR_DATA2CLOCK_HOLD_TIME, holdTime), 6, "Hold Time");  

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
        RSSCOPE_ATTR_DATA2CLOCK_SETUP_TIME, setupTime), 7, "Setup Time");   

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_DATA2CLOCK_POLARITY, data2ClockPolarity), 8, "Data2Clock Polarity");   

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines how the range of a pulse width is defined for keeping up the 
/// HIFN  true result of the pattern condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR patternMode/Adds additional time limitation to the pattern definition.
/// HIPAR timeoutCondition/Defines the condition for the timeout.
/// HIPAR patternWidth/For the ranges "Within" and "Outside", the width defines the center of 
/// HIPAR patternWidth/ a range which is defined by the limits "Delta".
/// HIPAR patternDelta/Defines a range around the width value.
/// HIPAR patternCondition/Defines how the range of a pulse width is defined for keeping up the 
/// HIPAR patternCondition/  true result of the pattern condition.
/// HIPAR timeout/Defines how long the result of the pattern condition must be true or 
/// HIPAR timeout/ false.
ViStatus _VI_FUNC rsscope_ConfigurePatternTriggerSource (ViSession instrSession,
                                                         ViInt32 patternMode,
                                                         ViInt32 timeoutCondition,
                                                         ViReal64 timeout,
                                                         ViReal64 patternWidth,
                                                         ViReal64 patternDelta,
                                                         ViInt32 patternCondition)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr(rsscope_SetAttributeViInt32 (instrSession, "TrigA",
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_PATTERN_TRIGGER));
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_PATTERN_MODE, patternMode), 2, "Pattern Mode");    
    
    if (patternMode == RSSCOPE_VAL_PATTERN_TIMEOUT)
    {
        viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
            RSSCOPE_ATTR_PATTERN_TIMEOUT_MODE, timeoutCondition), 3, "Timeout Condition");

        viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
            RSSCOPE_ATTR_PATTERN_TIMEOUT, timeout), 4, "Timeout");  
    }
    if (patternMode == RSSCOPE_VAL_PATTERN_WIDTH)
    {
        viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
            RSSCOPE_ATTR_PATTERN_WIDTH, patternWidth), 5, "Pattern Width");

        viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
            RSSCOPE_ATTR_PATTERN_DELTA, patternDelta), 6, "Pattern Delta"); 

        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, NULL,
            RSSCOPE_ATTR_PATTERN_CONDITION, patternCondition), 7, "Pattern Condition"); 
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The serial pattern event is used to trigger on signals with serial 
/// HIFN  data patterns in relation to a clock signal - for example, on bus 
/// HIFN  signals like the I2C bus. For convenient and comprehensive triggering 
/// HIFN  on specific serial data, options for serial protocol analysis are 
/// HIFN  provided.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR clockSource/Defines the input channel of the clock signal.
/// HIPAR clockLevel/Defines the voltage level for the clock signal.
/// HIPAR pattern/The pattern contains the bits of the serial data to be found in the 
/// HIPAR pattern/ data stream. The maximum length of the pattern is 128 bit. You can 
/// HIPAR pattern/ enter the pattern in binary or hexadecimal format.
/// HIPAR patternPolarity/Together with the clock level, the clock edge defines the point in 
/// HIPAR patternPolarity/ time when the state of the data signal is checked.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR dataLevel/Sets the trigger level for the specified event and source.
ViStatus _VI_FUNC rsscope_ConfigureSerialPatternTriggerSource (ViSession instrSession,
                                                               ViInt32 triggerSource,
                                                               ViReal64 dataLevel,
                                                               ViInt32 clockSource,
                                                               ViReal64 clockLevel,
                                                               ViString pattern,
                                                               ViInt32 patternPolarity)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "TrigA",
        RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 2, "Trigger Source");
    
    checkErr(rsscope_SetAttributeViInt32 (instrSession, "TrigA",
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_SERIAL_PATTERN_TRIGGER));
    viCheckParm(rsscope_ConfigureTriggerChannelLevel (instrSession,
                                                      RSSCOPE_VAL_TRIGGER_A,
                                                      triggerSource, dataLevel), 3, "Data Level");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_SERIAL_PATTERN_SOURCE, clockSource), 4, "Clock Source");
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, NULL,
        RSSCOPE_ATTR_SERIAL_PATTERN_LEVEL, clockLevel), 5, "Clock Level");

    viCheckParm(rsscope_SetAttributeViString(instrSession, NULL,
        RSSCOPE_ATTR_SERIAL_PATTERN, pattern), 4, "Pattern");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, NULL,
        RSSCOPE_ATTR_SERIAL_PATTERN_POLARITY, patternPolarity), 5, "Pattern Polarity");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function enables the decoding of the selected bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR protocol/Enables the decoding of the selected bus.
ViStatus _VI_FUNC rsscope_ConfigureSerialBusTriggerSource (ViSession instrSession,
                                                           ViInt32 serialBus,
                                                           ViInt32 protocol)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_STATE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckErr(rsscope_SetAttributeViInt32(instrSession, "TrigA",
        RSSCOPE_ATTR_TRIGGER_SOURCE, RSSCOPE_VAL_SBUS));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_TYPE, 
                                                 protocol
                                                 ), 3, "Protocol");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the NFC trigger. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.  
/// HIPAR technology/Selects the NFC technology, the communication protocol used by the 
/// HIPAR technology/input signal.
/// HIPAR event/Sets the event to be triggered on.
/// HIPAR bitRate/Sets the bit rate of the signal.
ViStatus _VI_FUNC rsscope_ConfigureNFCTrigger (ViSession instrSession,
                                               ViInt32 triggerSource,
                                               ViInt32 technology,
                                               ViInt32 bitRate, ViInt32 event,
											   ViReal64 triggerLevel)
{
	ViStatus    error = VI_SUCCESS;
	ViChar  rep_cap[15] = ""; 
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
	if (rsscope_invalidViInt32Range (instrSession, triggerSource, RSSCOPE_VAL_CHANNEL1, RSSCOPE_VAL_CHANNEL4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger Source");
    }
	
	sprintf (rep_cap, "TrigA,CH%ld", triggerSource); 
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "TrigA",
        	RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 2, "Trigger Source");
	
	checkErr(rsscope_SetAttributeViInt32 (instrSession, "TrigA",
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_NFC_TRIGGER));

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_NFC_TRIGGER_TECHNOLOGY, 
                                                 technology), 3, "Technology");
	
	if (technology == RSSCOPE_VAL_NFC_F)
	{
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
	                                                 RSSCOPE_ATTR_NFC_TRIGGER_BIT_RATE, 
	                                                 bitRate), 4, "Bit Rate");
	}
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_NFC_TRIGGER_EVENT, 
                                                 event), 5, "Event");
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
        										 RSSCOPE_ATTR_TRIGGER_LEVEL, 
												 triggerLevel), 6, "Trigger Level");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the TV trigger.       
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR standard/Sets the TV standard.
/// HIPAR mode/Selects the lines or fields on which the instrument can trigger. 
/// HIPAR mode/Available modes depend on the scanning system.
/// HIPAR lineNumber/Specifies the line number to trigger on. This control is relevant if 
/// HIPAR lineNumber/Mode is set to Line.
/// HIPAR lineField/Sets the field in which the line number is counted. This control is 
/// HIPAR lineField/only relevant for NTSC signals
/// HIPAR triggerLevel/Defines the voltage level for the data signal.
/// HIPAR signalPolarity/Sets the polarity of the signal. Note that the sync pulse has the 
/// HIPAR signalPolarity/opposite polarity, for example, a positive signal has a negative sync 
/// HIPAR signalPolarity/pulse.
ViStatus _VI_FUNC rsscope_ConfigureTVTrigger (ViSession instrSession,
                                              ViInt32 triggerSource,
                                              ViInt32 standard, ViInt32 mode,
                                              ViInt32 lineNumber,
                                              ViInt32 lineField,
                                              ViReal64 triggerLevel,
                                              ViInt32 signalPolarity)
{
	ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, triggerSource, RSSCOPE_VAL_CHANNEL1, RSSCOPE_VAL_CHANNEL4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger Source");
    }
	
	sprintf (rep_cap, "TrigA,CH%ld", triggerSource);
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "TrigA",
        	RSSCOPE_ATTR_TRIGGER_SOURCE, triggerSource), 2, "Trigger Source");
	
	checkErr (rsscope_SetAttributeViInt32 (instrSession, "TrigA",
										  RSSCOPE_ATTR_TRIGGER_TYPE,
										  RSSCOPE_VAL_TV_TRIGGER));
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_STANDARD, standard), 3, "Standard"); 
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_MODE, mode), 4, "Mode"); 
	
	if (mode == RSSCOPE_VAL_TV_MODE_LINE)
	{
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
        		RSSCOPE_ATTR_TV_TRIGGER_LINE_NUMBER, lineNumber), 5, "Line Number"); 
	}
	
	if (standard == RSSCOPE_VAL_TV_STANDARD_NTSC)
	{
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
        		RSSCOPE_ATTR_TV_TRIGGER_FIELD, lineField), 6, "Line Field"); 
	}
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
        	RSSCOPE_ATTR_TRIGGER_LEVEL, triggerLevel), 7, "Trigger Level");
	
	viCheckParm (rsscope_SetAttributeViInt32(instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_POLARITY, signalPolarity), 8, "Signal Polarity"); 

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the TV trigger custom settings.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR pulseType/Sets the type of the sync pulse.
/// HIPAR scanMode/Sets the scanning system.
/// HIPAR linePeriod/Sets the duration of a line, the time between two successive sync 
/// HIPAR linePeriod/pulses.
/// HIPAR pulseWidth/Sets the width of the sync pulse. 
ViStatus _VI_FUNC rsscope_ConfigureTVTriggerCustomSettings (ViSession instrSession,
                                                            ViInt32 pulseType,
                                                            ViReal64 linePeriod,
                                                            ViReal64 pulseWidth,
                                                            ViInt32 scanMode)
{
	ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_PULSE_TYPE, pulseType), 2, "Pulse Type"); 
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_LINE_PERIOD, linePeriod), 3, "Line Period"); 
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_PULSE_WIDTH, pulseWidth), 4, "Pulse Width"); 
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
        	RSSCOPE_ATTR_TV_TRIGGER_SCAN_MODE, scanMode), 5, "Scan Mode"); 

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The rejection of noise by settting a hysteresis avoids unwanted 
/// HIFN  trigger events caused by noise oscillation around the trigger level. 
/// HIFN  You can select the hysteresis mode and value for each channel, or 
/// HIFN  couple the trigger levels and set the same hysteresis for all channels.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR hysteresisMode/Selects how the hysteresis is set.
/// HIPAR absoluteHysteresis/Defines a range in absolute values around the trigger level. If the 
/// HIPAR absoluteHysteresis/ signal jitters inside this range and crosses the trigger level thereby, 
/// HIPAR absoluteHysteresis/ no trigger event occurs.
ViStatus _VI_FUNC rsscope_ConfigureNoiseReject(
    ViSession   instrSession,
    ViInt32 trigger,
    ViInt32 triggerSource,
    ViInt32 hysteresisMode,
    ViReal64    absoluteHysteresis
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   rep_cap[30] = "";
    ViChar   rep_cap_c[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_NOISE_REJECT_HYSTERESIS_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_NOISE_REJECT_HYSTERESIS_MODE,
                                                 "TriggerSource",
                                                 triggerSource-1,
                                                 15,
                                                 rep_cap_c), 3, "Trigger Source");
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_c);

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
        RSSCOPE_ATTR_NOISE_REJECT_HYSTERESIS_MODE, hysteresisMode), 4, "Hysteresis Mode");  
    
    if (hysteresisMode == RSSCOPE_VAL_MANUAL)
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
            RSSCOPE_ATTR_NOISE_REJECT_HYSTERESIS, absoluteHysteresis), 5, "Absolute Hysteresis");   
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Displays the trigger levels in the diagrams until you disable
/// HIFN  this option.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR showTriggerLinesPermanently/Displays the trigger levels in the diagrams until you disable
/// HIPAR showTriggerLinesPermanently/this option.
ViStatus _VI_FUNC rsscope_ConfigureTriggerLinesDisplay (ViSession instrSession,
                                                        ViBoolean showTriggerLinesPermanently)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_LINES_DISPLAY, showTriggerLinesPermanently),
        2, "ShowTrigger Lines Permanently");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the pulse that is provided to the EXT TRIGGER 
/// HIFN  OUT connector on the rear panel when a trigger occurs.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR enable/Enables/disbales the trigger out signal that is provided to the EXT 
/// HIPAR enable/TRIGGER OUT connector on the rear panel when a trigger occurs.
/// HIPAR polarity/Sets the polarity of the trigger out pulse.
/// HIPAR pulseLength/Sets the length of the trigger out pulse.
ViStatus _VI_FUNC rsscope_ConfigureTriggerOutSignal(
    ViSession   instrSession,
    ViBoolean   enable,
    ViInt32     polarity,
    ViReal64    pulseLength
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_TRIGGER_OUT_STATE,
                                                 enable
                                                 ), 2, "Enable");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_TRIGGER_OUT_POLARITY,
                                                 polarity
                                                 ), 3, "Polarity");
                                                 
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                RSSCOPE_ATTR_TRIGGER_OUT_PULSE_LENGTH,
                                                pulseLength
                                                ), 4, "Pulse Length");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function queries the delay of the first pulse edge to the trigger 
/// HIFN  point. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR delay/Returns the delay of the first pulse edge to the trigger point.
ViStatus _VI_FUNC rsscope_QueryTriggerOutDelay(
    ViSession   instrSession,
    ViReal64*   delay
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
                                                 
    viCheckParm (rsscope_GetAttributeViReal64 (instrSession, "",
                                                RSSCOPE_ATTR_TRIGGER_OUT_DELAY,
                                                delay
                                                ), 2, "Delay");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  By qualifying a trigger event, you can logically combine the trigger 
/// HIFN  signal with the state of other digital channel signals.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR triggerType/Sets the trigger type.
/// HIPAR trigger/Selects trigger event.
/// HIPAR qualificationEnabled/Enables the use of the qualification definition for the selected 
/// HIPAR qualificationEnabled/ trigger event.
/// HIPAR channel/Sets the trigger source for the selected trigger type.
/// HIPAR channelEnabled/Selects one of the channels and the specified trigger event to be 
/// HIPAR channelEnabled/ considered for qualification. You can select all channel signals except 
/// HIPAR channelEnabled/ for the trigger source. In pattern trigger setup, the trigger source 
/// HIPAR channelEnabled/ channel is selected by default, and you can select all other channel 
/// HIPAR channelEnabled/  signals.
/// HIPAR channelLogic/Defines the logic for the indicated channel.
ViStatus _VI_FUNC rsscope_ConfigureTriggerQualification(
    ViSession   instrSession,
    ViInt32 triggerType,
    ViInt32 trigger,
    ViBoolean   qualificationEnabled,
    ViInt32 channel,
    ViBoolean   channelEnabled,
    ViInt32 channelLogic
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[50] = "";
    ViChar  rep_cap_type[15] = "";
    ViChar  rep_cap_c[15] = "";
	ViChar  rep_cap_t[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_B) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Trigger");
    }
    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL1, RSSCOPE_VAL_CHANNEL4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Channel");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_QUALIFICATION_CHANNEL_ENABLED,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap_t), 3, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_QUALIFICATION_CHANNEL_ENABLED,
                                                 "TriggerType",
                                                 triggerType,
                                                 15,
                                                 rep_cap_type), 2, "Trigger Type");
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_QUALIFICATION_CHANNEL_ENABLED,
                                                 "TriggerChannel",
                                                 channel-1,
                                                 15,
                                                 rep_cap_c), 2, "Channel");
    strcpy (rep_cap, rep_cap_t);
	strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_type);

    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_c);

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_QUALIFICATION_CHANNEL_ENABLED, channelEnabled), 6, "Channel Enabled"); 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_QUALIFICATION_LOGIC, channelLogic), 7, "Channel Logic");

    strcpy (rep_cap, rep_cap_t);
	strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_type);
	viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_QUALIFICATION_ENABLED, qualificationEnabled), 4, "Qualification Enabled");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the logic for the indicated channel combination.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR triggerType/Sets the trigger type.
/// HIPAR trigger/Selects trigger event.
/// HIPAR qualificationEnabled/Enables the use of the qualification definition for the selected 
/// HIPAR qualificationEnabled/  trigger event.
/// HIPAR channelCombination/Sets the trigger source for the selected trigger type.
/// HIPAR multichannelLogic/Defines the logic for the indicated channels.
ViStatus _VI_FUNC rsscope_ConfigureTriggerQualificationMulitchannelLogic(
    ViSession   instrSession,
    ViInt32 triggerType,
    ViInt32 trigger,
    ViBoolean   qualificationEnabled,
    ViInt32 channelCombination,
    ViInt32 multichannelLogic
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[50] = "";
    ViChar  rep_cap_type[15] = "";
    ViChar  rep_cap_c[15] = "";
    ViChar  rep_cap_t[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_B) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_QUALIFICATION_MULTICHANNEL_LOGIC,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap_t), 3, "Trigger");
    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_QUALIFICATION_MULTICHANNEL_LOGIC,
                                                 "TriggerType",
                                                 triggerType,
                                                 15,
                                                 rep_cap_type), 2, "Trigger Type");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_TRIGGER_QUALIFICATION_MULTICHANNEL_LOGIC,
                                                 "TriggerMultiChannel",
                                                 channelCombination-1,
                                                 15,
                                                 rep_cap_c), 5, "Channel Combination");
    
    strcpy (rep_cap, rep_cap_t);
	strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_type);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_c);

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_QUALIFICATION_MULTICHANNEL_LOGIC, multichannelLogic), 6, "Multichannel Logic");
    strcpy (rep_cap, rep_cap_t);
	strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_type);
    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_TRIGGER_QUALIFICATION_ENABLED, qualificationEnabled), 4, "Qualification Enabled"); 

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The "A only" sequence contains an A-event and the holdoff setting as 
/// HIFN  optional condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR holdoffMode/Selects the method to define the holdoff condition. The trigger 
/// HIPAR holdoffMode/ holdoff defines when the next trigger after the current will be 
/// HIPAR holdoffMode/ recognized. Thus, it affects the next trigger to occur after the 
/// HIPAR holdoffMode/ current one. Holdoff helps to obtain stable triggering when the 
/// HIPAR holdoffMode/ oscilloscope is triggering on undesired events.
/// HIPAR holdoffTime/Defines the holdoff time period. The next trigger occurs only after 
/// HIPAR holdoffTime/ this time has passed.
ViStatus _VI_FUNC rsscope_ConfigureAOnlyTriggerSequence(
    ViSession   instrSession,
    ViInt32 holdoffMode,
    ViReal64    holdoffTime,
    ViInt32     holdoffEvents,
    ViReal64    randomMinTime,
    ViReal64    randomMaxTime)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr(rsscope_SetAttributeViInt32 (instrSession, "",
                                            RSSCOPE_ATTR_TRIGGER_SEQUENCE_MODE,
                                            RSSCOPE_VAL_SEQ_AONLY));

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_MODE, holdoffMode), 2, "Holdoff Mode");
    
    switch (holdoffMode)
    {
        case RSSCOPE_VAL_HOLDOFF_TIME:
            viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
                RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_TIME, holdoffTime), 3, "Holdoff Time");
            break;

        case RSSCOPE_VAL_HOLDOFF_EVENTS:
            viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
                RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_EVENTS, holdoffEvents), 4, "Holdoff Events");   
            break;

        case RSSCOPE_VAL_HOLDOFF_RANDOM:
            viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
                RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_RANDOM_MINIMUM_TIME, randomMinTime), 5, "Random Min Time");

            viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
                RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_RANDOM_MAXIMUM_TIME, randomMaxTime), 6, "Random Max Time");   
            break;
        default:
            break;
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN Returns the resulting holdoff time if the holdoff mode is set to AUTO: Auto time = Auto time scaling * Horizontal scale.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_QueryAOnlyTriggerSequenceAutoTimeResult (
    ViSession   instrSession,
    ViReal64    *autoTime
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (rsscope_GetAttributeViReal64 (instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_AUTO_TIME_RESULT, autoTime)); 

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Sets the auto time scaling factor the horizontal scale is multipied with: Auto time = 
/// HIFN  Auto time scaling * Horizontal scale. The setting is relevant if the holdoff mode is set to AUTO.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_TriggerSequenceHoldoffAutoScale (
    ViSession   instrSession,
    ViReal64    autoScale
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_HOLDOFF_AUTO_SCALE, autoScale), 2, "Auto Scale");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The complex trigger sequence "A -> B -> R" consists of two trigger 
/// HIFN  events - A and B - and an optional reset condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_ConfigureABRTriggerSequence(
    ViSession   instrSession,
    ViBoolean   eventCoupling,
    ViReal64    sequenceDelay,
    ViInt32     bEventsCount,
    ViBoolean   resetByTimeoutEnabled,
    ViReal64    resetTimeout,
    ViBoolean   resetByEventEnabled
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr(rsscope_SetAttributeViInt32 (instrSession, "",
                                            RSSCOPE_ATTR_TRIGGER_SEQUENCE_MODE,
                                            RSSCOPE_VAL_SEQ_ABR));

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "TrigA",
        RSSCOPE_ATTR_TRIGGER_EVENT_COUPLING, eventCoupling), 2, "Event Coupling");  
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_DELAY, sequenceDelay), 3, "Sequence Delay");  

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_B_EVENTS_COUNT, bEventsCount), 4, "B-Events Count");  

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_RESET_BY_TIMEOUT_ENABLED, resetByTimeoutEnabled), 5, "Reset By Timeout Enabled"); 

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_RESET_TIMEOUT, resetTimeout), 6, "Reset Timeout");    

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, "",
        RSSCOPE_ATTR_TRIGGER_SEQUENCE_RESET_EVENT_ENABLED, resetByEventEnabled), 7, "Reset By Event Enabled");  

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures persistence.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR enable/If enabled, each new data point in the diagram area remains on the 
/// HIPAR enable/screen for the defined duration. If disabled, the signal value is only 
/// HIPAR enable/displayed as long as it actually occurs.
/// HIPAR infinite/If persistence is enabled, each new data point in the diagram area 
/// HIPAR infinite/remains on the screen infinitely until is disabled.
/// HIPAR time/If persistence is enabled, each new data point in the diagram area 
/// HIPAR time/remains on the screen for the duration defined here.
ViStatus _VI_FUNC rsscope_ConfigurePersistence(
    ViSession    instrSession,
    ViBoolean    enable,
    ViBoolean    infinite,
    ViReal64    time
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_PERSISTENCE_STATE,
                                                 enable
                                                 ), 2, "Enable");
    
    if (enable == VI_TRUE)
    {
        viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                     RSSCOPE_ATTR_INFINITE_PERSISTENCE,
                                                     infinite
                                                     ), 3, "Infinite");
        if (infinite == VI_FALSE)
            {
                viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                            RSSCOPE_ATTR_PERSISTENCE_TIME,
                                                            time
                                                                ), 4, "Time");
            }
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Resets the display, removing persistent values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_ResetPersistence(
    ViSession    instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_PERSISTENCE_RESET,
                                                VI_NULL
                                                ), 1, "Session");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures signal intensity and style.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR intensity/This value determines the strength of the waveform line in the 
/// HIPAR intensity/diagram. Enter a percentage between 0 (not visible) and 100% (very 
/// HIPAR intensity/strong).
/// HIPAR style/Select the style in which the waveform is displayed.
ViStatus _VI_FUNC rsscope_ConfigureSignalStyle(
    ViSession    instrSession,
    ViInt32        intensity,
    ViInt32        style
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SIGNAL_STYLE_INTENSITY,
                                               intensity
                                               ), 2, "Intensity");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SIGNAL_STYLE,
                                               style
                                               ), 3, "Style");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the waveform colors to suit your preferences.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Waveform to be assigned.
/// HIPAR useColorTable/If enabled, the selected waveform is displayed according to its 
/// HIPAR useColorTable/assigned color table. If this option is disabled, the default color 
/// HIPAR useColorTable/table is used, i.e. the intensity of the specific signal color varies 
/// HIPAR useColorTable/according to the cumulative occurance of the values.
/// HIPAR tableName/Color table name to be assigned to the signal.
ViStatus _VI_FUNC rsscope_ConfigureColorTableAssignment(
    ViSession    instrSession,
    ViInt32        source,
    ViBoolean    useColorTable,
    ViString    tableName
)
{
    ViStatus    error = VI_SUCCESS;
    
    ViChar        rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL)); 
    
    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_USE_COLOR_TABLE,
                                                 "WfmSuffix",
                                                 source,
                                                 15,
                                                 rep_cap), 2, "Source");    
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_USE_COLOR_TABLE,
                                                 useColorTable
                                                 ), 3, "Use Color Table");
    
    if (useColorTable == VI_TRUE)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_ASSIGN_COLOR_TABLE,
                                                    tableName
                                                    ), 4, "Table Name");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function adds a new color table with the specified name.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the new table.
ViStatus _VI_FUNC rsscope_AddColorTable(
    ViSession    instrSession,
    ViString    tableName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_ADD_COLOR_TABLE,
                                                tableName
                                                ), 2, "Table Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function removes a existing color table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
ViStatus _VI_FUNC rsscope_RemoveColorTable(
    ViSession    instrSession,
    ViString    tableName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_REMOVE_COLOR_TABLE,
                                                tableName
                                                ), 2, "Table Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function appends a new row at the end of the color table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
ViStatus _VI_FUNC rsscope_ColorTableAppendRow(
    ViSession    instrSession,
    ViString    tableName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_COLOR_TABLE_APPEND_NEW_ROW,
                                                tableName
                                                ), 2, "Table Name");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function inserts the entry at the specified index in the color 
/// HIFN  table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
/// HIPAR index/Row number in the color table.
ViStatus _VI_FUNC rsscope_ColorTableInsertRow(
    ViSession    instrSession,
    ViString    tableName,
    ViInt32        index
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "DISP:COL:PAL:POIN:INS '%s',%ld\n", tableName, index));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function inserts a new entry in the specified color table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
/// HIPAR index/Row number of the new entry in the color table.
/// HIPAR cumulativePercentage/Cumulative occurance value
/// HIPAR color/ARGB value of the color to be used for the table entry.
ViStatus _VI_FUNC rsscope_ColorTableDefineRow(
    ViSession    instrSession,
    ViString    tableName,
    ViInt32        index,
    ViReal64        cumulativePercentage,
    ViInt32        color
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "DISP:COL:PAL:POIN:VAL '%s',%ld,%.12lG,%ld\n", tableName, 
                                                                                   index, 
                                                                                   cumulativePercentage, 
                                                                                   color));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function removes the entry with the specified index from the 
/// HIFN  color table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
/// HIPAR index/Row number in the color table.
ViStatus _VI_FUNC rsscope_ColorTableRemoveRow(
    ViSession    instrSession,
    ViString    tableName,
    ViInt32        index
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "DISP:COL:PAL:POIN:REM '%s',%ld\n", tableName, index));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the number of configured color maps.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR count/The number of configured color maps.
ViStatus _VI_FUNC rsscope_QueryColorTableCount(
    ViSession    instrSession,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, "",
                                              RSSCOPE_ATTR_COLOR_TABLE_COUNT,
                                              count
                                              ), 2, "Count");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the number of entries in the color table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
/// HIPAR count/Rows count in the color table.
ViStatus _VI_FUNC rsscope_QueryColorTableRowCount(
    ViSession    instrSession,
    ViString    tableName,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viQueryf(instrSession, "DISP:COL:PAL:POIN:COUN? '%s'\n", "%ld", tableName, count));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function query a entry from the specified color table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR tableName/Name of the existing color table.
/// HIPAR index/Row number of the entry in the color table.
/// HIPAR cumulativePercentage/Cumulative occurance value
/// HIPAR color/ARGB value of the color to be used for the table entry.
ViStatus _VI_FUNC rsscope_QueryColorTableRow(
    ViSession    instrSession,
    ViString    tableName,
    ViInt32        index,
    ViReal64*    cumulativePercentage,
    ViInt32*    color
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viQueryf(instrSession, "DISP:COL:PAL:POIN:VAL? '%s',%ld\n", "%lf;%ld", tableName, 
                                                                                       index, 
                                                                                       cumulativePercentage, 
                                                                                       color));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the basic diagram layout and the appearence.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR showGrid/If enabled, a grid is displayed in the diagram area.
/// HIPAR showCrosshair/If selected, a crosshair is displayed in the diagram area.
/// HIPAR showLabels/If enabled, labels mark values on the x and y-axes in specified 
/// HIPAR showLabels/intervals in the diagram.
/// HIPAR showTabsAlways/If enabled, the tab titles of all diagrams are displayed.
/// HIPAR yGridFixed/If enabled, the horizontal grid lines remain in their position when 
/// HIPAR yGridFixed/the position of the curve is changed. Only the values at the grid lines 
/// HIPAR yGridFixed/are adapted. This reflects the behavior of traditional oscilloscopes.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementDiagram(
    ViSession    instrSession,
    ViBoolean    showGrid,
    ViBoolean    showCrosshair,
    ViBoolean    showLabels,
    ViBoolean    showTabsAlways,
    ViBoolean    yGridFixed
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_DIAGRAM_SHOW_GRID,
                                                 showGrid
                                                 ), 2, "Show Grid");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_DIAGRAM_SHOW_CROSSHAIR,
                                                 showCrosshair
                                                 ), 3, "Show Crosshair");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_DIAGRAM_SHOW_LABELS,
                                                 showLabels
                                                 ), 4, "Show Labels");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_DIAGRAM_SHOW_TAB_TITLES,
                                                 showTabsAlways
                                                 ), 5, "Show Tabs Always");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_DIAGRAM_KEEP_Y_GRID_FIXED,
                                                 yGridFixed
                                                 ), 6, "Y Grid Fixed");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures appearence of signal bar.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR enable/If enabled, the signal bar is displayed in the diagram area.
/// HIPAR position/Selects vertical position of the signal bar.
ViStatus _VI_FUNC rsscope_ShowSignalBar(
    ViSession    instrSession,
    ViBoolean    enable,
    ViInt32        position
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
 
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                               RSSCOPE_ATTR_SIGNAL_BAR_STATE,
                                               enable
                                               ), 2, "Enable");
    
    if (enable)
    {
        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_SIGNAL_BAR_POSITION,
                                                 position
                                                 ), 3, "Position");
    }
        
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures behavior of signal bar auto-hiding.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR autoHide/If enabled, the signal bar disappears automatically after specified 
/// HIPAR autoHide/time.
/// HIPAR hideHead/If enabled, the "Auto hide" function hides also the horizontal and 
/// HIPAR hideHead/trigger label at the top of the signal bar.
/// HIPAR hideAfter/Sets the time when the signal bar is faded out if auto hide is 
/// HIPAR hideAfter/enabled.
/// HIPAR hidingOpacity/Sets the opacity, or transparency, of the signal bar. The minimum 
/// HIPAR hidingOpacity/value is 30% for the least visibility of the signal bar, the maximum 
/// HIPAR hidingOpacity/value is 80%.
ViStatus _VI_FUNC rsscope_ConfigureSignalBarAutoHide(
    ViSession    instrSession,
    ViBoolean    autoHide,
    ViBoolean    hideHead,
    ViReal64    hideAfter,
    ViReal64    hidingOpacity
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_SIGNAL_BAR_AUTO_HIDE,
                                                 autoHide
                                                 ), 2, "Auto Hide");
    if (autoHide)
    {
        viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_SIGNAL_BAR_HIDE_HEAD,
                                                 hideHead
                                                 ), 3, "Hide Head");
    
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                    RSSCOPE_ATTR_SIGNAL_BAR_HIDE_TIME,
                                                    hideAfter
                                                    ), 4, "Hide After");
        
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                   RSSCOPE_ATTR_SIGNAL_BAR_HIDING_TRANSPARENCY,
                                                   hidingOpacity
                                                   ), 5, "Hiding Opacity");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures color settings of signal bar.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR borderColor/Sets the ARGB color value of the signal bar border.
/// HIPAR fillColor/Sets the ARGB fill color value of the signal bar.
ViStatus _VI_FUNC rsscope_ConfigureSignalBarColor(
    ViSession    instrSession,
    ViInt32        borderColor,
    ViInt32        fillColor
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SIGNAL_BAR_BORDER_COLOR,
                                               borderColor
                                               ), 2, "Border Color");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SIGNAL_BAR_FILL_COLOR,
                                               fillColor
                                               ), 3, "Fill Color");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines where a new result box opens.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR position/Defines where a new result box opens.
ViStatus _VI_FUNC rsscope_ConfigureResultBoxPosition (ViSession instrSession,
                                                      ViInt32 position)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_RESULT_BOX_POSITION,
                                               position), 2, "Position");  
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function adds a new diagram with a waveform on the screen, in 
/// HIFN  relation to an existing diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR existingDiagram/Name of the existing diagram
/// HIPAR newDiagramPosition/Position of the new diagram in relation to the existing one.
/// HIPAR insertBefore/If on, the new diagram is inserted to the left (for HORizontal), above 
/// HIPAR insertBefore/(for VERTical) or in a tab before the existing one.
/// HIPAR source/Waveform to be diplayed in the new diagram.
/// HIPAR newDiagramName/Name of the new diagram.
ViStatus _VI_FUNC rsscope_AddDiagram(
    ViSession    instrSession,
    ViString    existingDiagram,
    ViInt32        newDiagramPosition,
    ViBoolean    insertBefore,
    ViInt32        source,
    ViString    newDiagramName
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, newDiagramPosition, RSSCOPE_VAL_DIAGRAM_NONE, RSSCOPE_VAL_DIAGRAM_NEW_TAB) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "New Diagram Position");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Source");
    }

    
    viCheckErr (viPrintf(instrSession, "LAY:ADD '%s',%s,%s,%s,'%s'\n", existingDiagram, 
                                                                     position_Arr[newDiagramPosition],
                                                                     insertBefore?"ON":"OFF",
                                                                     source_Arr[source],
                                                                     newDiagramName));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function displays diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the existing diagram
ViStatus _VI_FUNC rsscope_DisplayDiagram(
    ViSession    instrSession,
    ViString    diagramName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_DISPLAY_DIAGRAM,
                                                diagramName
                                                ), 2, "Diagram Name");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function removes diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the existing diagram
ViStatus _VI_FUNC rsscope_RemoveDiagram(
    ViSession    instrSession,
    ViString    diagramName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_REMOVE_DIAGRAM,
                                                diagramName
                                                ), 2, "Diagram Name");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function shows the specified waveform in the selected diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the new diagram.
/// HIPAR source/Waveform to be assigned.
ViStatus _VI_FUNC rsscope_ShowWaveformInDiagram(
    ViSession    instrSession,
    ViString    diagramName,
    ViInt32        source
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_SBUS4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Source");
    }
    
    viCheckErr (viPrintf(instrSession, "LAY:SIGN:ASS '%s',%s\n", diagramName, source_Arr[source]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function creates an XY-diagram by adding a second waveform to a 
/// HIFN  diagram with a channel, math or reference waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the diagram where the waveform is added.
/// HIPAR source/Waveform to be added.
/// HIPAR assignToXAxis/If On, the added waveform is assigned to the x-axis.
ViStatus _VI_FUNC rsscope_AddWaveformToDiagram(
    ViSession    instrSession,
    ViString    diagramName,
    ViInt32        source,
    ViBoolean    assignToXAxis
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_C1W1, RSSCOPE_VAL_WAV_R4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Source");
    }
    
    viCheckErr (viPrintf(instrSession, "LAY:SIGN:AXIS '%s',%s,%s\n", diagramName, source_Arr[source], assignToXAxis?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function removes the specified waveform from the diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Selects the waveform.
ViStatus _VI_FUNC rsscope_RemoveWaveformFromDiagram(
    ViSession    instrSession,
    ViInt32        source
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if ((source >= RSSCOPE_VAL_WAV_D0) && !(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_REMOVE_WAVEFORM_FROM_DIAGRAM,
                                               source
                                               ), 2, "Source");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function adds a new zoom diagram based on the specified waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of diagram to be zoomed
/// HIPAR newDiagramPosition/Position of the new diagram in relation to the existing one.
/// HIPAR insertBefore/If on, the new diagram is inserted to the left (for HORizontal), above 
/// HIPAR insertBefore/(for VERTical) or in a tab before the existing one.
/// HIPAR newZoomDiagramName/Defines the name of the new zoom diagram.
/// HIPAR xStart/Defines the x-value at the beginning of the zoom area.
/// HIPAR xStop/Defines the x-value at the end of the zoom area.
/// HIPAR yStart/Defines the y-value at the beginning of the zoom area.
/// HIPAR yStop/Defines the y-value at the end of the zoom area.
ViStatus _VI_FUNC rsscope_AddDiagramZoom(
    ViSession    instrSession,
    ViString    diagramName,
    ViInt32        newDiagramPosition,
    ViBoolean    insertBefore,
    ViString    newZoomDiagramName,
    ViReal64    xStart,
    ViReal64    xStop,
    ViReal64    yStart,
    ViReal64    yStop
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, newDiagramPosition, RSSCOPE_VAL_DIAGRAM_NONE, RSSCOPE_VAL_DIAGRAM_NEW_TAB) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "New Diagram Position");
    }

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:ADD '%s',%s,%s,%.12lG,%.12lG,%.12lG,%.12lG,'%s'\n", diagramName, 
                                                                                                   position_Arr[newDiagramPosition],
                                                                                                   insertBefore?"ON":"OFF",
                                                                                                   xStart,
                                                                                                   xStop,
                                                                                                   yStart,
                                                                                                   yStop,
                                                                                                   newZoomDiagramName));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function creates a new zoom diagram based on the settings of an 
/// HIFN  existing zoom area for the same source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Defines the name of the zoom diagram to be copied.
/// HIPAR newZoomDiagramName/Defines the name of the new zoom diagram.
/// HIPAR xOffset/Defines an offset to the existing zoom area in x direction.
/// HIPAR yOffset/Defines an offset to the existing zoom area in y direction.
ViStatus _VI_FUNC rsscope_AddDiagramZoomCoupled(
    ViSession    instrSession,
    ViString    diagramName,
    ViString    newZoomDiagramName,
    ViReal64    xOffset,
    ViReal64    yOffset
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:ADDC '%s',%.12lG,%.12lG,'%s'\n", diagramName, 
                                                                                  xOffset,
                                                                                  yOffset,
                                                                                  newZoomDiagramName));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function removes the specified zoom diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the diagram on which the zoom area is based.
/// HIPAR zoomDiagramName/Name of the zoom diagram
ViStatus _VI_FUNC rsscope_RemoveDiagramZoom(
    ViSession    instrSession,
    ViString    diagramName,
    ViString    zoomDiagramName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:REM '%s','%s'\n", diagramName, zoomDiagramName));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical settings of zoom area using 
/// HIFN  start and stop values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the diagram on which the zoom area is based.
/// HIPAR zoomDiagramName/Name of the zoom diagram
/// HIPAR mode/Defines whether absolute or relative values are used to specify the 
/// HIPAR mode/y-axis values. Since the zoom area refers to the active signal, 
/// HIPAR mode/relative values ensure that the zoom area remains the same.
/// HIPAR start/Defines the lower limit of the zoom area on the y-axis.
/// HIPAR stop/Defines the upper limit of the zoom area on the y-axis.
ViStatus _VI_FUNC rsscope_ConfigureDiagramZoomVerticalStartStop(
    ViSession    instrSession,
    ViString    diagramName,
    ViString    zoomDiagramName,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{                                                                             
    ViStatus    error = VI_SUCCESS;
    ViString     modeArr[] = {"ABS", "REL"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Mode");
    }                                                  

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:VERT:MODE '%s','%s',%s\n", diagramName, 
                                                                              zoomDiagramName, 
                                                                            modeArr[mode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:VERT:%s:STAR '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                   diagramName, 
                                                                                   zoomDiagramName, 
                                                                                   start));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:VERT:%s:STOP '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                   diagramName, 
                                                                                   zoomDiagramName, 
                                                                                   stop));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the horizontal settings of zoom area using 
/// HIFN  start and stop values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the diagram on which the zoom area is based.
/// HIPAR zoomDiagramName/Name of the zoom diagram
/// HIPAR mode/Defines whether absolute or relative values are used to specify the 
/// HIPAR mode/x-axis values. Since the zoom area refers to the active signal, 
/// HIPAR mode/relative values ensure that the zoom area remains the same.
/// HIPAR start/Defines the lower limit of the zoom area on the x-axis.
/// HIPAR stop/Defines the upper limit of the zoom area on the x-axis.
ViStatus _VI_FUNC rsscope_ConfigureDiagramZoomHorizontalStartStop(
    ViSession    instrSession,
    ViString    diagramName,
    ViString    zoomDiagramName,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;
    ViString     modeArr[] = {"ABS", "REL"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Mode");
    }                                                  

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:HORZ:MODE '%s','%s',%s\n", diagramName, 
                                                                              zoomDiagramName, 
                                                                            modeArr[mode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:HORZ:%s:STAR '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                   diagramName, 
                                                                                   zoomDiagramName, 
                                                                                   start));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:HORZ:%s:STOP '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                   diagramName, 
                                                                                   zoomDiagramName, 
                                                                                   stop));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical settings of zoom area using 
/// HIFN  position and range values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the diagram on which the zoom area is based.
/// HIPAR zoomDiagramName/Name of the zoom diagram
/// HIPAR mode/Defines whether absolute or relative values are used to specify the 
/// HIPAR mode/y-axis values. Since the zoom area refers to the active signal, 
/// HIPAR mode/relative values ensure that the zoom area remains the same.
/// HIPAR position/Defines the y-value of the centerpoint of the zoom area.
/// HIPAR range/Defines the height of the zoom area.
ViStatus _VI_FUNC rsscope_ConfigureDiagramZoomVerticalPositionRange(
    ViSession    instrSession,
    ViString    diagramName,
    ViString    zoomDiagramName,
    ViInt32        mode,
    ViReal64    position,
    ViReal64    range
)
{
    ViStatus    error = VI_SUCCESS;
    ViString     modeArr[] = {"ABS", "REL"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Mode");
    }                                                  

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:VERT:MODE '%s','%s',%s\n", diagramName, 
                                                                              zoomDiagramName, 
                                                                            modeArr[mode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:VERT:%s:POS '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                  diagramName, 
                                                                                  zoomDiagramName, 
                                                                                  position));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:VERT:%s:SPAN '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                   diagramName, 
                                                                                   zoomDiagramName, 
                                                                                   range));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the horizontal settings of zoom area using 
/// HIFN  position and range values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the diagram on which the zoom area is based.
/// HIPAR zoomDiagramName/Name of the zoom diagram
/// HIPAR mode/Defines whether absolute or relative values are used to specify the 
/// HIPAR mode/y-axis values. Since the zoom area refers to the active signal, 
/// HIPAR mode/relative values ensure that the zoom area remains the same.
/// HIPAR position/Defines the x-value of the centerpoint of the zoom area.
/// HIPAR range/Defines the width of the zoom area.
ViStatus _VI_FUNC rsscope_ConfigureDiagramZoomHorizontalPositionRange(
    ViSession    instrSession,
    ViString    diagramName,
    ViString    zoomDiagramName,
    ViInt32        mode,
    ViReal64    position,
    ViReal64    range
)
{
    ViStatus    error = VI_SUCCESS;
    ViString     modeArr[] = {"ABS", "REL"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Mode");
    }                                                  

    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:HORZ:MODE '%s','%s',%s\n", diagramName, 
                                                                              zoomDiagramName, 
                                                                            modeArr[mode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:HORZ:%s:POS '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                  diagramName, 
                                                                                  zoomDiagramName, 
                                                                                  position));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "LAY:ZOOM:HORZ:%s:SPAN '%s','%s',%.12lG\n", modeArr[mode], 
                                                                                   diagramName, 
                                                                                   zoomDiagramName, 
                                                                                   range));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the XY diagram settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR xyDiagramNumber/Sets the XY Diagram number.
/// HIPAR xyDiagramState/Activates an XY-waveform.
/// HIPAR constantXYRatio/If enabled, the x- and y-axes maintain a constant ratio in the 
/// HIPAR constantXYRatio/diagram.
/// HIPAR xSource/Defines the signal source that supplies the x-values of the 
/// HIPAR xSource/XY-diagram.
/// HIPAR ySource/Defines the signal source that supplies the y-values of the 
/// HIPAR ySource/XY-diagram.
ViStatus _VI_FUNC rsscope_ConfigureXYDiagram(
    ViSession    instrSession,
    ViInt32        xyDiagramNumber,
    ViBoolean    xyDiagramState,
    ViBoolean    constantXYRatio,
    ViInt32        xSource,
    ViInt32        ySource
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar         rep_cap[5] = "";
    ViChar         rep_cap_xy[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, xyDiagramNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "XY Diagram Numeber");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_XY_DIAGRAM_SOURCE,
                                                 "XYDiagram",
                                                 xyDiagramNumber - 1,
                                                 5,
                                                 rep_cap), 2, "XY Diagram Number");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_XY_DIAGRAM_STATE,
                                                 xyDiagramState
                                                 ), 3, "XY Diagram State");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_XY_DIAGRAM_RATIO,
                                                 constantXYRatio
                                                 ), 4, "XY Ratio");
    
    sprintf (rep_cap_xy, "%s,XSRC", rep_cap);
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_xy,
                                               RSSCOPE_ATTR_XY_DIAGRAM_SOURCE,
                                               xSource
                                               ), 5, "X Source");
    
    sprintf (rep_cap_xy, "%s,YSRC", rep_cap);
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_xy,
                                               RSSCOPE_ATTR_XY_DIAGRAM_SOURCE,
                                               ySource
                                               ), 6, "Y Source");    

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function replaces the source of the x-axis with the source of the 
/// HIFN  y-axis and vice versa.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR xyDiagramNumber/Sets the XY Diagram number.
ViStatus _VI_FUNC rsscope_SwapXYDiagram(
    ViSession    instrSession,
    ViInt32        xyDiagramNumber
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SWAP_XY_DIAGRAM,
                                               xyDiagramNumber
                                               ), 2, "XY Diagram Number");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function activates or deactivates the history display.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR enableHistory/Enables or disables the history display.
ViStatus _VI_FUNC rsscope_ConfigureHistoryState(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViBoolean   enableHistory
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_STATE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_STATE,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_STATE,
                                                 enableHistory
                                                 ), 4, "Enable History");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures start and stop point of history viewer.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR start/Sets the start point for the history replay.
/// HIPAR stop/Sets the end point for the history viewer.
ViStatus _VI_FUNC rsscope_ConfigureHistoryStartStop(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViInt32     start,
    ViInt32     stop
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_START_INDEX,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_START_INDEX,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_START_INDEX,
                                                 start
                                                 ), 4, "Start");
                                                 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_STOP_INDEX,
                                                 stop
                                                 ), 5, "Stop");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function selects a particular acquisition in the memory to 
/// HIFN  display it.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR acquisition/Select the acquisition number in the memory.
ViStatus _VI_FUNC rsscope_ConfigureHistoryAcquisitionView(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViInt32     acquisition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_ACQUISITION_VIEW,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_ACQUISITION_VIEW,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_ACQUISITION_VIEW,
                                                 acquisition
                                                 ), 4, "Acquisition");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the display time for one acquisition. The 
/// HIFN  shorter the time, the faster is the replay.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR timeperAcquisition/Sets the display time for one acquisition.
ViStatus _VI_FUNC rsscope_ConfigureHistoryAcquisitionTime(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViReal64    timeperAcquisition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_ACQUISITION_TIME,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_ACQUISITION_TIME,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);                                                                                          

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_HISTORY_ACQUISITION_TIME,
                                                timeperAcquisition
                                                ), 4, "Timeper Acquisition");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures if the replay of the history waveform 
/// HIFN  sequence repeats automatically.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR autoRepeat/If ON, the replay of the history waveform sequence repeats 
/// HIPAR autoRepeat/automatically. Otherwise, the replay stops at the stop index set with 
/// HIPAR autoRepeat/rsscope_ConfigureHistoryStartStop
ViStatus _VI_FUNC rsscope_ConfigureHistoryAutoRepeat(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViBoolean   autoRepeat
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_AUTO_REPEAT,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_AUTO_REPEAT,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);                                                                                          

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_AUTO_REPEAT,
                                                 autoRepeat
                                                 ), 4, "Auto Repeat");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function starts and stops the replay of the history waveforms.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
ViStatus _VI_FUNC rsscope_HistoryPlaybackControl(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_PLAYBACK,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_PLAYBACK,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_PLAYBACK,
                                                 NULL));

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function queries the time stamp of the currently displayed 
/// HIFN  history acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR mode/This control selects absolute or relative timestamp:
/// HIPAR timeStamp/Returns the time of the currently displayed history acquisition.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the time 
/// HIPAR bufferSize/stamp value.
ViStatus _VI_FUNC rsscope_QueryHistoryTimeStamp(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32     waveform,
    ViInt32     mode,
    ViInt32     bufferSize,
    ViChar      timeStamp[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";
    ViChar      rep_cap_mode[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_TS_ABS, RSSCOPE_VAL_TS_REL) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Mode");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_TIME_STAMP,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_TIME_STAMP,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);
    
    strcpy(rep_cap_mode, rep_cap);
    strcat(rep_cap_mode, mode?",Rel":",Abs");
    viCheckErr (rsscope_GetAttributeViString (instrSession, rep_cap_mode,
                                                 RSSCOPE_ATTR_HISTORY_TIME_STAMP,
                                                 bufferSize,
                                                 timeStamp));
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN Returns the date of the current acquisition that is shown in the history viewer.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/This control selects the waveform.
/// HIPAR date/Returns the date of the current acquisition that is shown in the history viewer
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the time 
/// HIPAR bufferSize/stamp value.
ViStatus _VI_FUNC rsscope_QueryHistoryDate (ViSession instrSession,
                                            ViInt32 channel, ViInt32 waveform,
                                            ViInt32 bufferSize, ViChar date[])
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
    ViChar      rep_cap_wav[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL_1, RSSCOPE_VAL_CHANNEL_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }

    if (rsscope_invalidViInt32Range (instrSession, waveform, 1, 3) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Waveform");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_DATE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel");
                                                 
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTORY_DATE,
                                                 "Waveform",
                                                 waveform,
                                                 5,
                                                 rep_cap_wav), 3, "Waveform"); 
                                                 
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_wav);
    
    viCheckErr (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HISTORY_DATE,
                                                 bufferSize,
                                                 date));
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function queries the number of acquisitions currently saved in 
/// HIFN  the memory. This number of acquisitions is available for history 
/// HIFN  viewing. It is also the number of acquisitions in an Ultra Segmentation 
/// HIFN  acquisition series.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR count/Returns the number of acquisitions currently saved in the memory.
ViStatus _VI_FUNC rsscope_QueryHistoryAcquisitionsCount(
    ViSession   instrSession,
    ViInt32     channel,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;
    channel;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_HISTORY_GET_ACQUISITIONS_COUNT,
                                                 count
                                                 ), 2, "Count");
                                                 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the state of the indicated measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR measurementState/Switches the indicated measurement on or off.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementState(
    ViSession   instrSession,
    ViInt32     measurement,
    ViBoolean   measurementState
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MEASUREMENT_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_MEASUREMENT_ENABLED, measurementState), 3, "Measurement State");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the state of the indicated measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR signalSource/Selects the source of the measurement.
/// HIPAR signalSource2/Selects the source of the measurement.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementSource(
    ViSession   instrSession,
    ViInt32     measurement,
    ViInt32     signalSource,
    ViInt32     signalSource2
)
{
    ViStatus    error = VI_SUCCESS;
    ViString    signalSourceArr[] = {"NONE","C1W1","C1W2","C1W3","C2W1","C2W2","C2W3","C3W1",
                                     "C3W2","C3W3","C4W1","C4W2","C4W3","M1","M2","M3","M4","R1",
                                     "R2","R3","R4","D0","D1","D2","D3","D4","D5","D6","D7","D8",
                                     "D9","D10","D11","D12","D13","D14","D15"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
        RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    if (rsscope_invalidViInt32Range (instrSession, signalSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE, 
        RSSCOPE_VAL_MEASUREMENT_SOURCE_D15) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Signal Source");
    }
    if (rsscope_invalidViInt32Range (instrSession, signalSource2, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE, 
        RSSCOPE_VAL_MEASUREMENT_SOURCE_D15) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Signal Source 2");
    }

    if (((signalSource >= RSSCOPE_VAL_WAV_D0) || (signalSource2 >= RSSCOPE_VAL_WAV_D0)) && !(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    viCheckErr (viPrintf(instrSession, "MEAS%ld:SOUR %s,%s", 
        measurement, signalSourceArr[signalSource], signalSourceArr[signalSource2]));
    
    viCheckErr(rsscope_CheckStatus(instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the type of the limit check that can run together with the measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR limitCheck/Selects the type of the limit check that can run together with the measurement.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementLimitCheck(
    ViSession   instrSession,
    ViInt32     measurement,
    ViInt32     limitCheck
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MEASUREMENT_LIMIT_TYPE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_MEASUREMENT_LIMIT_TYPE, limitCheck), 3, "Limit Check");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the state of the multiple measurement. The measurement is performed repeatedly if the measured parameter occurs several times inside the defined gate.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR multipleMeasurement/Switches the multiple measurement on or off.
ViStatus _VI_FUNC rsscope_ConfigureMultipleMeasurement(
    ViSession   instrSession,
    ViInt32     measurement,
    ViBoolean   multipleMeasurement
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MULTIPLE_MEASUREMENT_ENABLED,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_MULTIPLE_MEASUREMENT_ENABLED, multipleMeasurement), 3, "Multiple Measurement");    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function sets the maximum number of measurements per acquisition if multiple measurement is enabled.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions 
/// HIPAR instrSession/function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR measurementCount/Sets the maximum number of measurements per acquisition if multiple measurement is enabled.
ViStatus _VI_FUNC rsscope_ConfigureMultipleMeasurementNumber (ViSession instrSession,
                                                              ViInt32 measurement,
                                                              ViInt32 measurementCount)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MULTIPLE_MEASUREMENT_COUNT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_MULTIPLE_MEASUREMENT_COUNT, measurementCount), 3, "Measurement Count");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);
	return error;
}

/// HIFN  This function configures the measurement category.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR category/Selects the measurement category.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementCategory(
    ViSession   instrSession,
    ViInt32     measurement,
    ViInt32     category
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MEASUREMENT_CATEGORY,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_MEASUREMENT_CATEGORY, category), 3, "Category");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function enables all additional measurements in all categories of the indicated measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
ViStatus _VI_FUNC rsscope_EnableAdditionalMeasurements(
    ViSession   instrSession,
    ViInt32     measurement
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_ADDITIONAL_MEASUREMENTS_ENABLE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViString(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_ADDITIONAL_MEASUREMENTS_ENABLE, VI_NULL), 2, "Measurement");   

 Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function disables all additional measurements in all categories of the indicated measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
ViStatus _VI_FUNC rsscope_DisableAdditionalMeasurements(
    ViSession   instrSession,
    ViInt32     measurement
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_ADDITIONAL_MEASUREMENTS_DISABLE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViString(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_ADDITIONAL_MEASUREMENTS_DISABLE, VI_NULL), 2, "Measurement");  

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function deletes the statistic results of the indicated mesurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
ViStatus _VI_FUNC rsscope_ClearMeasurementStatisticData(
    ViSession   instrSession,
    ViInt32     measurement
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CLEAR_MEASUREMENT_STATISTIC_DATA,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViString(instrSession, rep_cap_measurement,
        RSSCOPE_ATTR_CLEAR_MEASUREMENT_STATISTIC_DATA, VI_NULL), 2, "Measurement"); 
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures what happens when the mask test has failed or when it has passed successfully. Each action can be initiated either on failure or on success.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR event/This Control selects event to be performed.
/// HIPAR action/This Control selects action for specified event.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementEventActions(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 event,
    ViInt32 action
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_measurement[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_GENERATE_BEEP_ON_MEASUREMENT_EVENT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");
    switch (event) 
    {   case RSSCOPE_VAL_MEASUREMENT_EVENT_BEEP:
            viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
                RSSCOPE_ATTR_GENERATE_BEEP_ON_MEASUREMENT_EVENT, action), 3, "Event: Beep");    
            break;

        case RSSCOPE_VAL_MEASUREMENT_EVENT_STOP:
            viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
                RSSCOPE_ATTR_STOP_ACQUISITION_ON_MEASUREMENT_EVENT, action), 3, "Event: Stop");
            break;

        case RSSCOPE_VAL_MEASUREMENT_EVENT_PRINT:
            viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
                RSSCOPE_ATTR_PRINT_ON_MEASUREMENT_EVENT, action), 3, "Event: Print");
            break;
        
        case RSSCOPE_VAL_MEASUREMENT_EVENT_SAVE_WFM:
            viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap_measurement,
                RSSCOPE_ATTR_SAVE_WAVEFORM_DATA_ON_MEASUREMENT_EVENT, action), 3, "Event: Save Waveform");
            break;
        
        default:
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Event");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the measurement display intermediate results.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR displayResultLines/If enabled, the intermediate result lines required to obtain the 
/// HIPAR displayResultLines/measurement result (e.g. signal thresholds) are displayed in the 
/// HIPAR displayResultLines/measurement diagram.
/// HIPAR displayReferenceLevels/If enabled, the reference levels used for the measurement are 
/// HIPAR displayReferenceLevels/displayed in the diagram.
ViStatus _VI_FUNC rsscope_ConfigureMeasurementDisplayIntermediateResults(
    ViSession    instrSession,
    ViInt32        measurement,
    ViBoolean    displayResultLines,
    ViBoolean    displayReferenceLevels
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
        RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_DISPLAY_RESULT_LINES,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap), 2, "Measurement");    
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_DISPLAY_RESULT_LINES,
                                                 displayResultLines
                                                 ), 3, "Display Result Lines");

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_DISPLAY,
                                                 displayReferenceLevels
                                                 ), 4, "Display Reference Levels");    

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the style in which the measurement waveform 
/// HIFN  is displayed.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR displayStyle/Selects the style in which the measurement waveform is displayed
ViStatus _VI_FUNC rsscope_ConfigureMeasurementDisplayStyle(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        displayStyle
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[25] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
        RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MEASUREMENT_DISPLAY_STYLE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap), 2, "Measurement");    
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_MEASUREMENT_DISPLAY_STYLE,
                                               displayStyle
                                               ), 3, "Display Style");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the results of all selected measurements in all categories.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR measurement/This control selects the measurement.
/// HIPAR arraySize/Sets the number of results requested.
/// HIPAR results/Returns the results of all selected measurements in all categories.
/// HIPAR actualPoints/Number of points actually returned in the Results array.
ViStatus _VI_FUNC rsscope_ReadMeasurementResults(
    ViSession   instrSession,
    ViInt32     measurement,
    ViInt32     arraySize,
    ViReal64    results[],
    ViInt32*    actualPoints
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      *buffer = VI_NULL;
    ViChar      *pbuff = VI_NULL;
    ViInt32     i = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
                                                  RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckErr( viPrintf (instrSession, "MEAS%ld:ARES?\n", measurement));

    viCheckErr(Rs_ReadDataUnknownLength (instrSession, &buffer, VI_NULL)); 
    
    pbuff = strtok (buffer, ",");
    
    while ((pbuff != NULL) && (i<arraySize))
    {
        results[i++] = atof (pbuff);
        pbuff = strtok (NULL, ",");
    }
    
    *actualPoints = i;
    
    viCheckErr(rsscope_CheckStatus(instrSession));
Error:
	if (buffer) free (buffer);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the cursor settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR cursorState/Switches the indicated cursor on or off.
/// HIPAR source/Defines the source of the cursor measurement.
/// HIPAR type/Defines the cursor measurement type.
ViStatus _VI_FUNC rsscope_ConfigureCursor(
    ViSession   instrSession,
    ViInt32     cursor,
    ViBoolean   cursorState,
    ViInt32     source,
    ViInt32     type
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";
    
    if ((source >= RSSCOPE_VAL_WAV_D0) && !(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	if (rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_NONE, RSSCOPE_VAL_WAV_MSOB4) == VI_TRUE || 
		rsscope_invalidViInt32Range (instrSession, source, RSSCOPE_VAL_WAV_XY4, RSSCOPE_VAL_WAV_D0 ) == VI_FALSE )
    
	{
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Source");
    }
	
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_ENABLED,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap), 2, "Cursor");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_ENABLED, cursorState), 3, "Cursor State");  
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_SOURCE, source), 4, "Cursor Source");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_MEASUREMENT_TYPE, type), 5, "Type");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function switches all cursors off.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
ViStatus _VI_FUNC rsscope_AllCursorsOff(
    ViSession   instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    viCheckParm(rsscope_SetAttributeViString(instrSession, "",
        RSSCOPE_ATTR_ALL_CURSORS_OFF, VI_NULL), 2, "All Cursors Off");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the horizontal and vertical position of selected cursor or cursor line.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR xPosition1/Defines the position of the left vertical cursor line.
/// HIPAR xPosition2/Defines the position of the right vertical cursor line.
/// HIPAR yPosition1/Defines the position of the lower horizontal cursor line.
/// HIPAR yPosition2/Defines the position of the upper horizontal cursor line.
ViStatus _VI_FUNC rsscope_ConfigureCursorPosition(
    ViSession   instrSession,
    ViInt32     cursor,
    ViReal64    xPosition1,
    ViReal64    xPosition2,
    ViReal64    yPosition1,
    ViReal64    yPosition2
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";
    ViChar  rep_cap_cursor[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_X_POSITION,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap_cursor), 2, "Cursor");
    strcpy (rep_cap, rep_cap_cursor);
    strcat (rep_cap, ",P1");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_X_POSITION, xPosition1), 3, "X Position 1");    
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_Y_POSITION, yPosition1), 5, "Y Position 1");
    
    strcpy (rep_cap, rep_cap_cursor);
    strcat (rep_cap, ",P2");

    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_X_POSITION, xPosition2), 4, "X Position 2");    
    
    viCheckParm(rsscope_SetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_Y_POSITION, yPosition2), 6, "Y Position 2");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the positioning mode of the horizontal and vertical cursors.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR xCoupling/Defines the positioning mode of the vertical cursor.
/// HIPAR yCoupling/Defines the positioning mode of the horizontal cursor.
ViStatus _VI_FUNC rsscope_ConfigureCursorCoupling(
    ViSession   instrSession,
    ViInt32     cursor,
    ViBoolean   xCoupling,
    ViBoolean   yCoupling
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_X_POSITION_COUPLING,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap), 2, "Cursor");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_X_POSITION_COUPLING, xCoupling), 3, "X Coupling");  
    
    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_Y_POSITION_COUPLING, yCoupling), 4, "Y Coupling");  
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the cursor waveform tracking
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR tracking/Switches the cursor waveform tracking.
ViStatus _VI_FUNC rsscope_ConfigureCursorWaveformTracking(
    ViSession   instrSession,
    ViInt32     cursor,
    ViBoolean   tracking
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_TRACKING,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap), 2, "Cursor");

    viCheckParm(rsscope_SetAttributeViBoolean(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_TRACKING, tracking), 3, "Cursor Tracking");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the first and second horizontal cursor position.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR firstCursorPosition/Defines whether the first horizontal cursor is positioned to the
/// HIPAR secondCursorPosition/Defines whether the second horizontal cursor is positioned to the
ViStatus _VI_FUNC rsscope_ConfigureCursorEnvelopeWaveformSelection(
    ViSession   instrSession,
    ViInt32     cursor,
    ViInt32     firstCursorPosition,
    ViInt32     secondCursorPosition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15]  = "";
    ViChar  rep_cap_c[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_ENVELOPE_CURVE,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap_c), 2, "Cursor");
    
    strcpy (rep_cap, rep_cap_c);
    strcat (rep_cap, ",E1");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_ENVELOPE_CURVE, firstCursorPosition), 3, "First Cursor Position");  
    
    strcpy (rep_cap, rep_cap_c);
    strcat (rep_cap, ",E2");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_ENVELOPE_CURVE, secondCursorPosition), 4, "Second Cursor Position");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the delta value (distance) of two horizontal or vertical cursors (RTM) / cursor lines (RTO).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR cursorDistance/Returns the delta value (distance) of two horizontal or vertical cursors (RTM) / cursor lines (RTO).
/// HIPAR direction/Selects the distance direction
ViStatus _VI_FUNC rsscope_QueryCursorDistance (ViSession instrSession,
                                               ViInt32 cursor, ViInt32 direction,
                                               ViReal64 *cursorDistance)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[15] = "";
    ViChar  rep_cap_dir[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_DISTANCE,
                                                 "Cursor",
                                                 cursor - 1,
                                                 15,
                                                 rep_cap), 2, "Cursor");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_DISTANCE,
                                                 "CursorDirection",
                                                 direction,
                                                 10,
                                                 rep_cap_dir), 2, "Direction");
    
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_dir);
    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_DISTANCE, cursorDistance), 3, "Cursor Distance");   
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the inverse value of the delta value (distance) of the two vertical or horizontal cursors (RTM) / cursor lines (RTO).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR cursorDistance/Returns the inverse value of the delta value (distance) of the two vertical or horizontal cursors (RTM) / cursor lines (RTO).
ViStatus _VI_FUNC rsscope_QueryCursorInverseDistance(
    ViSession   instrSession,
    ViInt32 cursor,
    ViReal64*   cursorDistance
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_INVERSE_DISTANCE,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap), 2, "Cursor");
    
    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_INVERSE_DISTANCE, cursorDistance), 3, "Cursor Distance");   
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function sets cursor to selected peak.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR search/Sets cursor to selected peak.
ViStatus _VI_FUNC rsscope_CursorSearch(
    ViSession   instrSession,
    ViInt32 cursor,
    ViInt32 search
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[25] = "";
    ViChar  rep_cap_s[15] = "";
    ViChar  rep_cap_c[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_SEARCH,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap_c), 2, "Cursor");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_SEARCH,
                                                 "CursorSearch",
                                                 search,
                                                 15,
                                                 rep_cap_s), 3, "Search");
    
    strcpy (rep_cap, rep_cap_c);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_s);
    viCheckParm(rsscope_SetAttributeViString(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_SEARCH, NULL), 1, "Session");   
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the minimum level by which the waveform must rise or fall so that it will be identified as a maximum or a minimum by the search functions.
///           
///           Attribute(s):
///           RSSCOPE_ATTR_CURSOR_PEAK_EXCURSION
///           
///           Remote-control command(s):
///           CURSor<Cursor>:PEXCursion
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR cursor/This control selects the cursor.
/// HIPAR peakExcursion/Defines the minimum level by which the waveform must rise or fall so that it will be identified as a maximum or a minimum by the search functions.
ViStatus _VI_FUNC rsscope_ConfigureCursorPeakExcursion(
    ViSession   instrSession,
    ViInt32 cursor,
    ViInt32 peakExcursion
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, cursor, RSSCOPE_VAL_CURSOR_1, RSSCOPE_VAL_CURSOR_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Cursor");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_CURSOR_PEAK_EXCURSION,
                                                 "Cursor",
                                                 cursor - 1,
                                                 5,
                                                 rep_cap), 2, "Cursor");
    
    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_CURSOR_PEAK_EXCURSION, peakExcursion), 3, "Peak Excursion");   
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the main measurement. This measurement is the one referred to 
/// HIFN  if the measurement waveform is used as a source for math calculations. 
/// HIFN  The main measurement type must belong to the same category as the other 
/// HIFN  types assigned to the same measurement waveform, if there are any.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Defines or queries the main measurement. This measurement is the one 
/// HIPAR measurementFunction/referred to if the measurement waveform is used as a source for math 
/// HIPAR measurementFunction/calculations. The main measurement type must belong to the same 
/// HIPAR measurementFunction/category as the other types assigned to the same measurement waveform, 
/// HIPAR measurementFunction/if there are any.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeMainMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_MAIN_MEASUREMENT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_AMPT_MAIN_MEASUREMENT, measurementFunction), 3, "Amplitude Time Measurement Function");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines additional measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects additional measurement type.
/// HIPAR enabled/Enables or disables the additional measurement.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeAdditionalMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViBoolean   enabled
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   command[50] = "";
    ViInt32  i = 0;
    ViReal64 discrete;
    ViChar   *p2string = NULL;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
                                                  RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    do
    {
        discrete = rsscope_rngAmplitudeTimeMeasurementType.rangeValues[i].discreteOrMinValue;
        p2string = rsscope_rngAmplitudeTimeMeasurementType.rangeValues[i].cmdString;

        if (p2string == RS_RANGE_TABLE_END_STRING)
            viCheckParm(RS_ERROR_INVALID_PARAMETER, 3, "Measurement Function");

        if (fabs(discrete - measurementFunction) <= 0.01) break;

        i++;

    } while (i != 0);
    
    sprintf (command, "MEAS%ld:ADD %s,%s\n", measurement, p2string, enabled ? "ON" : "OFF");
    checkErr (viWrite (instrSession, (ViBuf) command, (ViUInt32) strlen (command), NULL));
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the amplitude time measurement signal 
/// HIFN  threashold and area level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR signalThreshold/Defines the value above which measurement results are displayed. 
/// HIPAR signalThreshold/Values beneath the threshold are considered to be noise and are 
/// HIPAR signalThreshold/ignored.
/// HIPAR areaLevel/Defines the reference level used to integrate the waveform.
/// HIPAR pulseTrainCount/Sets the number of positive pulses for the pulse train
/// HIPAR pulseTrainCount/measurement. It measures the duration of N positive pulses from
/// HIPAR pulseTrainCount/the rising edge of the first pulse to the falling edge of the
/// HIPAR pulseTrainCount/N-th pulse.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeSettings(
    ViSession    instrSession,
    ViInt32      measurement,
    ViInt32      signalThreshold,
    ViReal64     areaLevel,
    ViInt32      pulseTrainCount
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_SIGNAL_DETECTION_THRESHOLD,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");    

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_SIGNAL_DETECTION_THRESHOLD, signalThreshold
                                               ), 3, "signalThreshold");
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_AMPT_AREA_LEVEL, areaLevel
                                                ), 4, "areaLevel");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_PULSE_TRAIN_COUNT, pulseTrainCount
                                               ), 5, "Pulse Train Count");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures the first slope of the pulses or the edges to be counted.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR countType/Switches between Pulse, Edge or Clock count.
/// HIPAR slope/This control sets the first slope of the pulses ot the edges to be counted.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeSlope (ViSession instrSession,
                                                       ViInt32 measurement,
                                                       ViInt32 countType,
                                                       ViInt32 slope)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";
	ViChar    rep_cap_type[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_SLOPE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_SLOPE,
                                                 "AMPTSlopeType",
                                                 countType,
                                                 15,
                                                 rep_cap_type), 3, "Count Type");
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_type);

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_SLOPE, slope
                                               ), 4, "Slope");
	
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures the specific settings for delay measurement to allow you to measure 
/// HIFN the time between any two slopes at any reference level.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR sourceNumber/Selects the source number.
/// HIPAR levelSelection/Selects the reference level on which the time is measured for each source.
/// HIPAR slope/This control sets the edge of each source, between which the delay is measured.
/// HIPAR direction/Selects the direction for counting slopes for each source.
/// HIPAR edgeNumber/Sets the number of the edge that is relevant for delay measurement for each source.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeAdvancedDelaySetup (ViSession instrSession,
                                                                ViInt32 measurement,
                                                                ViInt32 sourceNumber,
                                                                ViInt32 levelSelection,
                                                                ViInt32 slope,
                                                                ViInt32 direction,
                                                                ViInt32 edgeNumber)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";
	ViChar    rep_cap_source[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_DELAY_LEVEL_SELECTION,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_DELAY_LEVEL_SELECTION,
                                                 "SourceNumber",
                                                 sourceNumber-1,
                                                 15,
                                                 rep_cap_source), 3, "Source Number");
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_source);

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_DELAY_LEVEL_SELECTION, levelSelection
                                               ), 4, "Level Selection");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_DELAY_SLOPE, slope
                                               ), 5, "Slope");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_DELAY_DIRECTION, direction
                                               ), 6, "Direction");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_DELAY_EDGE_NUMBER, edgeNumber
                                               ), 7, "Edge Number");
	
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function selects the reference level on which the time is measured for each source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR type/Switches between Clock and Data refernce level.
/// HIPAR referenceLevel/Selects the reference level on which the time is measured for each source.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeReferenceLevel (ViSession instrSession,
                                                                ViInt32 measurement,
                                                                ViInt32 type,
                                                                ViInt32 referenceLevel)
{
	ViStatus    error = VI_SUCCESS;
    
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[32] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_REFERENCE_LEVEL,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_REFERENCE_LEVEL,
                                                 "RefLevelType",
                                                 type,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    

    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_REFERENCE_LEVEL, 
											   referenceLevel), 4, "Reference Level");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables or disables limit checking for amplitude vs. time measurements 
/// HIFN  in the specified measurement channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Amplitude/time measurement type.
/// HIPAR limitCheck/Enables or disables limit checking for amplitude vs. time measurements 
/// HIPAR limitCheck/in the specified measurement channel.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeLimitCheck(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViInt32        limitCheck
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[32] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_SHR) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_LIMIT_CHECK,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_LIMIT_CHECK,
                                                 "AmptMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    

    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_AMPT_LIMIT_CHECK, limitCheck
                                               ), 4, "Limit Check");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper limit for limit checking, respectively.
/// HIFN  MEASurement<Measurement>:AMPTime:LCHeck<AmptMeasurementType>:<LowUpp>:LIMit
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Amplitude/time measurement type.
/// HIPAR lowerLimit/Define the lower limit for limit checking.
/// HIPAR upperLimit/Define the upper limit for limit checking.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeLimitCheckLimits(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerLimit,
    ViReal64    upperLimit
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_SHR) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_LIMIT_VALUE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_LIMIT_VALUE,
                                                 "AmptMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_AMPT_LIMIT_VALUE, lowerLimit
                                                ), 4, "Lower Limit");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_AMPT_LIMIT_VALUE, upperLimit
                                                ), 5, "Upper Limit");    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper margins for the limit check, respectively. 
/// HIFN  Margins are not as strict as limits and must be within the valid value 
/// HIFN  range.
/// HIFN  MEASurement<Measurement>:AMPTime:LCHeck<AmptMeasurementType>:<LowUpp>:MARGin
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Amplitude/time measurement type.
/// HIPAR lowerMargin/Define the lower margin for the limit check. Margins are not as strict 
/// HIPAR lowerMargin/as limits and must be within the valid value range.
/// HIPAR upperMargin/Define the upper margins for the limit check. Margins are not as 
/// HIPAR upperMargin/strict as limits and must be within the valid value range.
ViStatus _VI_FUNC rsscope_ConfigureAmplitudeTimeLimitCheckMargins(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerMargin,
    ViReal64    upperMargin
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_SHR) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_LIMIT_MARGIN,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_LIMIT_MARGIN,
                                                 "AmptMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_AMPT_LIMIT_MARGIN, lowerMargin
                                                ), 4, "Lower Margin");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_AMPT_LIMIT_MARGIN, upperMargin
                                                ), 5, "Upper Margin");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function selects the envelope.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR evnelope/Envelope selection.
ViStatus _VI_FUNC rsscope_ConfigureEnvelopeMeasurement(
    ViSession   instrSession,
    ViInt32     measurement,
    ViInt32     evnelope
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_ENVELOPE_SELECTION,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_ENVELOPE_SELECTION,
                                                 evnelope
                                                 ), 3, "Evnelope");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Defines the main measurement. This measurement is the one referred to 
/// HIFN  if the measurement waveform is used as a source for math calculations. 
/// HIFN  The main measurement type must belong to the same category as the other 
/// HIFN  types assigned to the same measurement waveform, if there are any.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
ViStatus _VI_FUNC rsscope_ConfigureEyeJitterMainMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_MAIN_MEASUREMENT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_EYE_MAIN_MEASUREMENT, measurementFunction), 3, "Eye Jitter Measurement Function");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines additional measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR enabled/Enables or disables the additional measurement.
ViStatus _VI_FUNC rsscope_ConfigureEyeJitterAdditionalMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViBoolean   enabled
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   command[50] = "";
    ViInt32  i = 0;
    ViReal64 discrete;
    ViChar   *p2string = NULL;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
                                                  RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    do
    {
        discrete = rsscope_rngEyeJitterMeasurementType.rangeValues[i].discreteOrMinValue;
        p2string = rsscope_rngEyeJitterMeasurementType.rangeValues[i].cmdString;

        if (p2string == RS_RANGE_TABLE_END_STRING)
            viCheckParm(RS_ERROR_INVALID_PARAMETER, 3, "Measurement Function");

        if (fabs(discrete - measurementFunction) <= 0.01) break;

        i++;

    } while (i != 0);
    
    sprintf (command, "MEAS%ld:ADD %s,%s\n", measurement, p2string, enabled ? "ON" : "OFF");
    checkErr (viWrite (instrSession, (ViBuf) command, (ViUInt32) strlen (command), NULL));
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables or disables limit checking for eye/jitter measurements in the 
/// HIFN  specified measurement channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Eye Jitter measurement type.
/// HIPAR limitCheck/Enables or disables limit checking for eye/jitter measurements in the 
/// HIPAR limitCheck/specified measurement channel.
ViStatus _VI_FUNC rsscope_ConfigureEyeJitterLimitCheck(
    ViSession    instrSession,
    ViInt32    measurement,
    ViInt32    measurementType,
    ViInt32    limitCheck
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_LIMIT_CHECK,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_LIMIT_CHECK,
                                                 "EyeMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");          
    
    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_EYE_LIMIT_CHECK, limitCheck
                                               ), 3, "limitCheck");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper limit for limit checking, respectively.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Eye Jitter measurement type.
/// HIPAR lowerLimit/Define the lower limit for limit checking.
/// HIPAR upperLimit/Define the upper limit for limit checking.
ViStatus _VI_FUNC rsscope_ConfigureEyeJitterLimitCheckLimits(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerLimit,
    ViReal64    upperLimit
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_LIMIT_VALUE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_LIMIT_VALUE,
                                                 "EyeMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_EYE_LIMIT_VALUE, lowerLimit
                                                ), 4, "Lower Limit");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_EYE_LIMIT_VALUE, upperLimit
                                                ), 5, "Upper Limit");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper margins for the limit check, respectively. 
/// HIFN  Margins are not as strict as limits and must be within the valid value 
/// HIFN  range.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Eye Jitter measurement type.
/// HIPAR lowerMargin/Define the lower margin for the limit check. Margins are not as strict 
/// HIPAR lowerMargin/as limits and must be within the valid value range.
/// HIPAR upperMargin/Define the upper margins for the limit check. Margins are not as 
/// HIPAR upperMargin/strict as limits and must be within the valid value range.
ViStatus _VI_FUNC rsscope_ConfigureEyeJitterLimitCheckMargins(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerMargin,
    ViReal64    upperMargin
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_LIMIT_MARGIN,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_LIMIT_MARGIN,
                                                 "EyeMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_EYE_LIMIT_MARGIN, lowerMargin
                                                ), 4, "Lower Margin");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_EYE_LIMIT_MARGIN, upperMargin
                                                ), 5, "Upper Margin");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the main measurement. This measurement is the one referred to 
/// HIFN  if the measurement waveform is used as a source for math calculations. 
/// HIFN  The main measurement type must belong to the same category as the other 
/// HIFN  types assigned to the same measurement waveform, if there are any.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
ViStatus _VI_FUNC rsscope_ConfigureSpectrumMainMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_MAIN_MEASUREMENT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_SPECTRUM_MAIN_MEASUREMENT, measurementFunction), 3, "Spectrum Measurement Function");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines additional measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR enabled/Enables or disables the additional measurement.
ViStatus _VI_FUNC rsscope_ConfigureSpectrumAdditionalMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViBoolean   enabled
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   command[50] = "";
    ViInt32  i = 0;
    ViReal64 discrete;
    ViChar   *p2string = NULL;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
                                                  RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    do
    {
        discrete = rsscope_rngSpectrumMeasurementType.rangeValues[i].discreteOrMinValue;
        p2string = rsscope_rngSpectrumMeasurementType.rangeValues[i].cmdString;

        if (p2string == RS_RANGE_TABLE_END_STRING)
            viCheckParm(RS_ERROR_INVALID_PARAMETER, 3, "Measurement Function");

        if (fabs(discrete - measurementFunction) <= 0.01) break;

        i++;

    } while (i != 0);
    
    sprintf (command, "MEAS%ld:ADD %s,%s\n", measurement, p2string, enabled ? "ON" : "OFF");
    checkErr (viWrite (instrSession, (ViBuf) command, (ViUInt32) strlen (command), NULL));
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the spectrum settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR ndBDown/Defines the threshold until which the samples to the left and right of 
/// HIPAR ndBDown/the peak value are analyzed in order to determine the "N dB down 
/// HIPAR ndBDown/bandwidth".
/// HIPAR channelBandwidth/Defines the bandwidth over which the channel power is calculated.
/// HIPAR channelCenterFrequency/Defines the center frequency from which the channel power is 
/// HIPAR channelCenterFrequency/calculated over the specified bandwidth.
/// HIPAR occupiedBandwidth/Defines the percentage of the total power used to determine the 
/// HIPAR occupiedBandwidth/occupied bandwidth.
/// HIPAR noiseReject/Defines the threshold beneath which values are rejected as noise.
ViStatus _VI_FUNC rsscope_ConfigureSpectrumSettings(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        ndBDown,
    ViReal64    channelBandwidth,
    ViReal64    channelCenterFrequency,
    ViReal64    occupiedBandwidth,
    ViInt32        noiseReject
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_N_DB_DOWN,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap), 2, "Measurement");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_SPECTRUM_N_DB_DOWN, ndBDown
                                               ), 3, "ndBDown");
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_SPECTRUM_CHANNEL_POWER_BANDWIDTH, channelBandwidth
                                                ), 4, "channelBandwidth");
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_SPECTRUM_CHANNEL_POWER_CENTER_FREQUENCY, channelCenterFrequency
                                                ), 5, "channelCenterFrequency");
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_SPECTRUM_OCCUPIED_BANDWIDTH, occupiedBandwidth
                                                ), 6, "occupiedBandwidth");      
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_SPECTRUM_NOISE_REJECT, noiseReject
                                               ), 7, "noiseReject");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables or disables limit checking for spectrum measurements in the 
/// HIFN  specified measurement channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Selects measurement to be read.
/// HIPAR limitCheck/Enables or disables limit checking for spectrum measurements in the 
/// HIPAR limitCheck/specified measurement channel.
ViStatus _VI_FUNC rsscope_ConfigureSpectrumLimitCheck(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViInt32        limitCheck
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_LIMIT_CHECK,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_LIMIT_CHECK,
                                                 "SpectrumMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");
    
    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_SPECTRUM_LIMIT_CHECK, limitCheck
                                               ), 4, "Limit Check");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper limit for limit checking, respectively.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR lowerLimit/Define the lower limit for limit checking.
/// HIPAR upperLimit/Define the upper limit for limit checking.
/// HIPAR measurementType/Selects measurement to be read.
ViStatus _VI_FUNC rsscope_ConfigureSpectrumLimitCheckLimits(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerLimit,
    ViReal64    upperLimit
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_LIMIT_VALUE,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_LIMIT_VALUE,
                                                 "SpectrumMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_SPECTRUM_LIMIT_VALUE, lowerLimit
                                                ), 4, "Lower Limit");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_SPECTRUM_LIMIT_VALUE, upperLimit
                                                ), 5, "Upper Limit");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the lower and upper margins for the limit check, respectively. 
/// HIFN  Margins are not as strict as limits and must be within the valid value 
/// HIFN  range.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementType/Selects measurement to be read.
/// HIPAR lowerMargin/Define the lower margin for the limit check. Margins are not as strict 
/// HIPAR lowerMargin/as limits and must be within the valid value range.
/// HIPAR upperMargin/Define the upper margins for the limit check. Margins are not as 
/// HIPAR upperMargin/strict as limits and must be within the valid value range.
ViStatus _VI_FUNC rsscope_ConfigureSpectrumLimitCheckMargins(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        measurementType,
    ViReal64    lowerMargin,
    ViReal64    upperMargin
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap_low[30] = "";
    ViChar    rep_cap_upp[30] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, 1, 8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, measurementType, RSSCOPE_VAL_MEAS_HIGH, RSSCOPE_VAL_MEAS_PROBEMETER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Type");
    }    
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_LIMIT_MARGIN,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_LIMIT_MARGIN,
                                                 "SpectrumMeasurementType",
                                                 measurementType - 1,
                                                 15,
                                                 rep_cap_t), 3, "Measurement Type");    
    
    sprintf (rep_cap_low, "%s,%s,Lower", rep_cap_m, rep_cap_t);
    sprintf (rep_cap_upp, "%s,%s,Upper", rep_cap_m, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_low,
                                                RSSCOPE_ATTR_SPECTRUM_LIMIT_MARGIN, lowerMargin
                                                ), 4, "Lower Margin");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_upp,
                                                RSSCOPE_ATTR_SPECTRUM_LIMIT_MARGIN, upperMargin
                                                ), 5, "Upper Margin");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the main measurement. This measurement is the one referred to 
/// HIFN  if the measurement waveform is used as a source for math calculations. 
/// HIFN  The main measurement type must belong to the same category as the other 
/// HIFN  types assigned to the same measurement waveform, if there are any.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
ViStatus _VI_FUNC rsscope_ConfigureHistogramMainMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_MAIN_MEASUREMENT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 15,
                                                 rep_cap), 2, "Measurement");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_HISTOGRAM_MAIN_MEASUREMENT, measurementFunction), 3, "Histogram Measurement Function");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines additional measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR enabled/Enables or disables the additional measurement.
ViStatus _VI_FUNC rsscope_ConfigureHistogramAdditionalMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViBoolean   enabled
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   command[50] = "";
    ViInt32  i = 0;
    ViReal64 discrete;
    ViChar   *p2string = NULL;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, measurement, RSSCOPE_VAL_MEASUREMENT_1, 
                                                  RSSCOPE_VAL_MEASUREMENT_8) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Measurement");
    }

    do
    {
        discrete = rsscope_rngHistogramMeasurementType.rangeValues[i].discreteOrMinValue;
        p2string = rsscope_rngHistogramMeasurementType.rangeValues[i].cmdString;

        if (p2string == RS_RANGE_TABLE_END_STRING)
            viCheckParm(RS_ERROR_INVALID_PARAMETER, 3, "Measurement Function");

        if (fabs(discrete - measurementFunction) <= 0.01) break;

        i++;

    } while (i != 0);
    
    sprintf (command, "MEAS%ld:ADD %s,%s\n", measurement, p2string, enabled ? "ON" : "OFF");
    checkErr (viWrite (instrSession, (ViBuf) command, (ViUInt32) strlen (command), NULL));
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the test results.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects mask to be de/activates.
/// HIPAR acquisitionsCompleted/Returns the number of tested acquisitions.
/// HIPAR acquisitionsRemaining/Returns the remaining acquisitions until "Average count / Nx Single count" is reached.
/// HIPAR state/Returns whether the test is running or has finished. The state is set to "Finished" if no acquisitions remain.
/// HIPAR sampleHits/Returns the number of sample hits that violated the mask.
/// HIPAR acquisitionHits/Returns the number of acquisitions that contained at least one sample hit.
/// HIPAR failRate/Returns the ratio of acquisition hits to the number of tested acquisitions.
/// HIPAR testResult/Returns the test result.
ViStatus _VI_FUNC rsscope_QueryMaskTestResults (ViSession instrSession,
                                                ViString maskName,
                                                ViUInt32 *acquisitionsCompleted,
                                                ViUInt32 *acquisitionsRemaining,
                                                ViInt32 *state,
                                                ViUInt32 *sampleHits,
                                                ViUInt32 *acquisitionHits,
                                                ViUInt32 *failRate,
                                                ViInt32 *testResult)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar xxstr[16] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    sprintf (buffer, "MTES:RESult:COUN:WAV? '%s'", maskName);  
    viCheckErr (viQueryf (instrSession, "%s\n", "%u", buffer, acquisitionsCompleted));
    viCheckErr(rsscope_CheckStatus(instrSession));

    sprintf(buffer, "MTES:RESult:COUN:REM? '%s'", maskName);
    viCheckErr(viQueryf (instrSession, "%s\n", "%u", buffer, acquisitionsRemaining));
    viCheckErr(rsscope_CheckStatus(instrSession));

    sprintf(buffer, "MTES:RESult:STAT? '%s'", maskName);
    viCheckErr(viQueryf (instrSession, "%s\n", "%s", buffer, xxstr));
    *state = 0;
    if (strncmp (xxstr, "RUNN", 4)==0) *state = 1;
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    sprintf(buffer, "MTES:RESult:COUN:FAIL? '%s'", maskName);
    viCheckErr(viQueryf (instrSession, "%s\n", "%u", buffer, sampleHits));
    viCheckErr(rsscope_CheckStatus(instrSession));

    sprintf(buffer, "MTES:RESult:COUN:FWAV? '%s'", maskName);
    viCheckErr(viQueryf (instrSession, "%s\n", "%u", buffer, acquisitionHits));
    viCheckErr(rsscope_CheckStatus(instrSession));

    sprintf(buffer, "MTES:RESult:FRAT? '%s'", maskName);
    viCheckErr(viQueryf (instrSession, "%s\n", "%u", buffer, failRate));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
    sprintf(buffer, "MTES:RESult:RES? '%s'", maskName);
    viCheckErr(viQueryf (instrSession, "%s\n", "%s", buffer, xxstr));
    *testResult = 0;
    if (strncmp (xxstr, "PASS", 4)==0) *testResult = 1;
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures what happens when the mask test has failed or when it has passed successfully. Each action can be initiated either on failure or on success.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR event/This Control selects event to be performed.
/// HIPAR action/This Control selects action for specified event.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestActionsOnEvent(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     event,
    ViInt32     action
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViString event_Arr[] = {"BEEP","STOP","PRIN","SAV"};
    ViString action_Arr[] = {"NOAC","SUCC","VIOL"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, event, RSSCOPE_VAL_MASK_TEST_EVENT_BEEP, RSSCOPE_VAL_MASK_TEST_EVENT_SAVE_WFM) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Event");
    }

    if (rsscope_invalidViInt32Range (instrSession, action, RSSCOPE_VAL_MASK_TEST_ACTION_NOACTION, RSSCOPE_VAL_MASK_TEST_ACTION_VIOLATION) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Action");
    }

    sprintf (buffer, "MTES:ONV:%s '%s',%s", event_Arr[event], maskName, action_Arr[action]);  

    viCheckErr (viPrintf(instrSession, "%s\n", buffer));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function creates a new mask or deletes the mask test definition with the specified name.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR action/This Control selects the requested operation.
/// HIPAR maskName/This Control selects mask to be de/activates.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestDefinition(
    ViSession   instrSession,
    ViInt32     action,
    ViString    maskName
)
{
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViString event_Arr[] = {"ADD","REM"};

    ViStatus    error = VI_SUCCESS;
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, action, RSSCOPE_VAL_MASK_TEST_ACTION_CREATE,
                                             RSSCOPE_VAL_MASK_TEST_ACTION_DELETE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Action");
    }
    sprintf (buffer, "MTES:%s '%s'", event_Arr[action], maskName);  

    viCheckErr (viPrintf(instrSession, "%s\n", buffer));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function activates and deactivates the mask test.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects mask to be de/activates.
/// HIPAR state/This Control activates or deactivates mask test.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestEnable(
    ViSession   instrSession,
    ViString    maskName,
    ViBoolean   state
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "MTES:STAT '%s',%s\n", maskName, state?"ON":"OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));  
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function sets the method of mask definition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions
/// HIPAR instrSession/function. The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects mask.
/// HIPAR definitionType/This control selects the method of mask definition.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestDefinitionType (ViSession instrSession,
                                                           ViString maskName,
                                                           ViInt32 definitionType)
{
	ViStatus    error = VI_SUCCESS;
    ViString type_Arr[] = {"USER","WFML",VI_NULL};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, definitionType, RSSCOPE_VAL_MASK_TEST_TYPE_USER,
                                                 RSSCOPE_VAL_MASK_TEST_TYPE_WAVEFORM ) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Definition Type");
    
    viCheckErr (viPrintf(instrSession, "MTES:CTYP '%s',%s\n", maskName, type_Arr[definitionType]));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function selects the waveform to be tested against the mask.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects mask.
/// HIPAR maskSource/This Control selects Mask Source.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestSource(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     maskSource
)
{
    ViStatus    error = VI_SUCCESS;
    ViString source_Arr[] = {"NONE","C1W1","C1W2","C1W3","C2W1","C2W2","C2W3","C3W1",
                             "C3W2","C3W3","C4W1","C4W2","C4W3","M1","M2","M3","M4",
                             "R1","R2","R3","R4"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, maskSource, RSSCOPE_VAL_MASK_TEST_SOURCE_NONE,
                                                 RSSCOPE_VAL_MASK_TEST_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "maskSource");
    }

    viCheckErr (viPrintf(instrSession, "MTES:SOUR '%s',%s\n", maskName, source_Arr[maskSource]));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function sets two criteria for a failed test,
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects mask.
/// HIPAR failCondition/This Control sets the first criteria for a failed test.
/// HIPAR violationTolerance/This Control sets the second criteria for a failed test, the number of tolerable sample hits or acquisition hits.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestSettings(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     failCondition,
    ViUInt32    violationTolerance
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, failCondition, 
        RSSCOPE_VAL_MASK_SAMPLES, RSSCOPE_VAL_MASK_ACQUISITIONS) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "failCondition");
    }
    if (rsscope_invalidViUInt32Range (instrSession, violationTolerance, 0, 4000000000) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "violationTolerance");
    }

    viCheckErr (viPrintf(instrSession, "MTES:COND '%s',%s\n", maskName, failCondition==0?"SAMP":"ACQ"));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
    viCheckErr (viPrintf(instrSession, "MTES:TOL '%s',%ld\n", maskName, violationTolerance));

    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function defines the region of the segment that builds the mask and enables and disables the mask segment. Disabled segments are not considered by running tests.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR maskSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR state/This Control enables and disables the mask segment.
/// HIPAR region/This Control defines the region of the segment that builds the mask and enables and disables the mask segment.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestSegments(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     maskSegment,
    ViBoolean   state,
    ViInt32     region
)
{
    ViStatus    error = VI_SUCCESS;
    ViString region_Arr[] = {"UPPER","LOWER","INNER"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, region, 
        RSSCOPE_VAL_MASK_TEST_UPPER, RSSCOPE_VAL_MASK_TEST_INNER) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "region");
    }

    viCheckErr (viPrintf(
        instrSession, "MTES:SEGM:STAT '%s',%ld,%s\n", maskName, maskSegment, state?"ON":"OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));

    viCheckErr (viPrintf(
        instrSession, "MTES:SEGM:REG '%s',%ld,%s\n", maskName, maskSegment, region_Arr[region]));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the number of segments in the mask definition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR maskSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR segmentsNumber/This Output shows number of segments in the mask definition.
ViStatus _VI_FUNC rsscope_QueryMaskTestSegmentsCount(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     maskSegment,
    ViInt32*    segmentsNumber
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr(viQueryf (instrSession, "MTES:SEGM:COUN? '%s',%ld\n", "%ld", maskName, maskSegment, segmentsNumber));

    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function manipulates (creates, removes or inserts) with the specified segment in the mask definition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR maskSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR action/This Control selects action to be performed.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestSegmentsOperation(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     maskSegment,
    ViInt32     action
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    switch (action) 
    {   case RSSCOPE_VAL_ADD:
            sprintf(buffer, "MTES:SEGM:ADD '%s'", maskName);
            break;
        case RSSCOPE_VAL_REMOVE:
            sprintf(buffer, "MTES:SEGM:REM '%s',%ld", maskName, maskSegment);
            break;
        case RSSCOPE_VAL_INSERT:
            sprintf(buffer, "MTES:SEGM:INS '%s',%ld", maskName, maskSegment);
            break;
        default:
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "action");
    }

    viCheckErr (viPrintf(instrSession, "%s\n", buffer));

    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function defines the x-value and y-value of the mask segment point.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR maskSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR pointIndex/This Control sets index of the mask segment point in the mask definition.
/// HIPAR xValue/This Control defines the x-value of the mask segment point.
/// HIPAR yValue/This Control defines the y-value of the mask segment point.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestSegmentDefinition(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     maskSegment,
    ViInt32     pointIndex,
    ViReal64    xValue,
    ViReal64    yValue
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViReal64Range (instrSession, xValue, -100.0E+24, 100.0E+24) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "xValue");
    }
    if (rsscope_invalidViReal64Range (instrSession, yValue, -100.0E+24, 100.0E+24) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "yValue");
    }
    viCheckErr (viPrintf(
        instrSession, "MTES:SEGM:POIN:X '%s',%ld,%ld,%.12lG\n", maskName, maskSegment, pointIndex, xValue));
    viCheckErr(rsscope_CheckStatus(instrSession));

    viCheckErr (viPrintf(
        instrSession, "MTES:SEGM:POIN:Y '%s',%ld,%ld,%.12lG\n", maskName, maskSegment, pointIndex, yValue));
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the number of defined points for the specified mask segment.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR pointsNumber/This Output shows number of segments in the mask definition.
/// HIPAR maskSegment/This Control sets index of the mask segment in the mask definition.
ViStatus _VI_FUNC rsscope_QueryMaskTestSegmentDefinitionCount (ViSession instrSession,
                                                               ViString maskName,
                                                               ViInt32 maskSegment,
                                                               ViInt32 *pointsNumber)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr(viQueryf (instrSession, 
        "MTES:SEGM:POIN:COUN? '%s',%ld\n", "%ld", maskName, maskSegment, pointsNumber));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function manipulates (creates, removes or inserts) with the specified point of the mask segment definition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR definitionOfSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR pointIndex/This Control sets index of the point in the mask segment in the mask definition.
/// HIPAR action/This Control selects action to be performed.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestSegmentDefinitionOperation(
    ViSession   instrSession,
    ViString    maskName,
    ViInt32     definitionOfSegment,
    ViInt32     pointIndex,
    ViInt32     action
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    switch (action) 
    {   case RSSCOPE_VAL_ADD:
            sprintf(buffer, "MTES:SEGM:POIN:ADD '%s',%ld", maskName, definitionOfSegment);
            break;
        case RSSCOPE_VAL_REMOVE:
            sprintf(buffer, "MTES:SEGM:POIN:REM '%s',%ld,%ld", maskName, definitionOfSegment, pointIndex);
            break;
        case RSSCOPE_VAL_INSERT:
            sprintf(buffer, "MTES:SEGM:POIN:INS '%s',%ld,%ld", maskName, definitionOfSegment, pointIndex);
            break;
        default:
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "action");
    }

    viCheckErr (viPrintf(instrSession, "%s\n", buffer));

    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function moves or stretches the mask segment horizontally/vertically.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR definitionOfSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR offsetX/This Control is reserved for future use.
/// HIPAR factorX/This Control defines rate of stretches or compresses the selected mask segment in horizontal direction.
/// HIPAR offsetY/This Control moves the mask segment vertically.
/// HIPAR factorY/This Control defines rate of stretches or compresses the selected mask segment in vertical direction.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestRescale(
    ViSession   instrSession,
    ViInt32     definitionOfSegment,
    ViString    maskName,
    ViReal64    offsetX,
    ViInt32     factorX,
    ViReal64    offsetY,
    ViInt32     factorY
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViReal64Range (instrSession, offsetX, -50, 50) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Offset X");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, factorX, -100, 100) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "factorX");
    }
    if (rsscope_invalidViReal64Range (instrSession, offsetY, -1000.0, 1000.0) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "offsetY");
    }
    if (rsscope_invalidViInt32Range (instrSession, factorY, -100, 100) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "factorY");
    }
                        
    viCheckErr (viPrintf(instrSession, 
        "MTES:SEGM:RESC:XOFF '%s',%ld,%.12lG\n", maskName, definitionOfSegment, offsetX));
                                             
    viCheckErr (viPrintf(instrSession, 
        "MTES:SEGM:RESC:XFAC '%s',%ld,%ld\n", maskName, definitionOfSegment, factorX));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

    viCheckErr (viPrintf(instrSession, 
        "MTES:SEGM:RESC:YOFF '%s',%ld,%.12lG\n", maskName, definitionOfSegment, offsetY));

    viCheckErr(rsscope_CheckStatus(instrSession));

    viCheckErr (viPrintf(instrSession, 
        "MTES:SEGM:RESC:YFAC '%s',%ld,%ld\n", maskName, definitionOfSegment, factorY));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function creates the upper and lower mask limit from the 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions 
/// HIPAR instrSession/function. The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR usedReference/Sets the reference waveform from which the mask is created.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestWaveformCopy (ViSession instrSession,
                                                         ViString maskName,
                                                         ViInt32 usedReference)
{
	ViStatus    error = VI_SUCCESS;
    ViString reference_arr[] = {"REFERENCE1","REFERENCE2","REFERENCE3","REFERENCE4",VI_NULL};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, usedReference, RSSCOPE_VAL_MASK_TEST_REFERENCE1,
                                                 RSSCOPE_VAL_MASK_TEST_REFERENCE4 ) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Used Reference");
    
    viCheckErr (viPrintf(instrSession, "MTES:REFW \"%s\",%s\n", maskName, reference_arr[usedReference - 1]));
    
    viCheckErr(rsscope_CheckStatus (instrSession));
	
	viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_MASK_COPY_WAVEFORM, maskName
                                                ), 2, "Mask Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function moves or stretches the waveform mask horizontally/vertically.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions 
/// HIPAR instrSession/function. The handle identifies a particular instrument session.
/// HIPAR maskName/This Control selects the mask.
/// HIPAR horizontalWidth/Sets the width of the mask in horizontal direction. 
/// HIPAR verticalWidth/Sets the width of the waveform mask in vertical direction.
/// HIPAR verticalStretch/This control sets the vertical scaling to stretch the mask in y-direction.
/// HIPAR verticalPosition/This control moves the mask vertically within the display.
ViStatus _VI_FUNC rsscope_ConfigureMaskTestWaveformRescale (ViSession instrSession,
                                                            ViString maskName,
                                                            ViReal64 horizontalWidth,
                                                            ViReal64 verticalWidth,
                                                            ViInt32 verticalStretch,
                                                            ViReal64 verticalPosition)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViReal64Range (instrSession, horizontalWidth, 0, 100E+24) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "horizontalWidth");
    if (rsscope_invalidViReal64Range (instrSession, verticalWidth, 0, 100E+24) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "verticalWidth");
    if (rsscope_invalidViInt32Range (instrSession, verticalStretch, 10, 100) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "verticalStretch");
    if (rsscope_invalidViReal64Range (instrSession, verticalPosition, -100E+24, 100E+24) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "verticalPosition");
    
    viCheckErr (viPrintf(instrSession, 
        "MTES:WFMR:XWID '%s',%.12lG\n", maskName, horizontalWidth));
                                             
    viCheckErr(rsscope_CheckStatus(instrSession));
	
	viCheckErr (viPrintf(instrSession, 
        "MTES:WFMR:YWID '%s',%.12lG\n", maskName, verticalWidth));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

    viCheckErr (viPrintf(instrSession, 
        "MTES:WFMR:YSTR '%s',%ld\n", maskName, verticalStretch));

    viCheckErr(rsscope_CheckStatus(instrSession));

    viCheckErr (viPrintf(instrSession, 
        "MTES:WFMR:YPOS '%s',%.12lG\n", maskName, verticalPosition));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function multiplies and adds the given x- and y-factors and offsets to the coordinates of all points of the selected mask segment.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or rsscope_InitWithOptions function.  The handle identifies a particular instrument session.
/// HIPAR definitionOfSegment/This Control sets index of the mask segment in the mask definition.
/// HIPAR maskName/This Control selects the mask.
ViStatus _VI_FUNC rsscope_MaskTestRecalculate(
    ViSession   instrSession,
    ViInt32     definitionOfSegment,
    ViString    maskName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, 
        "MTES:SEGM:RESC:REC '%s',%ld\n", maskName, definitionOfSegment));
    
    viCheckErr(rsscope_CheckStatus(instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function creates a new search definition with the specified name.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies the name of the new search definition.
ViStatus _VI_FUNC rsscope_NewSearch(
    ViSession    instrSession,
    ViString    searchName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_NEW_SEARCH, searchName
                                                ), 2, "Search Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function deletes the specified search definition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Deletes the specified search definition.
ViStatus _VI_FUNC rsscope_DeleteSearch(
    ViSession    instrSession,
    ViString    searchName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_DELETE_SEARCH, searchName
                                                ), 2, "Search Name");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the source of the search. The source can be 
/// HIFN  any input signal, math or reference waveform. Depending on the selected 
/// HIFN  source, not all search conditions are available.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR searchConditionSource/Selects the source of the search.
ViStatus _VI_FUNC rsscope_ConfigureSearchSource(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        searchConditionSource
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, searchConditionSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                             RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Search Condition Source");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:SOUR '%s',%s\n", searchName, searchSource_Arr[searchConditionSource]));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function assigns the search definition to a search category.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR searchCategory/Selects the search category.
ViStatus _VI_FUNC rsscope_ConfigureSearchCategory(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        searchCategory
)
{
    ViStatus    error = VI_SUCCESS;
    ViString searchCategory_Arr[] = {"TRIG","FREQ"};
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchCategory, RSSCOPE_VAL_SEARCH_CATEGORY_TRIG,
                                                      RSSCOPE_VAL_SEARCH_CATEGORY_FREQ ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Search Category");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:CAT '%s',%s\n", searchName, searchCategory_Arr[searchCategory]));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}
    
/// HIFN  This function enables a repeated search for each new data acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR searchOnline/If enabled, a search is performed repeatedly for each new data 
/// HIPAR searchOnline/acquisition.
ViStatus _VI_FUNC rsscope_ConfigureSearchControl(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    searchOnline
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (viPrintf(instrSession, "SEAR:ONL '%s',%s\n", searchName, (searchOnline == VI_TRUE) ? "ON" : "OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}
 
/// HIFN  This function performs a single search on the existing data from the 
/// HIFN  selected source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR searchResults/Selects the search results.
ViStatus _VI_FUNC rsscope_PerformSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        searchResults
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, searchResults, RSSCOPE_VAL_SEARCH_RESULT_NEXT,
                                                     RSSCOPE_VAL_SEARCH_RESULT_ALL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Search Results");
    }

    switch (searchResults)
    {
        case RSSCOPE_VAL_SEARCH_RESULT_NEXT:
            viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_SEARCH_NEXT_RESULT, searchName
                                                ), 2, "Search Name");
        break;
        
        case RSSCOPE_VAL_SEARCH_RESULT_ALL:
            viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_SEARCH_ALL_RESULTS, searchName
                                                ), 2, "Search Name");
        break;
        
        default: break;
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function clears the search results once to start a new search.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
ViStatus _VI_FUNC rsscope_ClearSearchResults(
    ViSession    instrSession,
    ViString    searchName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_CLEAR_SEARCH_RESULTS, searchName
                                                ), 2, "Search Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns all search results.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR bufferSize/Pass the number of elements in the Search Results parameter.
/// HIPAR acquisitionIndex/Acquistion index.
/// HIPAR xPosition/ X-position of the search result
/// HIPAR yPosition/Y-position of the search result, currently not relevant
/// HIPAR typeOfSearchResult/Type of the search result.
/// HIPAR slope/Slope or polarity of the search result.
/// HIPAR timeResult/For runt, glitch, width, and window searches, the value contains
/// HIPAR timeResult/the width. For timeout and interval searches, it contains the
/// HIPAR timeResult/timeout. For transition searches, it contains the slew rate. For
/// HIPAR timeResult/all other searches, the value is not relevant.
/// HIPAR timeResult/If a value is not relevant, 9.91E+37 is returned.
/// HIPAR actualValues/Indicates the number of points the function places in the Search 
/// HIPAR actualValues/Results parameter.
ViStatus _VI_FUNC rsscope_QuerySearchResults (ViSession instrSession,
                                              ViString searchName,
                                              ViInt32 bufferSize,
                                              ViInt32 acquisitionIndex[],
                                              ViReal64 xPosition[],
                                              ViReal64 yPosition[],
                                              ViInt32 typeOfSearchResult[],
                                              ViInt32 slope[],
                                              ViReal64 timeResult[],
                                              ViInt32 *actualValues)
{
    ViStatus    error = VI_SUCCESS;
    
    ViChar   header[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar   *p2buf  = NULL;
    ViChar   *p2data  = NULL;
    ViUInt32 count = 0;
    ViInt32  i = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    sprintf (header, "SEAR:RES:ALL? '%s'", searchName);
    checkErr (viWrite (instrSession, (ViBuf) header, (ViUInt32) strlen (header), NULL));
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2data, &count));
    checkErr (rsscope_CheckStatus (instrSession));        
        
    p2buf = strtok (p2data, ",");

    while (p2buf && (i<bufferSize))
    {
        acquisitionIndex[i] = atol (p2buf);
        p2buf = strtok (NULL, ",");
        
        if (p2buf != NULL)
            xPosition[i] = atof (p2buf);
        p2buf = strtok (NULL, ",");
        
        if (p2buf != NULL)
            yPosition[i] = atof (p2buf);
        p2buf = strtok (NULL, ",");
        
        if (p2buf != NULL)
            typeOfSearchResult[i] = rsscope_StringIndex (typeArr,p2buf);
        p2buf = strtok (NULL, ",");
        
        if (p2buf != NULL)
            slope[i] = rsscope_StringIndex (polarityArr,p2buf);;
        p2buf = strtok (NULL, ",");
        
        if (p2buf != NULL)
            timeResult[i++] = atof (p2buf);
        p2buf = strtok (NULL, ",");
    }
    *actualValues = i;

Error:
    if (p2data) free (p2data);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function copies the trigger event configuration from Trigger A or 
/// HIFN  B for the selected channel source to the search condition settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerType/Sets the trigger type.
/// HIPAR copyFrom/Selects the trigger event configuration to copy from.
ViStatus _VI_FUNC rsscope_SearchTriggerCopyConfiguration(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        triggerType,
    ViInt32        copyFrom
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar rep_cap[20]= "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, triggerType, RSSCOPE_VAL_EDGE_TRIGGER,
                                                  RSSCOPE_VAL_STATE_TRIGGER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Trigger Type");
    }    

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SEARCH_COPY_FROM_A,
                                                 "SearchTrigger",
                                                 triggerType,
                                                 20,
                                                 rep_cap), 3, "Trigger Type"); 
    switch (copyFrom)
    {
        case RSSCOPE_VAL_COPY_FROM_A:
            viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_SEARCH_COPY_FROM_A, searchName
                                                ), 2, "Search Name");
        break;
        
        case RSSCOPE_VAL_COPY_FROM_B:
			if (triggerType == RSSCOPE_VAL_EDGE_TRIGGER)
			{
				viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_SEARCH_COPY_FROM_B, searchName
			                                   ), 2, "Search Name");
			}
        break;
        
        default: 
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Copy From");
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the edge trigger search.  
/// HIFN  An edge trigger occurs when the trigger signal passes through the 
/// HIFN  voltage threshold that you specify with the Trigger Level parameter and 
/// HIFN  has the slope that you specify with the Trigger Slope parameter.  
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the edge trigger event type in the 
/// HIPAR triggerState/next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR triggerLevel/Sets the voltage level for the trigger level that is used to determine 
/// HIPAR triggerLevel/other parameters.
/// HIPAR triggerSlope/Selects the edge type.
ViStatus _VI_FUNC rsscope_ConfigureEdgeTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    triggerLevel,
    ViInt32        triggerSlope
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }

    if (rsscope_invalidViInt32Range (instrSession, triggerSlope, RSSCOPE_VAL_POSITIVE,
                                                      RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Trigger Slope");
    }
    
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:EDGE:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:VAL '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], triggerLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:EDGE:SLOP '%s',%s\n", searchName, searchPolarity_Arr[triggerSlope]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the glitch trigger search. 
/// HIFN   A glitch trigger occurs when the trigger signal has a pulse with a 
/// HIFN  width that is less than the glitch width.  You specify the glitch width 
/// HIFN  in the Glitch Width parameter.  You specify the polarity of the pulse 
/// HIFN  with the Glitch Polarity parameter.  The trigger does not actually 
/// HIFN  occur until the edge of a pulse that corresponds to the Glitch Width 
/// HIFN  and Glitch Polarity crosses the threshold you specify in the Trigger 
/// HIFN  Level parameter. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the glitch trigger event type in 
/// HIPAR triggerState/the next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR triggerLevel/Sets the voltage level for the trigger level that is used to determine 
/// HIPAR triggerLevel/other parameters.
/// HIPAR glitchWidth/Sets the length of a glitch. The instrument triggers on pulses shorter 
/// HIPAR glitchWidth/or longer than this value.
/// HIPAR glitchPolarity/Defines the polarity of a pulse, that is the direction of the first 
/// HIPAR glitchPolarity/pulse slope.
/// HIPAR glitchCondition/Selects which glitches are identified: shorter or longer than the 
/// HIPAR glitchCondition/width.
ViStatus _VI_FUNC rsscope_ConfigureGlitchTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    triggerLevel,
    ViReal64    glitchWidth,
    ViInt32        glitchPolarity,
    ViInt32        glitchCondition
)
{
    ViStatus    error = VI_SUCCESS;
    
    ViString condition_Arr[] = {"SHOR", "LONG"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, glitchWidth, 100.0E-12, 1.0E-3 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Glitch Width");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, glitchPolarity, RSSCOPE_VAL_POSITIVE,
                                                      RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "Glitch Polarity");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, glitchCondition, RSSCOPE_VAL_SHORTER,
                                                       RSSCOPE_VAL_LONGER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 8, "Glitch Condition");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:GLIT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:VAL '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], triggerLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:GLIT:POL '%s',%s\n", searchName, searchPolarity_Arr[glitchPolarity]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:GLIT:RANG '%s',%s\n", searchName, condition_Arr[glitchCondition]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:GLIT:WIDT '%s',%.12lG\n", searchName, glitchWidth));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the width trigger search.  
/// HIFN  A width trigger occurs when the oscilloscope detects a positive or 
/// HIFN  negative pulse with a width between, or optionally outside, the width 
/// HIFN  thresholds.  You specify the width thresholds with the Width Low 
/// HIFN  Threshold and Width High Threshold parameters.  You specify whether the 
/// HIFN  oscilloscope triggers on pulse widths that are within or outside the 
/// HIFN  width thresholds with the Width Condition parameter.  You specify the 
/// HIFN  polarity of the pulse with the Width Polarity parameter.  The trigger 
/// HIFN  does not actually occur until the edge of a pulse that corresponds to 
/// HIFN  the Width Low Threshold, Width High Threshold, Width Condition, and 
/// HIFN  Width Polarity crosses the threshold you specify in the Trigger Level 
/// HIFN  parameter.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the width trigger event type in the 
/// HIPAR triggerState/next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR triggerLevel/Sets the voltage level for the trigger level that is used to determine 
/// HIPAR triggerLevel/other parameters.
/// HIPAR width/For the ranges "Within" and "Outside", the width defines the center of 
/// HIPAR width/a range which is defined by the limits "+/-Delta". For the ranges 
/// HIPAR width/"Shorter" and "Longer", the width defines the maximum and minimum pulse 
/// HIPAR width/width, respectively.
/// HIPAR widthDelta/Defines a range around the width value.
/// HIPAR widthPolarity/Sets the polarity of the pulse.
/// HIPAR widthRange/Sets how the measured pulse width is compared with the given limit(s).
ViStatus _VI_FUNC rsscope_ConfigureWidthTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    triggerLevel,
    ViReal64    width,
    ViReal64    widthDelta,
    ViInt32        widthPolarity,
    ViInt32        widthRange
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, width, 100E-12, 864.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Glitch Width");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, widthDelta, 0.0, 432.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "Width Delta");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, widthPolarity, RSSCOPE_VAL_POSITIVE,
                                                      RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 8, "Width Polarity");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, widthRange, RSSCOPE_VAL_SHORTER,
                                                       RSSCOPE_VAL_OUTSIDE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 9, "Width Range");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIDT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:VAL '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], triggerLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIDT:WIDT '%s',%.12lG\n", searchName, width));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIDT:DELT '%s',%.12lG\n", searchName, widthDelta));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIDT:POL '%s',%s\n", searchName, searchPolarity_Arr[widthPolarity]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIDT:RANG '%s',%s\n", searchName, searchCondition_Arr[widthRange]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the runt trigger search.  
/// HIFN  A runt trigger occurs when the trigger signal crosses one of the runt 
/// HIFN  thresholds twice without crossing the other runt threshold.  You 
/// HIFN  specify the runt thresholds with the  Runt Low Threshold and Runt High 
/// HIFN  Threshold parameters.  You specify the polarity of the runt with the 
/// HIFN  Runt Polarity parameter.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the runt trigger event type in the 
/// HIPAR triggerState/next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR runtLowThreshold/Sets the lower voltage threshold.
/// HIPAR runtHighThreshold/Sets the upper voltage threshold.
/// HIPAR runtPolarity/Defines the polarity of a pulse, that is the direction of the first 
/// HIPAR runtPolarity/pulse slope.
ViStatus _VI_FUNC rsscope_ConfigureRuntTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    runtLowThreshold,
    ViReal64    runtHighThreshold,
    ViInt32        runtPolarity
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, runtPolarity, RSSCOPE_VAL_POSITIVE,
                                                   RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Runt Polarity");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:RUNT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:RUNT:LOW '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], runtLowThreshold));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:RUNT:UPP '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], runtHighThreshold));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:RUNT:POL '%s',%s\n", searchName, searchPolarity_Arr[runtPolarity]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Configures Runt trigger search range and condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR runtWidth/For the ranges "Shorter" and "Longer", the runt width defines the 
/// HIPAR runtWidth/maximum and minimum pulse width, respectively.
/// HIPAR runtDelta/Defines a range around the runt width specified using Runt Width. This 
/// HIPAR runtDelta/control is only available if Runt Range is set to Within or Outside
/// HIPAR runtRange/Selects how the time limit of the runt pulse is defined based on the 
/// HIPAR runtRange/runt width and delta
ViStatus _VI_FUNC rsscope_ConfigureRuntTriggerSearchRange(
    ViSession    instrSession,
    ViString    searchName,
    ViReal64    runtWidth,
    ViReal64    runtDelta,
    ViInt32        runtRange
)
{
    ViStatus    error = VI_SUCCESS;
    
    ViString runtRange_Arr[] = {"SHOR","LONG","WITH","OUTS","ANY"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViReal64Range (instrSession, runtWidth, 100E-12, 864.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Runt Width");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, runtDelta, 100E-12, 864.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Runt Delta");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, runtRange, RSSCOPE_VAL_SHORTER, RSSCOPE_VAL_ANY ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Runt Range");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:RUNT:RANG '%s',%s\n", searchName, runtRange_Arr[runtRange]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:RUNT:WIDT '%s',%.12lG\n", searchName, runtWidth));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:RUNT:DELT '%s',%.12lG\n", searchName, runtDelta));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the window trigger search. 
/// HIFN  The window trigger checks the signal run in relation to a "window". The 
/// HIFN  window is formed by the upper and lower voltage levels. The event 
/// HIFN  condition is fulfilled, if the waveform enters or leaves the window, or 
/// HIFN  if the waveform stays inside or outside for a time longer or shorter 
/// HIFN  than specified. With the window trigger, you can display longer 
/// HIFN  transient effects.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the window trigger event type in 
/// HIPAR triggerState/the next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR windowLowerLimit/Sets the lower voltage limit for the window.
/// HIPAR windowUpperLimit/Sets the upper voltage limit for the window.
ViStatus _VI_FUNC rsscope_ConfigureWindowTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    windowLowerLimit,
    ViReal64    windowUpperLimit
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIND:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:WIND:UPP '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], windowUpperLimit));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:WIND:LOW '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], windowLowerLimit));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Configures Window trigger search range and condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR verticalCondition/Defines the signal run in relation to the window.
/// HIPAR timeCondition/Selects how the time limit of the window is defined. Time conditioning 
/// HIPAR timeCondition/is available for the vertical conditions "WITHin" and "OUTSide".
/// HIPAR windowWidth/For the ranges "Within" and "Outside", the width defines the center of 
/// HIPAR windowWidth/a time range which is defined by the limits "Delta".
/// HIPAR windowDelta/Defines a range around the "Width" value.
ViStatus _VI_FUNC rsscope_ConfigureWindowTriggerSearchRange(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        verticalCondition,
    ViInt32        timeCondition,
    ViReal64    windowWidth,
    ViReal64    windowDelta
)
{
    ViStatus    error = VI_SUCCESS;
    ViString verticalCondition_Arr[] = {"ENT", "EXIT", "WITH", "OUTS"};
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, verticalCondition, RSSCOPE_VAL_ENTER,
                                                        RSSCOPE_VAL_OUTSIDE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Vertical Condition");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, timeCondition, RSSCOPE_VAL_SHORTER,
                                                     RSSCOPE_VAL_OUTSIDE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Time Condition");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, windowWidth, 1.0E-010, 864.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Window Width");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, windowDelta, 0.0, 432.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Window Delta");
    }    

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIND:RANG '%s',%s\n", searchName, verticalCondition_Arr[verticalCondition]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIND:TIM '%s',%s\n", searchName, searchCondition_Arr[timeCondition]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIND:WIDT '%s',%.12lG\n\n", searchName, windowWidth));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:WIND:DELT '%s',%.12lG\n\n", searchName, windowDelta));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the timeout trigger 
/// HIFN  search. The timeout trigger event checks if the signal stays above or 
/// HIFN  below the threshold voltage for a specified time lapse. In other words, 
/// HIFN  the event occurs if the trigger source does not have the expected 
/// HIFN  transition within the specified time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the timeout trigger event type in 
/// HIPAR triggerState/the next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and source.
/// HIPAR timeoutValue/Defines the time limit for the timeout at which the instrument 
/// HIPAR timeoutValue/triggers.
/// HIPAR timeoutCondition/Defines the relation of the signal level to the trigger level.
ViStatus _VI_FUNC rsscope_ConfigureTimeoutTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    triggerLevel,
    ViReal64    timeoutValue,
    ViInt32        timeoutCondition
)
{
    ViStatus    error = VI_SUCCESS;
    ViString timeoutCondition_Arr[] = {"LOW", "HIGH", "EITH"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, timeoutValue, 1.0E-010, 864.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Timeout Value");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, timeoutCondition, RSSCOPE_VAL_TIMEOUT_LOW,
                                                          RSSCOPE_VAL_TIMEOUT_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "Timeout Condition");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:TIM:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:VAL '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], triggerLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:TIM:TIME '%s',%.12lG\n", searchName, timeoutValue));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:TIM:RANG '%s',%s\n", searchName, timeoutCondition_Arr[timeoutCondition]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the interval trigger 
/// HIFN  search. The interval trigger analyzes the time between two pulses. 
/// HIFN  While the interval trigger can only analyze either positive or negative 
/// HIFN  polarity, searching for an interval is also possible for both 
/// HIFN  polarities at the same time ("Either").
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the interval trigger event type in 
/// HIPAR triggerState/the next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR triggerLevel/Sets the trigger level for the specified event and source.
/// HIPAR intervalWidth/Defines the time between two pulses.
/// HIPAR intervalDelta/Defines a range around the "Interval width" value.
/// HIPAR intervalPolarity/Defines the polarity of a pulse, that is the direction of the first 
/// HIPAR intervalPolarity/pulse slope.
/// HIPAR intervalCondition/Defines the range of an interval in relation to the interval width.
ViStatus _VI_FUNC rsscope_ConfigureIntervalTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    triggerLevel,
    ViReal64    intervalWidth,
    ViReal64    intervalDelta,
    ViInt32        intervalPolarity,
    ViInt32        intervalCondition
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, intervalWidth, 1.0E-010, 10000.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Interval Width");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, intervalDelta, 0, 10.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "Interval Delta");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, intervalPolarity, RSSCOPE_VAL_POSITIVE,
                                                        RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 8, "Interval Polarity");
    }

    if (rsscope_invalidViInt32Range (instrSession, intervalCondition, RSSCOPE_VAL_SHORTER,
                                                         RSSCOPE_VAL_OUTSIDE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 9, "Interval Polarity");
    }
    
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:INT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:VAL '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], triggerLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:INT:WIDT '%s',%.12lG\n", searchName, intervalWidth));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:INT:DELT '%s',%.12lG\n", searchName, intervalDelta));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:INT:POL '%s',%s\n", searchName, searchPolarity_Arr[intervalPolarity]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:INT:RANG '%s',%s\n", searchName, searchCondition_Arr[intervalCondition]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the slew rate trigger 
/// HIFN  search. The slew rate trigger, also known as transition trigger, can 
/// HIFN  detect fast or slow edges selectively. It triggers on edges, if the 
/// HIFN  transition time from the lower to higher voltage level (or vice versa) 
/// HIFN  is shorter or longer as defined, or outside a specified time range. The 
/// HIFN  trigger event finds slew rates faster than expected or permissible to 
/// HIFN  avoid overshooting and other interfering effects. It also detects very 
/// HIFN  slow edges violating the timing in pulse series.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the slew rate trigger event type in 
/// HIPAR triggerState/the next search.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR slewRateLowerLimit/Defines the lower voltage threshold. When the signal crosses this 
/// HIPAR slewRateLowerLimit/level, the slew rate measurement starts or stops depending on the 
/// HIPAR slewRateLowerLimit/selected slope.
/// HIPAR slewRateUpperLimit/Defines the upper voltage threshold. When the signal crosses this 
/// HIPAR slewRateUpperLimit/level, the slew rate measurement starts or stops depending on the 
/// HIPAR slewRateUpperLimit/selected slope.
ViStatus _VI_FUNC rsscope_ConfigureSlewRateTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    slewRateLowerLimit,
    ViReal64    slewRateUpperLimit
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:SLEW:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:TRAN:UPP '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], slewRateUpperLimit));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:TRAN:LOW '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], slewRateLowerLimit));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Configures slew rate trigger search range and condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR slewRate/For the ranges "Within" and "Outside", the slew rate defines the 
/// HIPAR slewRate/center of a range which is defined by the limits "Delta".
/// HIPAR slewRateDelta/Defines a time range around the slew rate.
/// HIPAR slewRateCondition/Selects how the time limit for the slew rate is defined. The time 
/// HIPAR slewRateCondition/measurement starts when the signal crosses the first trigger level - 
/// HIPAR slewRateCondition/the upper or lower level depending on the selected slope - and stops 
/// HIPAR slewRateCondition/when the signal crosses the second level.
/// HIPAR slewRatePolarity/Selects the edge type for the trigger event.
ViStatus _VI_FUNC rsscope_ConfigureSlewRateTriggerSearchRange(
    ViSession    instrSession,
    ViString    searchName,
    ViReal64    slewRate,
    ViReal64    slewRateDelta,
    ViInt32        slewRateCondition,
    ViInt32        slewRatePolarity
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViReal64Range (instrSession, slewRate, 1.0E-010, 864.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Slew Rate");
    }    
    
    if (rsscope_invalidViReal64Range (instrSession, slewRateDelta, 0.0, 10.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Slew Rate Delta");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, slewRateCondition, RSSCOPE_VAL_SHORTER,
                                                         RSSCOPE_VAL_OUTSIDE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Slew Rate Condition");
    }

    if (rsscope_invalidViInt32Range (instrSession, slewRatePolarity, RSSCOPE_VAL_POSITIVE,
                                                        RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Slew Rate Polarity");
    }
    
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:SLEW:TIME '%s',%.12lG\n", searchName, slewRate));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:SLEW:DELT '%s',%.12lG\n", searchName, slewRateDelta));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:SLEW:SLOP '%s',%s\n", searchName, searchPolarity_Arr[slewRatePolarity]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:SLEW:RANG '%s',%s\n", searchName, searchSlewCondition_Arr[slewRateCondition]));
    viCheckErr(rsscope_CheckStatus(instrSession));
        
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the data 2 clock trigger 
/// HIFN  search. With the Data2Clock event - also known as setup/hold - you can 
/// HIFN  analyze the relative timing between two signals: a data signal and the 
/// HIFN  synchronous clock signal. Many systems require, that the data signal 
/// HIFN  must be steady for some time before and after the clock edge, for 
/// HIFN  example, the data transmission on parallel interfaces. With this 
/// HIFN  trigger type, you can also test the time correlation of sideband and 
/// HIFN  inband signals. The event occurs if the data signal crosses the data 
/// HIFN  level during the setup and hold time. The reference point for the time 
/// HIFN  measurement is defined by clock level and clock edge.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the data2clock trigger event type 
/// HIPAR triggerState/in the next search.
/// HIPAR clockEdge/Sets the edge of the clock signal to define the time reference point 
/// HIPAR clockEdge/for the setup and hold time.
/// HIPAR dataLevel/Sets the trigger level for the specified event and source.
/// HIPAR searchSource/Selects the source of the search.
/// HIPAR holdTime/Sets the minimum time after the clock edge while the data signal must 
/// HIPAR holdTime/stay steady above or below the data level. The hold time can be 
/// HIPAR holdTime/negative. In this case, the setup time is always positive. The 
/// HIPAR holdTime/setup/hold interval starts before the clock edge (setup time) and ends 
/// HIPAR holdTime/before the clock edge (hold time). If you change the negative hold 
/// HIPAR holdTime/time, the setup time is adjusted by the intrument.
/// HIPAR setupTime/Sets the minimum time before the clock edge while the data signal must 
/// HIPAR setupTime/stay steady above or below the data level. The setup time can be 
/// HIPAR setupTime/negative. In this case, the hold time is always positive. The 
/// HIPAR setupTime/setup/hold interval starts after the clock edge (setup time) and ends 
/// HIPAR setupTime/after the clock edge (hold time). If you change the negative setup 
/// HIPAR setupTime/time, the hold time is adjusted by the intrument.
/// HIPAR clockLevel/Sets the voltage level for the clock signal.
/// HIPAR clockSource/Selects the waveform used for the clock signal.
ViStatus _VI_FUNC rsscope_ConfigureData2ClockTriggerSearch(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    triggerState,
    ViInt32        searchSource,
    ViReal64    dataLevel,
    ViInt32        clockSource,
    ViReal64    clockLevel,
    ViReal64    holdTime,
    ViReal64    setupTime,
    ViInt32        clockEdge
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, clockEdge, RSSCOPE_VAL_POSITIVE,
                                                      RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 10, "Clock Edge");
    }

    if (rsscope_invalidViReal64Range (instrSession, dataLevel, -10.0, 10.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Data Level");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, searchSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                   RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Search Source");
    }
    
    if (rsscope_invalidViReal64Range (instrSession, holdTime, -99.999E-9, 0.1 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 8, "Hold Time");
    }    
    
    if (rsscope_invalidViReal64Range (instrSession, setupTime, -99.999E-9, 0.1 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 9, "Setup Time");
    }

    if (rsscope_invalidViReal64Range (instrSession, clockLevel, -10.0, 10.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Clock Level");
    }    
    
    if (rsscope_invalidViInt32Range (instrSession, clockSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                  RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "Clock Source");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:DAT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:VAL '%s',%s,%.12lG\n", searchName, searchSource_Arr[searchSource], dataLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:DAT:CSO '%s',%s\n", searchName, searchSource_Arr[clockSource]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:DAT:CLEV '%s',%.12lG\n", searchName, clockLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:DAT:HTIM '%s',%.12lG\n", searchName, holdTime));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:DAT:STIM '%s',%.12lG\n", searchName, setupTime));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:DAT:CEDG '%s',%s\n", searchName, searchPolarity_Arr[clockEdge]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the conditions for the state trigger search. 
/// HIFN  The state search is a qualified edge search. The state search is only 
/// HIFN  available for analog channel sources (Ch1 to Ch4).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR triggerState/Includes the search conditions for the state trigger event type in the 
/// HIPAR triggerState/next search.
/// HIPAR clockSource/Sets the source of the clock signal.
/// HIPAR clockLevel/Sets the trigger level of the clock signal.
/// HIPAR clockEdge/Sets the trigger edge of the clock signal. 
ViStatus _VI_FUNC rsscope_ConfigureStateTriggerSearch (ViSession instrSession,
                                                       ViString searchName,
                                                       ViBoolean triggerState,
                                                       ViInt32 clockSource,
                                                       ViInt32 clockEdge,
                                                       ViReal64 clockLevel)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, clockSource, RSSCOPE_VAL_CLOCK_SOURCE_C1W1,
                                                   RSSCOPE_VAL_CLOCK_SOURCE_C4W1 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Clock Source");
    }
	
	if (rsscope_invalidViInt32Range (instrSession, clockEdge, RSSCOPE_VAL_POSITIVE,
                                                      RSSCOPE_VAL_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Clock Edge");
    }

    if (rsscope_invalidViReal64Range (instrSession, clockLevel, -10.0, 10.0 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Clock Level");
    } 

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:CSO '%s',C%ldW1\n", searchName, clockSource));
    viCheckErr(rsscope_CheckStatus(instrSession));
	viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:CEDG '%s',%s\n", searchName, searchPolarity_Arr[clockEdge]));
    viCheckErr(rsscope_CheckStatus(instrSession)); 
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:CLEV '%s',%.12lG\n", searchName, clockLevel));
    viCheckErr(rsscope_CheckStatus(instrSession));
    												
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  By qualifying a trigger event, you can logically combine the trigger 
/// HIFN  signal with the state of other digital channel signals.
/// HIFN     The instrument triggers if both of the following apply:
/// HIFN     - The basic conditions of the trigger event definition are fulfilled.
/// HIFN     - The logical conditions of the trigger qualification are true.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR channel/Sets the trigger source for state trigger search.
/// HIPAR channelEnabled/Enables the channel to be considered in the state search. You can 
/// HIPAR channelEnabled/enable all channel signals except for the trigger source.
/// HIPAR channelLogic/Defines the logic for the indicated channel. 
ViStatus _VI_FUNC rsscope_ConfigureStateTriggerSearchQualification (ViSession instrSession,
                                                                    ViString searchName,
                                                                    ViInt32 channel,
                                                                    ViBoolean channelEnabled,
                                                                    ViInt32 channelLogic)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL1,
                                                   RSSCOPE_VAL_CHANNEL4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Channel");
    }
	
	if (rsscope_invalidViInt32Range (instrSession, channelLogic, RSSCOPE_VAL_LOGIC_DIRECT,
                                                      RSSCOPE_VAL_LOGIC_NEGATE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Channel Logic");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:%s:ENAB '%s',%s\n", qualifyChannelArr[channel], 
																	searchName, channelEnabled?"ON":"OFF"));
	viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:%s:LOGic '%s',%s\n", qualifyChannelArr[channel], 
																	searchName, qualifyChannelLogicArr[channelLogic]));
    viCheckErr(rsscope_CheckStatus(instrSession)); 
    												
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the logic for the indicated channel combination.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR channelCombination/Sets the trigger source for the state trigger search.
/// HIPAR multichannelLogic/Defines the logic for the indicated channel combination.
ViStatus _VI_FUNC rsscope_ConfigureStateTriggerSearchQualificationMulitchannelLogic (ViSession instrSession,
                                                                                     ViString searchName,
                                                                                     ViInt32 channelCombination,
                                                                                     ViInt32 multichannelLogic)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, channelCombination, RSSCOPE_VAL_CHANNEL1_AND_2,
                                                   RSSCOPE_VAL_CHANNEL_ALL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Channel Combination");
    }
	
	if (rsscope_invalidViInt32Range (instrSession, multichannelLogic, RSSCOPE_VAL_AND,
                                                      RSSCOPE_VAL_NOR ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Multichannel Logic");
    }

	viCheckErr (viPrintf(instrSession, "SEAR:TRIG:STAT:%s:LOGic '%s',%s\n", qualifyMultiChannelArr[channelCombination], 
																	searchName, qualifyMultiChannelLogicArr[multichannelLogic]));
    viCheckErr(rsscope_CheckStatus(instrSession)); 
    												
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines how the range of a pulse width is defined for keeping up the 
/// HIFN  true result of the pattern condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR patternMode/Adds additional time limitation to the pattern definition.
/// HIPAR timeoutCondition/Defines the condition for the timeout.
/// HIPAR timeout/Defines how long the result of the pattern condition must keep the 
/// HIPAR timeout/given state.
/// HIPAR patternWidth/For the ranges "Within" and "Outside", the width defines the center of 
/// HIPAR patternWidth/a range which is defined by the limits "Delta".
/// HIPAR patternDelta/Defines a range around the width value.
/// HIPAR patternCondition/Defines how the range of a pulse width is defined for keeping up the 
/// HIPAR patternCondition/true result of the pattern condition.
/// HIPAR triggerState/Includes the search conditions for the pattern trigger event type in 
/// HIPAR triggerState/the next search. 
ViStatus _VI_FUNC rsscope_ConfigurePatternTriggerSearch (ViSession instrSession,
                                                         ViString searchName,
                                                         ViBoolean triggerState,
                                                         ViInt32 patternMode,
                                                         ViInt32 timeoutCondition,
                                                         ViReal64 timeout,
                                                         ViReal64 patternWidth,
                                                         ViReal64 patternDelta,
                                                         ViInt32 patternCondition)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, patternMode, RSSCOPE_VAL_PATTERN_OFF,
                                                   RSSCOPE_VAL_PATTERN_WIDTH ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Pattern Mode");
    }
	
	if (rsscope_invalidViInt32Range (instrSession, timeoutCondition, RSSCOPE_VAL_PATTERN_TIMEOUT_LOW,
                                                      RSSCOPE_VAL_PATTERN_TIMEOUT_EITHER ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Timeout Condition");
    }
	
	if (rsscope_invalidViReal64Range (instrSession, timeout, 100.0E-12, 864.0) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 6, "Timeout");
    } 

    if (rsscope_invalidViReal64Range (instrSession, patternWidth, 100.0E-12, 864.0) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 7, "Pattern Width");
    }
	
	if (rsscope_invalidViReal64Range (instrSession, patternDelta, 0.0, 432.0) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 8, "Pattern Delta");
    } 
	
	if (rsscope_invalidViInt32Range (instrSession, patternCondition, RSSCOPE_VAL_SHORTER,
                                                      RSSCOPE_VAL_OUTSIDE) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 9, "Pattern Condition");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:STAT '%s',%s\n", searchName, triggerState?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:MODE '%s',%s\n", searchName, patternModeArr[patternMode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
	
	if (patternMode == RSSCOPE_VAL_PATTERN_TIMEOUT)
	{
		viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:TIM:MODE '%s',%s\n", searchName, timeoutConditionArr[timeoutCondition]));
	    viCheckErr(rsscope_CheckStatus(instrSession)); 
	    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:TIM '%s',%.12lG\n", searchName, timeout));
	    viCheckErr(rsscope_CheckStatus(instrSession));
	}
	
	if (patternMode == RSSCOPE_VAL_PATTERN_WIDTH)
	{
		
	    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:WIDT '%s',%.12lG\n", searchName, patternWidth));
	    viCheckErr(rsscope_CheckStatus(instrSession));
		viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:WIDT:DELT '%s',%.12lG\n", searchName, patternDelta));
	    viCheckErr(rsscope_CheckStatus(instrSession));
		viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:WIDT:RANG '%s',%s\n", searchName, patternConditionArr[patternCondition]));
	    viCheckErr(rsscope_CheckStatus(instrSession)); 
	} 
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  By qualifying a trigger event, you can logically combine the trigger 
/// HIFN  signal with the state of other digital channel signals.
/// HIFN     The instrument triggers if both of the following apply:
/// HIFN     - The basic conditions of the trigger event definition are fulfilled.
/// HIFN     - The logical conditions of the trigger qualification are true.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR channel/Sets the trigger source for the pattern trigger search.
/// HIPAR channelEnabled/Enables the channel to be considered in the pattern search. You can 
/// HIPAR channelEnabled/enable all channel signals except for the trigger source.
/// HIPAR channelLogic/Defines the logic for the indicated channel.
ViStatus _VI_FUNC rsscope_ConfigurePatternTriggerSearchQualification (ViSession instrSession,
                                                                      ViString searchName,
                                                                      ViInt32 channel,
                                                                      ViBoolean channelEnabled,
                                                                      ViInt32 channelLogic)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, channel, RSSCOPE_VAL_CHANNEL1,
                                                   RSSCOPE_VAL_CHANNEL4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Channel");
    }
	
	if (rsscope_invalidViInt32Range (instrSession, channelLogic, RSSCOPE_VAL_LOGIC_DIRECT,
                                                      RSSCOPE_VAL_LOGIC_NEGATE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Channel Logic");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:%s:ENAB '%s',%s\n", qualifyChannelArr[channel], 
																	searchName, channelEnabled?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
	viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:%s:LOG '%s',%s\n", qualifyChannelArr[channel], 
																	searchName, qualifyChannelLogicArr[channelLogic]));
    viCheckErr(rsscope_CheckStatus(instrSession)); 
    
    												
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the logic for the indicated channel combination.       
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR channelCombination/Sets the trigger source for the state trigger search.
/// HIPAR multichannelLogic/Defines the logic for the indicated channel combination.
ViStatus _VI_FUNC rsscope_ConfigurePatternTriggerSearchQualificationMulitchannelLogic (ViSession instrSession,
                                                                                       ViString searchName,
                                                                                       ViInt32 channelCombination,
                                                                                       ViInt32 multichannelLogic)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, channelCombination, RSSCOPE_VAL_CHANNEL1_AND_2,
                                                   RSSCOPE_VAL_CHANNEL_ALL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Channel Combination");
    }
	
	if (rsscope_invalidViInt32Range (instrSession, multichannelLogic, RSSCOPE_VAL_AND,
                                                      RSSCOPE_VAL_NOR) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Multichannel Logic");
    }

	viCheckErr (viPrintf(instrSession, "SEAR:TRIG:PATT:%s:LOG '%s',%s\n", qualifyMultiChannelArr[channelCombination], 
																	searchName, qualifyMultiChannelLogicArr[multichannelLogic]));
    viCheckErr(rsscope_CheckStatus(instrSession)); 
    												
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the trigger search condition. It provides 
/// HIFN  logical combinations of the input channels, math or reference 
/// HIFN  waveforms, and supports you in verifying the operation of digital 
/// HIFN  logic.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR searchLogic/Returns regular expression defining the logic search.
ViStatus _VI_FUNC rsscope_QueryTriggerSearchCondition(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32 bufferSize,
    ViChar      searchLogic[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   *p2data  = NULL;
    ViUInt32     count = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:COND? '%s'\n", searchName));
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2data, &count));
    memcpy (searchLogic, p2data, ((ViUInt32) bufferSize<count) ? (ViUInt32) bufferSize : count);

Error:
    if (p2data) free (p2data);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function performs the search only on the defined gate area of the 
/// HIFN  source waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR useGate/Enables gating.
ViStatus _VI_FUNC rsscope_ConfigureSearchGateState(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    useGate
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "SEAR:GATE:STAT '%s',%s\n", searchName, useGate?"ON":"OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether the gate area is displayed in the 
/// HIFN  source diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR showGate/Indicates the gate area in the source diagram.
ViStatus _VI_FUNC rsscope_ConfigureSearchGateShow(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    showGate
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "SEAR:GATE:SHOW '%s',%s\n", searchName, showGate?"ON":"OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether the gate area is defined identically 
/// HIFN  to the zoom area for the selected active zoom diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR zoomCoupling/If enabled, the gate area is defined identically to the zoom area for 
/// HIPAR zoomCoupling/the zoom diagram.
/// HIPAR zoomDiagram/This control is reserved for future use.
ViStatus _VI_FUNC rsscope_ConfigureSearchGateDefinitionZoom(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    zoomCoupling,
    ViInt32        zoomDiagram
)
{
    ViStatus    error = VI_SUCCESS;
    zoomDiagram;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "SEAR:GATE:ZCO '%s',%s\n", searchName, zoomCoupling?"ON":"OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the start and end values for the gate.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR mode/Defines whether the gate settings are configured using absolute or 
/// HIPAR mode/relative values.
/// HIPAR start/Defines the starting value for the gate.
/// HIPAR stop/Defines the ending value for the gate.
ViStatus _VI_FUNC rsscope_ConfigureSearchGateDefinitionStartStop(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Mode");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:GATE:MODE '%s',%s\n", searchName, searchMode_Arr[mode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:GATE:%s:STAR '%s',%.12lG\n", searchMode_Arr[mode], searchName, start));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:GATE:%s:STOP '%s',%.12lG\n", searchMode_Arr[mode], searchName, stop));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the search result table.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR showResultTable/Displays or hides the search result table.
/// HIPAR sortMode/Sorts the search result table by x-value position or value of the 
/// HIPAR sortMode/result.
/// HIPAR sortAscending/If enabled, the results are listed in asscending order, i.e. the 
/// HIPAR sortAscending/smallest value at the top.
/// HIPAR maxResultCount/Defines the maximum number of entries in the search result table.
ViStatus _VI_FUNC rsscope_ConfigureSearchResultTable(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    showResultTable,
    ViInt32        sortMode,
    ViBoolean    sortAscending,
    ViInt32        maxResultCount
)
{
    ViStatus    error = VI_SUCCESS;
    ViString sortMode_Arr[] = {"POS", "VAL"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, sortMode, RSSCOPE_VAL_SORT_MODE_POSITION, RSSCOPE_VAL_SORT_MODE_VALUE ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Sort Mode");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:RES:SHOW '%s',%s\n", searchName, showResultTable?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RES:SORT:MODE '%s',%s\n", searchName, sortMode_Arr[sortMode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RES:SORT:ASC '%s',%s\n", searchName, sortAscending?"ON":"OFF"));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RES:LIM '%s',%ld\n", searchName, maxResultCount));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the zoom window display state.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR showSearchZoomWindows/If enabled, a zoom window is displayed for the currently selected 
/// HIPAR showSearchZoomWindows/search result. The zoom area is indicated in the diagram that displays 
/// HIPAR showSearchZoomWindows/the source waveform of the search.
ViStatus _VI_FUNC rsscope_ConfigureSearchZoomWindowState(
    ViSession    instrSession,
    ViString    searchName,
    ViBoolean    showSearchZoomWindows
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (viPrintf(instrSession, "SEAR:RESD:SHOW '%s',%s\n", searchName, showSearchZoomWindows?"ON":"OFF"));

    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configure the horizontal settings of the search zoom 
/// HIFN  window.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR horizonatalMode/Defines whether absolute or relative values are used to specify the 
/// HIPAR horizonatalMode/x-axis values.
/// HIPAR position/Defines the x-value of the centerpoint of the zoom area.
/// HIPAR range/Defines the width of the zoom area.
ViStatus _VI_FUNC rsscope_ConfigureSearchZoomWindowXAxis(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        horizonatalMode,
    ViReal64    position,
    ViReal64    range
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, horizonatalMode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Horizonatal Mode");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:RESD:HORZ:MODE '%s',%s\n", searchName, searchMode_Arr[horizonatalMode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RESD:HORZ:%s:POS '%s',%.12lG\n", searchMode_Arr[horizonatalMode], searchName, position));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RESD:HORZ:%s:SPAN '%s',%.12lG\n", searchMode_Arr[horizonatalMode], searchName, range));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configure the vertical settings of the search zoom 
/// HIFN  window.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR verticalMode/Defines whether absolute or relative values are used to specify the 
/// HIPAR verticalMode/y-axis values.
/// HIPAR position/Defines the y-value of the centerpoint of the zoom area.
/// HIPAR range/Defines the width of the zoom area.
ViStatus _VI_FUNC rsscope_ConfigureSearchZoomWindowYAxis(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        verticalMode,
    ViReal64    position,
    ViReal64    range
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, verticalMode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Vertical Mode");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:RESD:VERT:MODE '%s',%s\n", searchName, searchMode_Arr[verticalMode]));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RESD:VERT:%s:POS '%s',%.12lG\n", searchMode_Arr[verticalMode], searchName, position));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:RESD:VERT:%s:SPAN '%s',%.12lG\n", searchMode_Arr[verticalMode], searchName, range));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the noise rejection by setting a hysteresis 
/// HIFN  in order to avoid finding trigger events caused
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR searchName/Specifies search definition.
/// HIPAR searchConditionSource/Selects the source of the search.
/// HIPAR useNoiseReject/If enabled, the noise reject settings for the waveform are considered 
/// HIPAR useNoiseReject/for the search.
/// HIPAR hysteresis/Defines a range in absolute or relative values around the trigger 
/// HIPAR hysteresis/level. If the signal jitters inside this range and crosses the trigger 
/// HIPAR hysteresis/level, no trigger event is detected.
/// HIPAR hysteresisMode/Defines whether absolute values or relative values to the vertical 
/// HIPAR hysteresisMode/scaling are used as a hysteresis for noise rejection.
ViStatus _VI_FUNC rsscope_ConfigureSearchNoiseReject(
    ViSession    instrSession,
    ViString    searchName,
    ViInt32        searchConditionSource,
    ViBoolean    useNoiseReject,
    ViInt32        hysteresisMode,
    ViReal64    hysteresis
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, searchConditionSource, RSSCOPE_VAL_MEASUREMENT_SOURCE_NONE,
                                                               RSSCOPE_VAL_MEASUREMENT_SOURCE_R4 ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Search Condition Source");
    }    

    if (rsscope_invalidViInt32Range (instrSession, hysteresisMode, RSSCOPE_VAL_ABS, RSSCOPE_VAL_REL ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 5, "Hysteresis Mode");
    }

    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:NOIS:STAT '%s',%s,%s\n", searchName,
                                                                               searchSource_Arr[searchConditionSource],
                                                                               useNoiseReject?"ON":"OFF"
                                                                               ));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:NOIS:MODE '%s',%s,%s\n", searchName,
                                                                               searchSource_Arr[searchConditionSource],
                                                                               searchMode_Arr[hysteresisMode]
                                                                               ));
    viCheckErr(rsscope_CheckStatus(instrSession));
    viCheckErr (viPrintf(instrSession, "SEAR:TRIG:LEV:NOIS:%s '%s',%s,%.12lG\n", searchMode_Arr[hysteresisMode],
                                                                                 searchName,
                                                                                 searchSource_Arr[searchConditionSource],
                                                                                 hysteresis
                                                                                 ));
    viCheckErr(rsscope_CheckStatus(instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function enables the decoding of the selected bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR state/Enables the decoding of the selected bus.
ViStatus _VI_FUNC rsscope_ConfigureDecodeState(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViBoolean    state
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_STATE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_STATE, 
                                                 state
                                                 ), 3, "State");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures a label to be displayed with the bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR busLabel/Defines a label to be displayed with the bus.
ViStatus _VI_FUNC rsscope_ConfigureBusLabel(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViString    busLabel
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LABEL,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_LABEL, 
                                                busLabel
                                                ), 3, "Bus Label");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function opens a table with decoded data of the serial signal. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR showTable/Opens a table with decoded data of the serial signal. 
ViStatus _VI_FUNC rsscope_ShowDecodeTable(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViBoolean    showTable
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_DISPLAY_RESULT_TABLE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_DISPLAY_RESULT_TABLE, 
                                                 showTable
                                                 ), 3, "Show Table");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function activates the label list to be used for decoding. The 
/// HIFN  "Label" appear in the "Decode results" table and in the frame captions 
/// HIFN  of the decoded signal.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR state/Activates the label list to be used for decoding. The "Label" appear 
/// HIPAR state/in the "Decode results" table and in the frame captions of the decoded 
/// HIPAR state/signal.
ViStatus _VI_FUNC rsscope_ConfigureLabelList (ViSession instrSession,
                                              ViInt32 serialBus, ViBoolean state)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
		viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LABEL_LIST,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LABEL_LIST, 
                                                 state), 3, "State");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures source waveform of the data line (SDA) and 
/// HIFN  clock line (SCL).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR line/This control select I2C line.
/// HIPAR waveformSource/Selects the source of the waveform.
ViStatus _VI_FUNC rsscope_ConfigureI2CSource(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        line,
    ViInt32        waveformSource
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap_bus[5] = "";
    ViChar        rep_cap_line[5] = "";
    ViChar        rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, line, RSSCOPE_VAL_I2C_SCL, RSSCOPE_VAL_I2C_SDA) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Line");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_SOURCE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_SOURCE,
                                                 "I2CLine",
                                                 line,
                                                 5,
                                                 rep_cap_line), 3, "Line"); 
    
    strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_line);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_SOURCE,
                                               waveformSource
                                               ), 4, "Waveform Source");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures threshold value for digitization of analog 
/// HIFN  signals.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs the threshold voltage for various signal 
/// HIPAR preset/technologies from a list.
/// HIPAR SCLThreshold/Sets user-defined value of the threshold voltage.
/// HIPAR SDAThreshold/Sets user-defined value of the threshold voltage.
ViStatus _VI_FUNC rsscope_ConfigureI2CThreshold(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        preset,
    ViReal64     SCLThreshold,
    ViReal64     SDAThreshold
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";
    ViChar    rep_cap_man[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TECHNOLOGY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_TECHNOLOGY,
                                               preset
                                               ), 3, "Preset");
    
    if (preset == RSSCOPE_VAL_MAN)
    {
        
        strcpy(rep_cap_man, rep_cap);
        strcat(rep_cap_man, ",SCL");
            
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_man,
                                                RSSCOPE_ATTR_PROTOCOL_I2C_THRESHOLD,
                                                SCLThreshold
                                                ), 4, "SCL Threshold");
        
        strcpy(rep_cap_man, rep_cap);
        strcat(rep_cap_man, ",SDA");;
        
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_man,
                                                RSSCOPE_ATTR_PROTOCOL_I2C_THRESHOLD,
                                                SDAThreshold
                                                ), 5, "SDA Threshold");
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
} 

/// HIFN This function defines if the R/W bit of a 7-bit address is considered 
/// HIFN separately or as part of the address.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR RWBit/This control defines if the R/W bit of a 7-bit address is  
/// HIPAR RWBit/considered separately or as part of the address.
ViStatus _VI_FUNC rsscope_ConfigureI2CRWBit (ViSession instrSession,
                                             ViInt32 serialBus, ViInt32 RWBit)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
		viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_RW_BIT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_RW_BIT, 
                                                 RWBit), 3, "RW Bit");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function selects the trigger type for I2C analysis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR type/This control select trigger type.
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerType(
    ViSession    instrSession,
    ViInt32        trigger,
    ViInt32        type
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_MODE,
                                               type
                                               ), 3, "Type");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the state of the indicated ADOR address in 
/// HIFN  the "address OR" trigger condition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR orSlot/This control select index of the address in an "address OR" condition 
/// HIPAR orSlot/(OR slot).
/// HIPAR orSlotState/If set to "On" the indicated ADOR address is included in the "address 
/// HIPAR orSlotState/OR" trigger condition.
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerAddressORState(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     orSlot,
    ViBoolean   orSlotState
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[20]="";
    ViChar      rep_cap_slot[5]="";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, orSlot, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "OR Slot");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_STATE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_STATE,
                                                 "ORSlot",
                                                 orSlot - 1,
                                                 5,
                                                 rep_cap_slot), 3, "OR Slot");
    
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_slot);

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_STATE,
                                                 orSlotState
                                                 ), 4, "OR Slot State");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures triggering on one to four address conditions. 
/// HIFN  Each condition requires an exact address.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR orSlot/This control select index of the address in an "address OR" condition 
/// HIPAR orSlot/(OR slot).
/// HIPAR addressType/This control select address length.
/// HIPAR rwBitAddress/Sets the R/W bit of the indicated ADOR address in the "address OR" 
/// HIPAR rwBitAddress/trigger condition.
/// HIPAR address/Defines the address pattern of the address.
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerAddressOR(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     orSlot,
    ViInt32     addressType,
    ViInt32     rwBitAddress,
    ViString    address
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[20]="";
    ViChar      rep_cap_slot[5]="";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, orSlot, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "OR Slot");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_TYPE,
                                                 "ORSlot",
                                                 orSlot - 1,
                                                 5,
                                                 rep_cap_slot), 3, "OR Slot");
    
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_slot);

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_TYPE,
                                                 addressType
                                                 ), 4, "Address Type");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR_ACCESS_BIT,
                                                 rwBitAddress
                                                 ), 5, "RW Bit Address");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_OR,
                                                 address
                                                 ), 6, "Address");
                                                 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the data trigger conditions.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set a specific address or an address range.
/// HIPAR addressMin/Sets a data pattern, or sets the the start value of a data
/// HIPAR addressMin/pattern range. Enter the pattern MSB first and with Big endian byte order.
/// HIPAR addressMax/Sets the the end value of an data range if "Condition" "In  range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerData(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     condition,
    ViString    addressMin,
    ViString    addressMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_trig[20]="";
    ViChar      rep_cap[20]="";
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_DATA_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
    
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_trig,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_DATA_CONDITION,
                                                 condition
                                                 ), 3, "Condition");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Min");
	viCheckParm (rsscope_SetAttributeViString(instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_PATTERN_MIN_MAX,
                                                 addressMin), 3, "Address Min");
												 
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Max");
	viCheckParm (rsscope_SetAttributeViString(instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_PATTERN_MIN_MAX,
                                                 addressMax), 3, "Address Max");   
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function sets the position of the first byte of data bit pattern within the payload segment.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set a specific position or position range.
/// HIPAR indexMin/Sets the number of data bytes to be skipped after start of the payload segment.
/// HIPAR indexMax/Defines the last byte of interest,if "Condition" is "Range". 
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerDataPosition (ViSession instrSession,
                                                           ViInt32 trigger,
                                                           ViInt32 condition,
                                                           ViInt32 indexMin,
                                                           ViInt32 indexMax)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_trig[20]="";
    ViChar      rep_cap[20]="";
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_POSITION_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
    
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_trig,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_POSITION_CONDITION,
                                                 condition
                                                 ), 3, "Condition");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Min");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_POSITION_MIN_MAX,
                                                 indexMin), 4, "Index Min");
												 
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Max");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_POSITION_MIN_MAX,
                                                 indexMax), 5, "Index Max");   
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures which missing acknowledge bits is detected if 
/// HIFN  the trigger type is set to "Missing Ack".
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR addressNack/Triggers if the address acknowledge bit is missing.
/// HIPAR dataWriteNack/Triggers if a data acknowledge bit is missing
/// HIPAR dataReadNack/Triggers on the end of the read process when the master reads data 
/// HIPAR dataReadNack/from the slave.
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerNoAck(
    ViSession    instrSession,
    ViInt32      trigger,
    ViBoolean    addressNack,
    ViBoolean    dataWriteNack,
    ViBoolean    dataReadNack
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_trig[10] = "";
    ViChar      rep_cap[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_NO_ACK,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger"); 
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Address");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_NO_ACK,
                                                 addressNack
                                                 ), 3, "Address Nack");
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Write");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_NO_ACK,
                                                 dataWriteNack
                                                 ), 4, "Data Write Nack");
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Read");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_NO_ACK,
                                                 dataReadNack
                                                 ), 5, "Data Read Nack");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the address trigger conditions.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR addressType/This control select address length.
/// HIPAR RWBitAddress/This control select trigger type.
/// HIPAR addressMin/Sets slave address, or the the start value of an address range. Enter 
/// HIPAR addressMin/values in binary format, use the following characters: 1; 0; or X (any 
/// HIPAR addressMin/bit).
/// HIPAR condition/This control is reserved for future use.
/// HIPAR addressMax/This control is reserved for future use.
ViStatus _VI_FUNC rsscope_ConfigureI2CTriggerAddress(
    ViSession      instrSession,
    ViInt32        trigger,
    ViInt32        addressType,
    ViInt32        RWBitAddress,
    ViInt32        condition,                                 
    ViString       addressMin,
    ViString       addressMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_TYPE,
                                               addressType
                                               ), 3, "Address Type");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ACCESS_BIT,
                                               RWBitAddress
                                               ), 4, "RW Bit Address");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_CONDITION,
                                               condition
                                               ), 5, "Condition");
    
    viCheckParm (rsscope_SetAttributeViString(instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_MIN,
                                                addressMin
                                                ), 6, "Address Min");
    
    if (condition >= RSSCOPE_VAL_COND_IN) 
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_MAX,
                                                    addressMax
                                                    ), 7, "Address Max");
    }
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the number of decoded frames.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Number of decoded frames.
ViStatus _VI_FUNC rsscope_QueryI2CFrameCount(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32*     count
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_FRAME_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus"); 
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_I2C_FRAME_COUNT,
                                               count
                                               ), 3, "Count");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the overall state of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR status/The overall state of the frame.
/// HIPAR frameStart/Time of frame start
/// HIPAR frameStop/Time of frame end.
/// HIPAR addressType/This control show address length.
/// HIPAR address/Value of the frame address.
/// HIPAR RWBit/Value of the R/W bit.
/// HIPAR ackBit/Value of the address acknowledge bit.
ViStatus _VI_FUNC rsscope_QueryI2CFrameStatus(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViInt32*     status,
    ViReal64*    frameStart,
    ViReal64*    frameStop,
    ViInt32*     addressType,
    ViInt32*     address,
    ViInt32*     RWBit,
    ViInt32*     ackBit
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:STAT?", "%s", serialBus, frame, buffer));
    *status = rsscope_StringIndex (protocolFrameStatus_Arr, buffer);
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:STAR?", "%le", serialBus, frame, frameStart));
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:STOP?", "%le", serialBus, frame, frameStop));
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:AMOD?", "%s", serialBus, frame, buffer));
    *addressType = rsscope_StringIndex (protocolI2CAddressType_Arr, buffer);
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:ADDR?", "%ld", serialBus, frame, address));
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:ACC?", "%s", serialBus, frame, buffer));
    *RWBit = rsscope_StringIndex (protocolI2CRWBit_Arr, buffer);
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:AACC?", "%s", serialBus, frame, buffer));
    *ackBit = rsscope_StringIndex (protocolI2CAckBit_Arr, buffer);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the start time of the access ack bit.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR accessBitStart/Time of access bit start.
ViStatus _VI_FUNC rsscope_QueryI2CFrameAccessBitStart(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViReal64*    accessBitStart                     
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:RWBS?", "%le", serialBus, frame, accessBitStart));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the slave address of the indicated frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR address/Value of the frame slave address.
ViStatus _VI_FUNC rsscope_QueryI2CFrameSlaveAddress(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViInt32     *address
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:ADEV?", "%ld", serialBus, frame, address));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the start time of the address for the indicated frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR addressStart/Time of address start.
ViStatus _VI_FUNC rsscope_QueryI2CFrameAddressAckBitStartTime(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViReal64*    addressStart
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:AST?", "%le", serialBus, frame, addressStart));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the start time of the address acknowledge bit.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR ackBitStart/Time of ack bit start.
ViStatus _VI_FUNC rsscope_QueryI2CFrameAddressAckBitStart(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViReal64*    ackBitStart      
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:ADBS?", "%le", serialBus, frame, ackBitStart));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function checks if address is complete.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR complete/Status of address.
ViStatus _VI_FUNC rsscope_QueryI2CFrameAddressComplete(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViBoolean*   complete
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:ACOM?", "%s", serialBus, frame, buffer));
    if (strcmp(buffer, "ON") == 0) 
        *complete = VI_TRUE;
    else
        *complete = VI_FALSE;

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the number of bytes in the specified frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR length/Returns the number of bytes in the specified frame
ViStatus _VI_FUNC rsscope_QueryI2CFrameLength(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32*    length
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:BCO?", "%ld", serialBus, frame, length));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the data value of the specified byte.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR byteNumber/This control selects the Byte.
/// HIPAR data/Value of the specified byte
/// HIPAR ackBit/Value of the data acknowledge bit.
ViStatus _VI_FUNC rsscope_QueryI2CFrameData(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViInt32      byteNumber,
    ViInt32*     data,
    ViInt32*     ackBit
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
                                                        
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:BYTE%ld:VAL?", "%ld", serialBus, frame, byteNumber, data));
    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:BYTE%ld:ACC?", "%s", serialBus, frame, byteNumber, buffer));
    *ackBit = rsscope_StringIndex(protocolI2CAckBit_Arr, buffer);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the start time of the specified data byte.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR byteNumber/This control selects the Byte.
/// HIPAR startTime/Start time of the byte.
ViStatus _VI_FUNC rsscope_QueryI2CFrameDataByteStart(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViInt32      byteNumber,
    ViReal64*    startTime
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:BYTE%ld:STAR?", "%le", serialBus, frame, byteNumber, startTime ));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function checks if data byte is complete.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR byteNumber/This control selects the Byte.
/// HIPAR complete/Start time of the byte.
ViStatus _VI_FUNC rsscope_QueryI2CFrameDataComplete(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViInt32      byteNumber,
    ViBoolean*   complete
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:I2C:FRAM%ld:BYTE%ld:COMP?", "%s", serialBus, frame, byteNumber, buffer));
    
    if (strcmp(buffer, "ON") == 0) 
        *complete = VI_TRUE;
    else
        *complete = VI_FALSE;

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the all data words of the specified frame in comma-separated 
/// HIFN  list of decimal values of the data bytes.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR arraySize/Pass the number of values allocated for Data result array.
/// HIPAR data/Data words of the specified frame.
/// HIPAR returnedValues/Returns number of results returned from the instrument.
ViStatus _VI_FUNC rsscope_QueryI2CFrameAllData (ViSession instrSession,
                                                ViInt32 serialBus, 
                                                ViInt32 frame,
                                                ViInt32 arraySize,
                                                ViInt32 data[],
                                                ViInt32 *returnedValues)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar      *p2buf  = NULL;
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt;
    ViInt32     i=0;
    ViInt32     value_count = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:I2C:FRAM%d:DATA?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    
    value_count = atoi (p2buf);
    
    arraySize = (arraySize < value_count) ? arraySize : value_count;
    
    p2buf = strtok(NULL, ",");
    
    while (p2buf && (i < arraySize))
    {                  
        data[i] = atol(p2buf);
        p2buf = strtok(NULL, ",");
        i++;
    }
    *returnedValues = i;
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
	if (extBuf) free (extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the symbolic label of the specified frame if the 
/// HIFN  label list is enabled.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Translation'.
/// HIPAR label/Returns the symbolic label of the specified frame if the label list is 
/// HIPAR label/enabled.
ViStatus _VI_FUNC rsscope_QueryI2CFrameLabel (ViSession instrSession,
                                              ViInt32 serialBus, ViInt32 frame,
                                              ViInt32 bufferSize,
                                              ViChar label[])
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%ld:I2C:FRAM%d:SYMB?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt));
	
	if (bufferSize < (ViInt32) ret_cnt) ret_cnt = (ViUInt32) bufferSize;
		
	strncpy (label, extBuf, ret_cnt);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
	if (extBuf) free (extBuf);
    Rs_UnlockSession (instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures input channel of the selected line.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR line/This control select configured SPI line.
/// HIPAR waveformSource/Selects the source of the waveform.
ViStatus _VI_FUNC rsscope_ConfigureSPISource(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        line,
    ViInt32        waveformSource
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap_bus[5] = "";
    ViChar        rep_cap_line[12] = "";
    ViChar        rep_cap[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, line, RSSCOPE_VAL_SPI_SCLK, RSSCOPE_VAL_SPI_MOSI) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Line");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_SOURCE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_SOURCE,
                                                 "SPILine",
                                                 line,
                                                 12,
                                                 rep_cap_line), 3, "Line");
                                                 
    strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_line);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_SOURCE,
                                               waveformSource
                                               ), 4, "Waveform Source");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures he threshold value for digitization of 
/// HIFN  signals for each line. If the signal value on the line is higher than 
/// HIFN  the threshold, the signal state is high (1 or true for the boolean 
/// HIFN  logic). Otherwise, the signal state is considered low (0 or false) if 
/// HIFN  the signal value is below the threshold.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs the threshold voltage for various signal 
/// HIPAR preset/technologies from a list.
/// HIPAR clockThreshold/Sets user-defined value of the threshold voltage.
/// HIPAR SSThreshold/Sets user-defined value of the threshold voltage.
/// HIPAR misoThreshold/Sets user-defined value of the threshold voltage.
/// HIPAR mosiThreshold/Sets user-defined value of the threshold voltage.
ViStatus _VI_FUNC rsscope_ConfigureSPIThreshold(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        preset,
    ViReal64    clockThreshold,
    ViReal64    SSThreshold,
    ViReal64    misoThreshold,
    ViReal64    mosiThreshold
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[20] = "";
    ViChar        rep_cap_bus[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_TECHNOLOGY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TECHNOLOGY,
                                               preset
                                               ), 3, "Preset");
    
    if (preset == RSSCOPE_VAL_MAN)
    {
        strcpy(rep_cap, rep_cap_bus);
        strcat(rep_cap, ",Clock");
    
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_SPI_THRESHOLD,
                                                clockThreshold
                                                ), 4, "Clock Threshold");
        
        strcpy(rep_cap, rep_cap_bus);
        strcat(rep_cap, ",SlaveSelect");
        
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_SPI_THRESHOLD,
                                                SSThreshold
                                                ), 5, "SS Threshold");
        
        strcpy(rep_cap, rep_cap_bus);
        strcat(rep_cap, ",MISO");
        
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_SPI_THRESHOLD,
                                                misoThreshold
                                                ), 6, "MISOThreshold");
        
        strcpy(rep_cap, rep_cap_bus);
        strcat(rep_cap, ",MOSI");
        
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_SPI_THRESHOLD,
                                                mosiThreshold
                                                ), 7, "MOSIThreshold");
    }

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether transmitted data or the slave select 
/// HIFN  signal is high active (high = 1) or low active (low = 1).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR line/This control select configured SPI line.
/// HIPAR polarity/Selects line polarity.
ViStatus _VI_FUNC rsscope_ConfigureSPIPolarity(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        line,
    ViInt32        polarity
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap_bus[5] = "";
    ViChar        rep_cap_line[12] = "";
    ViChar        rep_cap[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, line, RSSCOPE_VAL_SPI_SSEL, RSSCOPE_VAL_SPI_MOSI) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Line");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_POLARITY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_POLARITY,
                                                 "SPILine",
                                                 line,
                                                 12,
                                                 rep_cap_line), 3, "Line");
    
    strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_line);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_POLARITY,
                                               polarity
                                               ), 4, "Polarity");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures bit count and it's order in message. The 
/// HIFN  display of the decoded signal considers this setting.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR bitOrder/Select if the data of the messages starts with msb or lsb.
/// HIPAR wordLength/Sets the number of bits in a word.
ViStatus _VI_FUNC rsscope_ConfigureSPIWord(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        bitOrder,
    ViInt32        wordLength
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";                                    

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_BIT_ORDER,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_BIT_ORDER,
                                               bitOrder
                                               ), 3, "Bit Order");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_WORD_LENGTH,
                                               wordLength
                                               ), 4, "Word Length");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the start of a frame. A frame contains a 
/// HIFN  number of successive words, at least one word.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frameCondition/Select the start of a frame.
/// HIPAR clockTimeout/Sets a timeout on the clock line SCLK as limiter between two frames.
ViStatus _VI_FUNC rsscope_ConfigureSPIFrameStart(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frameCondition,
    ViReal64    clockTimeout
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_FRAME_START_CONDITION,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_FRAME_START_CONDITION,
                                               frameCondition
                                               ), 3, "Frame Condition");
    
    if (frameCondition == RSSCOPE_VAL_SPI_FRAME_START_CLK)
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_FRAME_START_TIMEOUT,
                                               clockTimeout
                                               ), 4, "Clock Timeout");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the trigger type for SPI analysis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR type/This control select trigger type.
ViStatus _VI_FUNC rsscope_ConfigureSPITriggerType(
    ViSession    instrSession,
    ViInt32        type
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_MODE,
                                               type
                                               ), 3, "Type");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configure MOSI and MISO trigger conditions.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function. The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Selects the operator for the MISO and MOSI pattern.
/// HIPAR mosiPattern/Specifies the data pattern to be found on the MOSI line. Enter bin 
/// HIPAR mosiPattern/words in msb first bit order.
/// HIPAR misoPattern/Specifies the data pattern to be found on the MISO line. Enter bin 
/// HIPAR misoPattern/words in msb first bit order.
ViStatus _VI_FUNC rsscope_ConfigureSPITriggerData(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     condition,
    ViString    mosiPattern,
    ViString    misoPattern
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";
    ViChar      rep_cap_line[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    if (rsscope_invalidViInt32Range (instrSession, condition, RSSCOPE_VAL_COND_NQ, RSSCOPE_VAL_COND_EQ) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Condition");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_I2C_TRIGGER_ADDRESS_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_CONDITION,
                                               condition
                                               ), 3, "Condition");  
    
    strcpy(rep_cap_line, rep_cap);
    strcat(rep_cap_line, ",MOSI");
    viCheckParm (rsscope_SetAttributeViString (instrSession, "MOSI",
                                                RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_PATTERN,
                                                mosiPattern
                                                ), 4, "MOSI Pattern");
    
    strcpy(rep_cap_line, rep_cap);
    strcat(rep_cap_line, ",MISO");
    viCheckParm (rsscope_SetAttributeViString (instrSession, "MISO",
                                                RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_PATTERN,
                                                misoPattern
                                                ), 5, "MISO Pattern");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configure MOSI and MISO trigger conditions.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Reserved for future use.
/// HIPAR searchMode/Selects how the specified data pattern is searched:
/// HIPAR indexMin/Sets the number of bits or words before the first word of interest.
/// HIPAR indexMax/Reserved for future use.
ViStatus _VI_FUNC rsscope_ConfigureSPITriggerDataPosition(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     condition,
    ViInt32     searchMode,
    ViInt32     indexMin,
    ViInt32     indexMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";
    indexMax;
    condition;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_DATA_ALIGNMENT,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
    
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_POSITION_CONDITION,
                                               condition), 3, "Condition");
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_DATA_ALIGNMENT,
                                               searchMode), 4, "Search Mode");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_DATA_INDEX_MIN,
                                               indexMin), 5, "Index Min"); 
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_TRIGGER_DATA_INDEX_MAX,
                                               indexMax), 6, "Index Max");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Queries the number of decoded frames.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Number of decoded frames.
ViStatus _VI_FUNC rsscope_QuerySPIFrameCount(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_SPI_FRAME_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_SPI_FRAME_COUNT,
                                               count
                                               ), 3, "Count");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN Queries the number of words in frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR count/Number of words.
ViStatus _VI_FUNC rsscope_QuerySPIWordCount (
    ViSession instrSession,
    ViInt32   serialBus, 
    ViInt32   frame,
    ViInt32  *count)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:WCO?", "%ld", serialBus, frame, count));
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the overall state of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR frameStart/Returns the start time of the specified frame.
/// HIPAR frameStop/Returns the end time of the specified frame.
/// HIPAR status/The overall state of the frame.
ViStatus _VI_FUNC rsscope_QuerySPIFrameStatus(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViReal64*    frameStart,
    ViReal64*    frameStop,
    ViInt32*     status
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:STAR?", "%le", serialBus, frame, frameStart));
    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:STOP?", "%le", serialBus, frame, frameStop));
    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:STAT?", "%s", serialBus, frame, frameStop));
    *status = rsscope_StringIndex( protocolFrameStatus_Arr, buffer);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the data value of the specified word.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR word/This control selects the word.
/// HIPAR valueStart/Start time of the data word.
/// HIPAR valueStop/Stop time of the data word.
/// HIPAR mosiValue/Returns the data value of the specified word on the MOSI line.
/// HIPAR misoValue/Returns the data value of the specified word on the MISO line.
ViStatus _VI_FUNC rsscope_QuerySPIFrameData(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      frame,
    ViInt32      word,
    ViReal64*    valueStart,
    ViReal64*    valueStop,
    ViInt32*     mosiValue,
    ViInt32*     misoValue
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));

    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:WORD%ld:STAR?", "%le", serialBus, frame, word, valueStart));
    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:WORD%ld:STOP?", "%le", serialBus, frame, word, valueStop));
    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:WORD%ld:MOSI?", "%ld", serialBus, frame, word, mosiValue));
    viCheckErr (viQueryf (instrSession, "BUS%ld:SPI:FRAM%ld:WORD%ld:MISO?", "%ld", serialBus, frame, word, misoValue));
    
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the all data words of the specified frame in comma-separated 
/// HIFN  list of decimal values of the data bytes.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR arraySize/Pass the number of values allocated for Data result array.
/// HIPAR data/Data words of the specified frame.
/// HIPAR returnedValues/Returns number of results returned from the instrument.
ViStatus _VI_FUNC rsscope_QuerySPIFrameAllData (ViSession instrSession,
                                                ViInt32 serialBus, 
                                                ViInt32 frame,
                                                ViInt32 arraySize,
                                                ViInt32 data[],
                                                ViInt32 *returnedValues)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt;
    ViInt32     i=0;
    ViInt32     value_count = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K1") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:SPI:FRAM%d:DATA?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    
    value_count = atoi (p2buf);
    
    arraySize = (arraySize < value_count) ? arraySize : value_count;
    
    p2buf = strtok(NULL, ",");
    
    while (p2buf && (i < arraySize))
    {                  
        data[i] = atol(p2buf);
        p2buf = strtok(NULL, ",");
        i++;
    }
    *returnedValues = i;
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the input channels for the transmitter and 
/// HIFN  receiver signals. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR line/This control select UART line.
/// HIPAR waveformSource/Selects the source of the waveform.
ViStatus _VI_FUNC rsscope_ConfigureUARTSource(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        line,
    ViInt32        waveformSource
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap_bus[5] = "";
    ViChar        rep_cap_line[5] = "";
    ViChar        rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, line, RSSCOPE_VAL_UART_RX, RSSCOPE_VAL_UART_TX) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Line");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_SOURCE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_SOURCE,
                                                 "UARTLine",
                                                 line,
                                                 5,
                                                 rep_cap_line), 3, "Line");
    
    strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_line);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_SOURCE,
                                               waveformSource
                                               ), 4, "Waveform Source");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures threshold value for digitization of analog 
/// HIFN  signals.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs the threshold voltage for various signal 
/// HIPAR preset/technologies from a list.
/// HIPAR rxThreshold/Sets user-defined value of the threshold voltage.
/// HIPAR txThreshold/Sets user-defined value of the threshold voltage.
ViStatus _VI_FUNC rsscope_ConfigureUARTThreshold(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        preset,
    ViReal64    rxThreshold,
    ViReal64    txThreshold
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";
    ViChar        rep_cap_line[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_TECHNOLOGY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TECHNOLOGY,
                                               preset
                                               ), 3, "Preset");
    
    if (preset == RSSCOPE_VAL_MAN)
    {
        strcpy(rep_cap_line, rep_cap);
        strcat(rep_cap_line, ",Rx");
    
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_line,
                                                    RSSCOPE_ATTR_PROTOCOL_UART_THRESHOLD,
                                                    rxThreshold
                                                    ), 4, "Rx Threshold");
    
        strcpy(rep_cap_line, rep_cap);
        strcat(rep_cap_line, ",Tx");
    
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap_line,
                                                    RSSCOPE_ATTR_PROTOCOL_UART_THRESHOLD,
                                                    txThreshold
                                                    ), 5, "Tx Threshold");
    }
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures UART.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR bitRate/Sets the number of transmitted bits per second.
/// HIPAR stopbits/Selects the number of stop bits.
/// HIPAR databits/Sets the number of data bits in a message.
/// HIPAR parity/Selects the optional parity bit that is used for error detection.
/// HIPAR polarity/Sets if the transmitted data on the bus is high (high = 1) or low (low 
/// HIPAR polarity/= 1) active.
ViStatus _VI_FUNC rsscope_ConfigureUART(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32        bitRate,
    ViInt32        stopbits,
    ViInt32        databits,
    ViInt32        parity,
    ViInt32        polarity
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_BIT_RATE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_BIT_RATE,
                                               bitRate
                                               ), 3, "Bit Rate");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_STOP_BITS,
                                               stopbits
                                               ), 4, "Stop Bits");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_DATA_BITS_COUNT,
                                               databits
                                               ), 5, "Data bits");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_PARITY,
                                               parity
                                               ), 6, "Parity");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_POLARITY,
                                               polarity
                                               ), 7, "Polarity");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

ViStatus _VI_FUNC rsscope_ConfigureUARTPackets (ViSession instrumentHandle,
                                                ViInt32 packets,
                                                ViString endWord,
                                                ViReal64 packetsTimeout)
{
packetsTimeout;
endWord;
packets;
instrumentHandle;
/*    

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_UART_INTERFRAME_TIME,
                                                packetsTimeout
                                                ), 8, "Packets Timeout");
*/

    return RS_ERROR_FUNCTION_NOT_SUPPORTED;
}

/// HIFN  This function configures the trigger type and source for UART 
/// HIFN  analysis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger even
/// HIPAR type/This control select trigger type.
/// HIPAR source/This control select trigger type.
ViStatus _VI_FUNC rsscope_ConfigureUARTTriggerType(
    ViSession    instrSession,
    ViInt32      trigger,
    ViInt32      type,
    ViInt32      source
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10];
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");   

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_MODE,
                                               type
                                               ), 3, "Type");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_SOURCE,
                                               source
                                               ), 4, "Source");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configure the data conditions if the trigger type is set 
/// HIFN  to Data.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger even 
/// HIPAR condition/Selects the operator for the data pattern.
/// HIPAR pattern/Specifies the data pattern to be found on the specified trigger 
/// HIPAR pattern/source, in hex format. Enter the words in msb first bit order.
/// HIPAR position/Operator for the data position. You can defined an exact position, or 
/// HIPAR position/a position range.
/// HIPAR indexMin/Sets the number of words before the first word of interest. These 
/// HIPAR indexMin/offset words are ignored. If the Position defines a range, the first 
/// HIPAR indexMin/word of interest is defined.
/// HIPAR indexMax/Sets the last word of interest, if the Position defines a range.
ViStatus _VI_FUNC rsscope_ConfigureUARTTriggerData(
    ViSession    instrSession,
    ViInt32      trigger,
    ViInt32      condition,
    ViString     pattern,
    ViInt32      position,
    ViInt32      indexMin,
    ViInt32      indexMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10];
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_DATA_PATTERN_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_DATA_PATTERN_CONDITION,
                                               condition
                                               ), 3, "Condition");
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_DATA_PATTERN,
                                                pattern
                                                ), 4, "Pattern");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_DATA_POSITION,
                                               position
                                               ), 5, "Position");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_DATA_POSITION_INDEX_MIN,
                                               indexMin
                                               ), 6, "Index Min");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_TRIGGER_DATA_POSITION_INDEX_MAX,
                                               indexMax
                                               ), 7, "Index Max");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the number of decoded frames.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Number of decoded words.
ViStatus _VI_FUNC rsscope_QueryUARTFrameCount(
    ViSession    instrSession,
    ViInt32        serialBus,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_UART_WORD_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_UART_WORD_COUNT,
                                               count
                                               ), 3, "Count");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the detailed decoded data of the specified word.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR word/This control selects the word.
/// HIPAR source/Line on which the specified word was tranferred.
/// HIPAR status/The status of the specified word.
/// HIPAR start/Time of the word start (start bit)
/// HIPAR txValue/Decimal value of the Tx word
/// HIPAR rxValue/Decimal value of the Rx word
ViStatus _VI_FUNC rsscope_QueryUARTFrameData(
    ViSession    instrSession,
    ViInt32      serialBus,
    ViInt32      word,
    ViInt32*     source,
    ViInt32*     status,
    ViReal64*    start,
    ViInt32*     txValue,
    ViInt32*     rxValue
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViUInt16    temp = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K2") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    error = viQueryf (instrSession, "BUS%ld:UART:WORD%ld:SOUR?", "%s", serialBus, word, buffer);
    *source = rsscope_StringIndex(protocolUARTLine_Arr, buffer); 
    if (error != VI_SUCCESS)
    {       
        viQueryf (instrSession, "*ESR?\n", "%hu", &temp);

        if ((temp & 32) != 0)
            error = VI_SUCCESS;
        else
            error = RS_ERROR_INSTRUMENT_STATUS;
    }
    
    
    error = viQueryf (instrSession, "BUS%ld:UART:WORD%ld:STAT?", "%s", serialBus, word, buffer);
    *status = rsscope_StringIndex(protocolUARTStatus_Arr, buffer); 
    if (error != VI_SUCCESS)
    {       
        viQueryf (instrSession, "*ESR?\n", "%hu", &temp);

        if ((temp & 32) != 0)
            error = VI_SUCCESS;
        else
            error = RS_ERROR_INSTRUMENT_STATUS;
    }
    
    
    error = viQueryf (instrSession, "BUS%ld:UART:WORD%ld:STAR?", "%le", serialBus, word, start);
    if (error != VI_SUCCESS)
    {       
        viQueryf (instrSession, "*ESR?\n", "%hu", &temp);

        if ((temp & 32) != 0)
            error = VI_SUCCESS;
        else
            error = RS_ERROR_INSTRUMENT_STATUS;
    }
    
    error = viQueryf (instrSession, "BUS%ld:UART:WORD%ld:RXV?", "%ld", serialBus, word, rxValue);
    if (error != VI_SUCCESS)
    {       
        viQueryf (instrSession, "*ESR?\n", "%hu", &temp);

        if ((temp & 32) != 0)
            error = VI_SUCCESS;
        else
            error = RS_ERROR_INSTRUMENT_STATUS;
    }
    
    error = viQueryf (instrSession, "BUS%ld:UART:WORD%ld:TXV?", "%ld", serialBus, word, txValue);
    if (error != VI_SUCCESS)
    {       
        viQueryf (instrSession, "*ESR?\n", "%hu", &temp);

        if ((temp & 32) != 0)
            error = VI_SUCCESS;
        else
            error = RS_ERROR_INSTRUMENT_STATUS;
    }
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures source waveform of the data line.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR waveformSource/Selects the source of the waveform.
ViStatus _VI_FUNC rsscope_ConfigureLINSource(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     waveformSource
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_SOURCE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_SOURCE,
                                                 waveformSource
                                                 ), 3, "Waveform Source");
                                                 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures threshold value for digitization of analog 
/// HIFN  signals. 
/// HIFN     If the signal value is higher than the threshold, the signal state is 
/// HIFN  high (logic 1). Otherwise, the signal state is considered low (logic 
/// HIFN  0).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs the threshold voltage for various signal 
/// HIPAR preset/technologies from a list.
/// HIPAR manualThreshold/Sets user-defined value of the threshold voltage.
ViStatus _VI_FUNC rsscope_ConfigureLINThreshold(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     preset,
    ViReal64    manualThreshold
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TECHNOLOGY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TECHNOLOGY,
                                                 preset
                                                 ), 3, "Preset");

    if (preset == RSSCOPE_VAL_LIN_MAN)
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_PROTOCOL_LIN_THRESHOLD,
                                                    manualThreshold
                                                    ), 4, "Manual Threshold");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the idle state of the bus. The idle state is 
/// HIFN  the rezessive state and corresponds to a logic 1.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR polarity/Selects line polarity.
ViStatus _VI_FUNC rsscope_ConfigureLINPolarity(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     polarity
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_POLARITY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_POLARITY,
                                                 polarity
                                                 ), 3, "Polarity");
     
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the number of transmitted bits per second.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR standard/Selects the version of the LIN standard that is used in the DUT.
/// HIPAR standard/The setting mainly defines the checksum version used during decoding.
/// HIPAR bitRate/Sets the number of transmitted bits per second.
ViStatus _VI_FUNC rsscope_ConfigureLINStandard(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     standard,
    ViInt32     bitRate
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_STANDARD,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_STANDARD,
                                                 standard
                                                 ), 3, "Standard");
                                                 
    if (standard != RSSCOPE_VAL_LIN_STANDARD_J2602)
    {
        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_LIN_BIT_RATE,
                                                     bitRate
                                                     ), 4, "Bit Rate");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the trigger type for LIN analysis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR type/Selects the trigger type for LIN analysis.
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerType(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     type
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_MODE,
                                                 type
                                                 ), 3, "Type");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures conditions for ID trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set a specific identifier or an identifier range.
/// HIPAR idMin/Sets the message identifier pattern, or sets the the start value of an 
/// HIPAR idMin/identifier range.
/// HIPAR idMax/Sets the the end value of an identifier range if "Condition" is "In 
/// HIPAR idMax/range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerID(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     condition,
    ViString    idMin,
    ViString    idMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
                         
    strcat(rep_cap, ",ID");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CONDITION,
                                                 condition
                                                 ), 3, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_PATTERN_MIN,
                                                 idMin
                                                 ), 4, "ID Min");
    
    if (condition >= RSSCOPE_VAL_COND_IN)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_PATTERN_MAX,
                                                     idMax
                                                     ), 5, "ID Max");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures triggering on one to four address conditions. 
/// HIFN  Enter the patterns in the "Frame ID" fields
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR orSlot/This control select index of the address in an "address OR" condition 
/// HIPAR orSlot/(OR slot).
/// HIPAR orSlotState/If set to "On" the indicated ADOR address is included in the 
/// HIPAR orSlotState/"identifier OR" trigger condition.
/// HIPAR frameID/Sets the pattern of the indicated IDOR identifier in the "identifier 
/// HIPAR frameID/OR" trigger condition.
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerIDOR(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     orSlot,
    ViBoolean   orSlotState,
    ViString    frameID
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[20]="";
    ViChar      rep_cap_slot[5]="";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, orSlot, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "OR Slot");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ADDRESS_OR_STATE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ADDRESS_OR_STATE,
                                                 "ORSlot",
                                                 orSlot - 1,
                                                 5,
                                                 rep_cap_slot), 3, "OR Slot");
    
    strcat(rep_cap, ",");
    strcat(rep_cap, rep_cap_slot);

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ADDRESS_OR_STATE,
                                                 orSlotState
                                                 ), 4, "OR Slot State");
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ADDRESS_OR,
                                                 frameID
                                                 ), 5, "Frame ID");
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures conditions for data trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set a specific identifier or an identifier range.
/// HIPAR dataMin/Sets a data pattern, or sets the the start value of a data pattern 
/// HIPAR dataMin/range. Enter the pattern MSB first and with Big endian byte order. 
/// HIPAR dataMax/Sets the the end value of an identifier range if "Condition" "In 
/// HIPAR dataMax/range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerData(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     condition,
    ViString    dataMin,
    ViString    dataMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
                         
    strcat(rep_cap, ",Data");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CONDITION,
                                                 condition
                                                 ), 3, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_PATTERN_MIN,
                                                 dataMin
                                                 ), 4, "Data Min");
    
    if (condition >= RSSCOPE_VAL_COND_IN)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_PATTERN_MAX,
                                                     dataMax
                                                     ), 5, "Data Max");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures data trigger setup.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set the data length code for triggering on LIN data.
/// HIPAR dataLength/Sets the length of the bit pattern to be found, in bytes.
/// HIPAR transfer/Sets the byte order (endianess) of the data transfer.
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerDataSetup (ViSession instrSession,
                                                        ViInt32 trigger,
                                                        ViInt32 condition,
                                                        ViInt32 dataLength,
                                                        ViInt32 transfer)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_DATA_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
                         
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_DATA_CONDITION,
                                                 condition), 3, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_DATA_LENGTH,
                                                 dataLength), 4, "Data Length");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_DATA_TRANSFER,
                                                 transfer), 5, "Transfer");
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures conditions for Error Condition trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR checksum/Sets state of triggering on the CRC error according to the LIN 
/// HIPAR checksum/standard.
/// HIPAR idParityError/Sets state of triggering on an error in the identifier parity bits. 
/// HIPAR idParityError/These are the bits 6 and 7 of the identifier.
/// HIPAR syncError/Sets state of triggering on a synchronization error. 
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerErrorConditions(
    ViSession   instrSession,
    ViInt32     trigger,
    ViBoolean   checksum,
    ViBoolean   idParityError,
    ViBoolean   syncError
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_trig[10] = "";
    ViChar      rep_cap[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
                                                 
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, rep_cap_trig,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_MODE,
                                                 RSSCOPE_VAL_LIN_ERR_COND));
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Checksum");                                             
    viCheckParm (rsscope_SetAttributeViBoolean(instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ERROR,
                                                 checksum
                                                 ), 3, "Checksum");
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",IDParity");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ERROR,
                                                 idParityError
                                                 ), 4, "ID Parity Error");
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Sync");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_ERROR,
                                                 syncError
                                                 ), 5, "Sync Error");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the bit pattern of the slave identifier 
/// HIFN  ("ID") and the number of data bytes ("Data length") when trigger on CRC 
/// HIFN  error is enabled.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR frameID/Sets bit pattern of the slave identifier ("ID").
/// HIPAR dataLength/Sets the number of data bytes to trigger on CRC errors.
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerCRCErrorPattern(
    ViSession   instrSession,
    ViInt32     trigger,
    ViString    frameID,
    ViInt32     dataLength
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CRC_ERROR_DATA_LENGTH,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");

    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CRC_ERROR_PATTERN,
                                                 frameID
                                                 ), 3, "Frame ID");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CRC_ERROR_DATA_LENGTH,
                                                 dataLength
                                                 ), 4, "DataL ength");
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function sets the LIN standard to trigger on CRC errors.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR standard/Sets the LIN standard to trigger on CRC errors.
ViStatus _VI_FUNC rsscope_ConfigureLINTriggerCRCErrorStandard (ViSession instrSession,
                                                               ViInt32 trigger,
                                                               ViInt32 standard)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CRC_STANDARD,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_TRIGGER_CRC_STANDARD,
                                                 standard
                                                 ), 3, "Standard");
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Queries the number of decoded frames.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Returns number of decoded frames.
ViStatus _VI_FUNC rsscope_QueryLINFrameCount(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_FRAME_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                 
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_LIN_FRAME_COUNT,
                                                 count
                                                 ), 3, "Count");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Queries the overall state of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR frameStatus/The overall state of the frame.
/// HIPAR frameStart/Time of frame start.
/// HIPAR frameStop/Time of frame stop.
/// HIPAR version/Returns the version of the LIN standard for the specified frame.
ViStatus _VI_FUNC rsscope_QueryLINFrameStatus(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32*    frameStatus,
    ViReal64*   frameStart,
    ViReal64*   frameStop,
    ViInt32*    version
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:STAT?", "%s", serialBus, frame, buffer));
    *frameStatus = rsscope_StringIndex(protocolLINFrameStatus_Arr, buffer);
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:STAR?", "%le", serialBus, frame, frameStart));
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:STOP?", "%le", serialBus, frame, frameStop));
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:VERS?", "%s", serialBus, frame, buffer));
    *version = rsscope_StringIndex(protocolLINVersion_Arr, buffer);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the identifier parameters of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR value/Returns the version of the LIN standard for the specified frame.
/// HIPAR parity/Returns the value of the identifier parity bits of the selected frame.
/// HIPAR status/Returns the identifier state of the selected frame.
ViStatus _VI_FUNC rsscope_QueryLINFrameID(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32*    value,
    ViInt32*    parity,
    ViInt32*    status
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));

    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:IDV?", "%ld", serialBus, frame, value));
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:IDPV?", "%ld", serialBus, frame, parity));
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:IDST?", "%s", serialBus, frame, buffer));
    *status = rsscope_StringIndex(protocolLINFieldStatus_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the identifier parameters of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR field/This control selects the field which will be queried.
/// HIPAR fieldValue/Returns the value of selected field for the specified frame.
/// HIPAR fieldStatus/Returns the selected field state for the specified frame.
ViStatus _VI_FUNC rsscope_QueryLINFrameField(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32     field,
    ViInt32*    fieldValue,
    ViInt32*    fieldStatus
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViString    fieldArr[] = {"SY", "CS"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, field, RSSCOPE_VAL_LIN_FIELD_SYNC, RSSCOPE_VAL_LIN_FIELD_CHKSUM) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Field");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    if(field == RSSCOPE_VAL_LIN_FIELD_SYNC) 
    {
        *fieldValue = -1;
    }
    else 
    {
        viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:%sV?\n", "%ld", serialBus, frame, fieldArr[field], fieldValue));
    }
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:%sST?\n", "%s", serialBus, frame, fieldArr[field], buffer));
    *fieldStatus = rsscope_StringIndex(protocolLINFieldStatus_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the data value of the specified byte.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR byteNumber/This control selects the Byte.
/// HIPAR data/Value of the specified byte
/// HIPAR statusCode/Returns the data state for the specified frame.
ViStatus _VI_FUNC rsscope_QueryLINFrameData(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32     byteNumber,
    ViInt32*    data,
    ViInt32*    statusCode
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:BYTE%ld:VAL?", "%ld", serialBus, frame, byteNumber, data));
    viCheckErr (viQueryf (instrSession, "BUS%ld:LIN:FRAM%ld:BYTE%ld:STAT?", "%s", serialBus, frame, byteNumber, buffer));
    *statusCode = rsscope_StringIndex(protocolLINFieldStatus_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the data bytes of the specified frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR arraySize/Pass the number of values allocated for Data result array.
/// HIPAR data/Array of decimal values of the data bytes.
/// HIPAR returnedValues/Returns number of results returned from the instrument.
ViStatus _VI_FUNC rsscope_QueryLINFrameAllData(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32     arraySize,
    ViInt32     data[],
    ViInt32*    returnedValues
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt; 
    ViInt32     i=0;
    ViInt32     value_count = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:LIN:FRAM%d:DATA?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    
    value_count = atoi (p2buf);
    
    arraySize = (arraySize < value_count) ? arraySize : value_count;
    
    p2buf = strtok(NULL, ",");
    
    while (p2buf && (i < arraySize))
    {                  
        data[i] = atol(p2buf);
        p2buf = strtok(NULL, ",");
        i++;
    }
    *returnedValues = i;
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function returns the symbolic label of the specified frame if the 
/// HIFN  label list is enabled.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Translation'.
/// HIPAR label/String with symbolic name of the identifier.
ViStatus _VI_FUNC rsscope_QueryLINFrameLabel (ViSession instrSession,
                                              ViInt32 serialBus, ViInt32 frame,
                                              ViInt32 bufferSize, ViChar label[])
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:LIN:FRAM%d:SYMB?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt));
	
	if ((ViUInt32) bufferSize < ret_cnt) ret_cnt = (ViUInt32) bufferSize;
		
	strncpy (label, extBuf, ret_cnt);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
	if (extBuf) free (extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures input channel of the CAN line.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR line/Selects the CAN-High or CAN-Low line. Both lines are required for 
/// HIPAR line/differential signal transmission used by CAN.
/// HIPAR waveformSource/Selects the source of the waveform.
ViStatus _VI_FUNC rsscope_ConfigureCANSource(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     line,
    ViInt32     waveformSource
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_LINE_TYPE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_LINE_TYPE,
                                                 line
                                                 ), 3, "Line");
        
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_SOURCE,
                                                 waveformSource
                                                 ), 4, "Waveform Source");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures threshold value for digitization of analog 
/// HIFN  signals. 
/// HIFN  If the signal value is higher than the threshold, the signal state is 
/// HIFN  high (logic 1). Otherwise, the signal state is considered low (logic 
/// HIFN  0).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs the threshold voltage for various signal 
/// HIPAR preset/technologies from a list.
/// HIPAR manualThreshold/Sets user-defined value of the threshold voltage.
ViStatus _VI_FUNC rsscope_ConfigureCANThreshold(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     preset,
    ViReal64    manualThreshold
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TECHNOLOGY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TECHNOLOGY,
                                                 preset
                                                 ), 3, "Preset");
                                                 
    if (preset == RSSCOPE_VAL_CAN_MAN)
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_PROTOCOL_CAN_THRESHOLD,
                                                    manualThreshold
                                                    ), 4, "Manual Threshold");
    }

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the number of transmitted bits per second.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR bitRate/Sets the number of transmitted bits per second.
ViStatus _VI_FUNC rsscope_ConfigureCANBitRate(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     bitRate
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_BIT_RATE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                     
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_BIT_RATE,
                                                 bitRate
                                                 ), 3, "Bit Rate");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures maximum number of time quanta for phase 
/// HIFN  correction. This mean Time segment1 may be lengthened or Time segment2 
/// HIFN  may be shortened due to resynchronization.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR jumpWidth/Sets the jump width.
ViStatus _VI_FUNC rsscope_ConfigureCANJumpWidth(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViReal64    jumpWidth
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_JUMP_WIDTH,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_JUMP_WIDTH,
                                                 jumpWidth
                                                 ), 3, "Jump Width");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the number of time quanta before the sample 
/// HIFN  point (Time segment1) and after the sample point (Time segmnet 2).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR timeSegment1/Set the number of time quanta before the sample point.
/// HIPAR timeSegment2/Set the number of time quanta after the sample point.
ViStatus _VI_FUNC rsscope_ConfigureCANSamplePointAbsolute(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     timeSegment1,
    ViInt32     timeSegment2
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";
    ViChar      rep_cap_TS[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    if ((timeSegment1 + timeSegment2) > 25)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Time Segment");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_SAMPLE_POINT_ABS,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                            
    strcpy(rep_cap_TS, rep_cap);
    strcat(rep_cap_TS, ",TS1");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_TS,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_SAMPLE_POINT_ABS,
                                                 timeSegment1
                                                 ), 3, "Time Segment 1");
    
    strcpy(rep_cap_TS, rep_cap);
    strcat(rep_cap_TS, ",TS2");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_TS,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_SAMPLE_POINT_ABS,
                                                 timeSegment2
                                                 ), 4, "Time Segment 2");
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the position of the sample point within the 
/// HIFN  bit in percent of the nominal bit time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR samplePoint/Sets the position of the sample point within the bit in percent of the 
/// HIPAR samplePoint/nominal bit time.
ViStatus _VI_FUNC rsscope_ConfigureCANSamplePointRelative(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViReal64        samplePoint
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_SAMPLE_POINT_REL,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                 
    viCheckParm (rsscope_SetAttributeViReal64(instrSession, rep_cap,
                                                RSSCOPE_ATTR_PROTOCOL_CAN_SAMPLE_POINT_REL,
                                                samplePoint
                                                ), 3, "Sample Point");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the trigger type for CAN analysis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR type/Selects the trigger type for CAN analysis.
/// HIPAR frameType/Selects the frame type which will be used as trigger condition.
ViStatus _VI_FUNC rsscope_ConfigureCANTriggerType(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     type,
    ViInt32     frameType
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_MODE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
                                                     
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_MODE,
                                                 type
                                                 ), 3, "Type");
                                                 
    if(type == RSSCOPE_VAL_CAN_FRAME_TYPE)
    {
        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_FRAME_TYPE,
                                                 frameType
                                                 ), 3, "Type");
    }
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures conditions for ID trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR idType/Selects the format of data and remote frames.
/// HIPAR condition/Sets the operator to set a specific identifier or an identifier range.
/// HIPAR idMin/Sets the message identifier pattern, or sets the the start value of an 
/// HIPAR idMin/identifier range.
/// HIPAR idMax/Sets the the end value of an identifier range if "Condition" "In 
/// HIPAR idMax/range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureCANTriggerID(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     idType,
    ViInt32     condition,
    ViString    idMin,
    ViString    idMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_ID_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
                                                     
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_ID_TYPE,
                                                 idType
                                                 ), 4, "ID Type");
    
    strcat(rep_cap, ",ID");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_CONDITION,
                                                 condition
                                                 ), 3, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_PATTERN_MIN,
                                                 idMin
                                                 ), 5, "ID Min");
    if(condition >= RSSCOPE_VAL_COND_IN)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_PATTERN_MAX,
                                                 idMax
                                                 ), 6, "ID Max");
    }
                                                 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures conditions for data trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR transfer/Selects the byte order (endianness) of the data transfer.
/// HIPAR condition/Sets the operator to set a specific identifier or an identifier range.
/// HIPAR dataMin/Sets a data pattern, or sets the the start value of a data pattern 
/// HIPAR dataMin/range. Enter the pattern MSB first and with Big endian byte order. 
/// HIPAR dataMax/Sets the the end value of an identifier range if "Condition" "In 
/// HIPAR dataMax/range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureCANTriggerData(
    ViSession   instrSession,
    ViInt32     trigger,
    ViInt32     transfer,
    ViInt32     condition,
    ViString    dataMin,
    ViString    dataMax
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[20] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_FRAME_ENDIANNESS,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
                                                     
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_FRAME_ENDIANNESS,
                                                 transfer
                                                 ), 3, "Transfer");
    
    strcat(rep_cap, ",Data");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_CONDITION,
                                                 condition
                                                 ), 4, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_PATTERN_MIN,
                                                 dataMin
                                                 ), 5, "Data Min");
    if(condition >= RSSCOPE_VAL_COND_IN)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_PATTERN_MAX,
                                                 dataMax
                                                 ), 6, "data Max");
    }

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures conditions for Error Condition trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR crc/Sets state of triggering on the CRC error. A CRC error occurs
/// HIPAR stuffing/Sets state of triggering on the bit stuffing error. A stuff error 
/// HIPAR stuffing/occurs when the 6th consecutive equal bit level in the mentioned fields 
/// HIPAR stuffing/is detected
/// HIPAR form/Sets state of triggering on the form error. A form error occurs when a 
/// HIPAR form/fixed-form bit field contains one or more illegal bits. 
/// HIPAR ack/Sets state of triggering on the form error. An acknowledgement error 
/// HIPAR ack/occurs when the transmitter does not receive an acknowledgment - a 
/// HIPAR ack/dominant bit during the Ack Slot.
ViStatus _VI_FUNC rsscope_ConfigureCANTriggerErrorConditions(
    ViSession   instrSession,
    ViInt32     trigger,
    ViBoolean   crc,
    ViBoolean   stuffing,
    ViBoolean   form,
    ViBoolean   ack
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[20] = "";
    ViChar      rep_cap_err[15] = ""; 

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_FRAME_ENDIANNESS,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
        
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_MODE,
                                                 RSSCOPE_VAL_CAN_ERR_COND));
                                                     
    strcpy(rep_cap_err, rep_cap);
    strcat(rep_cap_err, ",CRC");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap_err,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_ERROR,
                                                 crc
                                                 ), 3, "CRC");
    
    strcpy(rep_cap_err, rep_cap);
    strcat(rep_cap_err, ",Stuffing");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap_err,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_ERROR,
                                                 stuffing
                                                 ), 4, "Stuffing");
    
    strcpy(rep_cap_err, rep_cap);
    strcat(rep_cap_err, ",Form");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap_err,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_ERROR,
                                                 form
                                                 ), 5, "Form");
    
    strcpy(rep_cap_err, rep_cap);
    strcat(rep_cap_err, ",Ack");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap_err,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_TRIGGER_ERROR,
                                                 ack
                                                 ), 6, "Ack");
    

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}   

/// HIFN  Queries the number of decoded frames.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Number of decoded frames.
ViStatus _VI_FUNC rsscope_QueryCANFrameCount(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32*    count
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_FRAME_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
                                                     
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_CAN_FRAME_COUNT,
                                                 count
                                                 ), 3, "Count");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Queries the overall state of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR frameStatus/The overall state of the frame.
/// HIPAR frameStart/Time of frame start.
/// HIPAR frameStop/Time of frame stop.
/// HIPAR frameType/Returns the frame type of the selected frame.
ViStatus _VI_FUNC rsscope_QueryCANFrameStatus(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32*    frameStatus,
    ViReal64*   frameStart,
    ViReal64*   frameStop,
    ViInt32*    frameType
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:STAT?","%s", serialBus, frame, buffer));
    *frameStatus = rsscope_StringIndex (protocolCANFrameStatus_Arr, buffer);
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:STAR?","%le", serialBus, frame, frameStart));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:STOP?","%le", serialBus, frame, frameStop));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:TYPE?","%s", serialBus, frame, buffer));
    *frameType = rsscope_StringIndex (protocolCANFrameType_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the identifier parameters of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR idType/Returns the identifier type of the selected frame, the identifier 
/// HIPAR idType/format of data and remote frames.
/// HIPAR idValue/Returns the identifier value of the selected frame.
/// HIPAR statusCode/Return the identifier state.
ViStatus _VI_FUNC rsscope_QueryCANFrameID(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32*    idType,
    ViInt32*    idValue,
    ViInt32*    statusCode
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));

    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:IDTY?", "%s", serialBus, frame, buffer));
    *idType = rsscope_StringIndex(protocolCANIDType_Arr, buffer);

    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:IDV?", "%ld", serialBus, frame, idValue));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:IDST?", "%s", serialBus, frame, buffer));
    *statusCode = rsscope_StringIndex(protocolCANFieldStatus_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the parameters of selected field of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR field/This control selects the field which will be queried.
/// HIPAR value/Returns the value of selected field for the specified frame.
/// HIPAR status/Returns the field state of the selected frame.
ViStatus _VI_FUNC rsscope_QueryCANFrameField(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32     field,
    ViInt32*    value,
    ViInt32*    status
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViString        fieldArr[] = {"DLC", "CS", "ACK"};

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    if (rsscope_invalidViInt32Range (instrSession, field, RSSCOPE_VAL_CAN_FIELD_DLC, RSSCOPE_VAL_CAN_FIELD_ACK) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Field");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:%sV?", "%ld", serialBus, frame, fieldArr[field], value));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:%sSTate?", "%s", serialBus, frame, fieldArr[field], buffer));
    *status = rsscope_StringIndex(protocolCANFieldStatus_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the location of a bit stuffing error of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR errorPosition/Returns the location of a bit stuffing error.
ViStatus _VI_FUNC rsscope_QueryCANFrameBitStuffingError(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViReal64*   errorPosition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:BSEP?", "%le", serialBus, frame, errorPosition));

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the data value of the specified byte.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR byteNumber/This control selects the Byte.
/// HIPAR data/Value of the specified byte
/// HIPAR statusCode/Returns the state of the specified byte.
ViStatus _VI_FUNC rsscope_QueryCANFrameData(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32     byteNumber,
    ViInt32*    data,
    ViInt32*    statusCode
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:BYTE%ld:VAL?", "%ld", serialBus, frame, byteNumber, data));
    
    viCheckErr (viQueryf (instrSession, "BUS%ld:CAN:FRAM%ld:BYTE%ld:STAT?", "%s", serialBus, frame, byteNumber, buffer));
    *statusCode = rsscope_StringIndex(protocolCANFieldStatus_Arr, buffer);

    checkErr (rsscope_CheckStatus (instrSession));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}
   
/// HIFN  Queries the data bytes of the specified frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR arraySize/Pass the number of values allocated for Data result array.
/// HIPAR data/Array of decimal values of the data bytes.
/// HIPAR returnedValues/Returns number of results returned from the instrument.
ViStatus _VI_FUNC rsscope_QueryCANFrameAllData(
    ViSession   instrSession,
    ViInt32     serialBus,
    ViInt32     frame,
    ViInt32     arraySize,
    ViInt32     data[],
    ViInt32*    returnedValues
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt; 
    ViInt32     i=0;
    ViInt32     value_count = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:CAN:FRAM%d:DATA?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    
    value_count = atoi (p2buf);
    
    arraySize = (arraySize < value_count) ? arraySize : value_count;
    
    p2buf = strtok(NULL, ",");
    
    while (p2buf && (i < arraySize))
    {                  
        data[i] = atol(p2buf);
        p2buf = strtok(NULL, ",");
        i++;
    }
    *returnedValues = i;
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function returns the symbolic label of the specified frame if the 
/// HIFN  label list is enabled.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Translation'.
/// HIPAR label/String with symbolic name of the identifier.
ViStatus _VI_FUNC rsscope_QueryCANFrameLabel (ViSession instrSession,
                                              ViInt32 serialBus, ViInt32 frame,
                                              ViInt32 bufferSize, ViChar label[])
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K3") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:CAN:FRAM%d:SYMB?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt));
	
	if ((ViUInt32) bufferSize < ret_cnt) ret_cnt = (ViUInt32) bufferSize;
		
	strncpy (label, extBuf, ret_cnt);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
	if (extBuf) free (extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures MSO source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR line/Selects the line.
/// HIPAR waveformSource/Selects the source of the waveform.
/// HIPAR channel/This control selects the channel on which the signal is measured.
/// HIPAR separateHeaderBits/If ON, the leading five indicator bits of the header are decoded as five single bits.
/// HIPAR separateHeaderBits/Otherwise, the indicator bits are shown as one word with word length five bit
/// HIPAR bitRate/This control selects the bit rate.
ViStatus _VI_FUNC rsscope_ConfigureFlexRaySource (ViSession instrSession,
                                                  ViInt32 serialBus,
                                                  ViInt32 line,
                                                  ViInt32 waveformSource,
                                                  ViInt32 channel,
                                                  ViBoolean separateHeaderBits,
                                                  ViInt32 bitRate)
{
	ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap_bus[15] = "";
	ViChar        rep_cap_line[15] = "";
	ViChar        rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SOURCE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 15,
                                                 rep_cap_bus), 2, "Serial Bus");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SOURCE,
                                                 "Line",
                                                 line,
                                                 15,
                                                 rep_cap_line), 3, "Line");
	
	sprintf (rep_cap, "%s,%s", rep_cap_bus, rep_cap_line);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SOURCE,
                                                 waveformSource), 4, "Waveform Source");
        
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_CHANNEL,
                                                 channel), 5, "Channel");
	
	viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SEPARATE_HEADER_BITS,
                                                 separateHeaderBits), 6, "Separate Header Bits");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_BIT_RATE,
                                                 bitRate), 7, "Bit Rate");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function sets the type of measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function. The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR sourceType/Selects the source type.
ViStatus _VI_FUNC rsscope_ConfigureFlexRaySourceType (ViSession instrSession,
                                                      ViInt32 serialBus,
                                                      ViInt32 sourceType)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SOURCE_TYPE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SOURCE_TYPE,
                                                 sourceType), 3, "Source Type");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures threshold value for digitization of signals.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs a default threshold voltage.
/// HIPAR polarity/This control selects the wire on which the bus signal is measured in case of SINGle source type.
/// HIPAR manualThresholdHigh/Sets user-defined upper value of the threshold.
/// HIPAR manualThresholdLow/Sets user-defined lower value of the threshold.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayThresholdSingle (ViSession instrSession,
                                                           ViInt32 serialBus,
                                                           ViInt32 polarity,
														   ViInt32 preset,
                                                           ViReal64 manualThresholdHigh,
                                                           ViReal64 manualThresholdLow)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_bus[20]="";
    ViChar      rep_cap[20]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SINGLE_POLARITY,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SINGLE_POLARITY,
                                                 polarity), 3, "polarity");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_SINGLE_PRESET_TRESHOLD,
                                                 preset), 4, "preset");
	
	if (preset == RSSCOPE_VAL_FLEXRAY_SINGLE_MAN)
	{
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",High");
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRESHOLD,
                                                 manualThresholdHigh), 5, "Manual Threshold High");
												 
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",Low");
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRESHOLD,
                                                 manualThresholdLow), 6, "Manual Threshold Low");
	}
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures threshold value for digitization of signals.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs a default threshold voltage.
/// HIPAR manualThresholdHigh/Sets user-defined upper value of the threshold.
/// HIPAR manualThresholdLow/Sets user-defined lower value of the threshold.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayThresholdDifferential (ViSession instrSession,
                                                                 ViInt32 serialBus,
                                                                 ViInt32 preset,
                                                                 ViReal64 manualThresholdHigh,
                                                                 ViReal64 manualThresholdLow)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_bus[20]="";
    ViChar      rep_cap[20]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_DIFF_PRESET_TRESHOLD,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_DIFF_PRESET_TRESHOLD,
                                                 preset), 3, "Preset");
	
	if (preset == RSSCOPE_VAL_FLEXRAY_DIFF_MAN)
	{
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",High");
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRESHOLD,
                                                 manualThresholdHigh), 4, "Manual Threshold High");
												 
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",Low");
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRESHOLD,
                                                 manualThresholdLow), 5, "Manual Threshold Low");
	}
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures threshold value for digitization of signals from logic source.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR preset/This control selecs a default threshold voltage.
/// HIPAR manualThresholdDataLine/Sets the threshold for the data line.
/// HIPAR manualThresholdEnableLine/Sets the threshold for the enable line.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayThresholdLogic (ViSession instrSession,
                                                          ViInt32 serialBus,
                                                          ViInt32 preset,
                                                          ViReal64 manualThresholdDataLine,
                                                          ViReal64 manualThresholdEnableLine)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_bus[20]="";
    ViChar      rep_cap[20]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_LOGIC_PRESET_TRESHOLD,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
    
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_LOGIC_PRESET_TRESHOLD,
                                                 preset), 3, "Preset");
	
	if (preset == RSSCOPE_VAL_FLEXRAY_LOGIC_MAN)
	{
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",Data");
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_LOGIC_TRESHOLD,
                                                 manualThresholdDataLine), 4, "Manual Threshold Data Line");
												 
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",Enable");
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_LOGIC_TRESHOLD,
                                                 manualThresholdEnableLine), 5, "Manual Threshold Enable Line");
	}
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures the trigger type for FlexRay analysis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR type/Selects the trigger type for FlexRay analysis.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerType (ViSession instrSession,
                                                       ViInt32 trigger,
                                                       ViInt32 type)
{
	ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_TYPE,
                                               type), 3, "Type");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function sets to trigger on one or more indicator bits at the beginning of the header segment.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR payloadPreamble/Triggers on the payload preamble indicator bit that indicates 
/// HIPAR payloadPreamble/a Network Management Vector in the payload segment.
/// HIPAR nullFrame/Triggers on the null frame indicator bit, a frame without usable data.
/// HIPAR syncFrame/Triggers on the sync frame used for synchronization of the FlexRay system.
/// HIPAR startupFrame/Triggers on startup frames used for startup of the network.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerIndicatorBits (ViSession instrSession,
                                                                ViInt32 trigger,
                                                                ViInt32 payloadPreamble,
                                                                ViInt32 nullFrame,
                                                                ViInt32 syncFrame,
                                                                ViInt32 startupFrame)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[50] = "";
	ViChar      rep_cap_trig[50]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_INDICATOR_BITS,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap_trig), 2, "Trigger"); 
    
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Payload");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_INDICATOR_BITS,
                                               payloadPreamble), 3, "Payload Preamble");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",NullFrame");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_INDICATOR_BITS,
                                               nullFrame), 4, "Null Frame");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",SyncFrame");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_INDICATOR_BITS,
                                               syncFrame), 5, "Sync Frame");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",StartupFrame");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_INDICATOR_BITS,
                                               startupFrame), 6, "Startup Frame");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function configures conditions for frame ID trigger
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set a frame ID or a frame ID range.
/// HIPAR IDMin/Specifies a frame identifier pattern - the number of the slot - or sets the the start value 
/// HIPAR IDMin/of an identifier range.
/// HIPAR IDMax/Sets the the end value of an identifier range if "Condition" is "In range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerFrameID (ViSession instrSession,
                                                          ViInt32 trigger,
                                                          ViInt32 condition,
                                                          ViString IDMin,
                                                          ViString IDMax)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 15,
                                                 rep_cap), 2, "Trigger");
                         
    strcat(rep_cap, ",Frame");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 condition), 3, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_PATTERN_MIN,
                                                 IDMin), 4, "ID Min");
    
    if (condition == RSSCOPE_VAL_COND_IN || condition == RSSCOPE_VAL_COND_OUT)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_PATTERN_MAX,
                                                     IDMax), 5, "ID Max");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures conditions for payload length trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator for the payload length trigger setting.
/// HIPAR payloadMin/Specifies a payload length - the number of words in the payload segment - 
/// HIPAR payloadMin/or sets the the start value of an payload length range.
/// HIPAR payloadMax/Sets the the end value of a payload length range if "Condition"  
/// HIPAR payloadMax/is "In range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerPayloadLength (ViSession instrSession,
                                                                ViInt32 trigger,
                                                                ViInt32 condition,
                                                                ViInt32 payloadMin,
                                                                ViInt32 payloadMax)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
	ViChar      rep_cap_trig[15]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
                         
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Payload");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 condition), 3, "Condition");
                                                 
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Min");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_PAYLOAD_MIN_MAX,
                                                 payloadMin), 4, "payloadMin");
    
    if (condition == RSSCOPE_VAL_COND_IN || condition == RSSCOPE_VAL_COND_OUT)
    {
        strcpy(rep_cap, rep_cap_trig);
    	strcat(rep_cap, ",Max");
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_PAYLOAD_MIN_MAX,
                                                     payloadMax), 5, "Payload Max");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures conditions for cycle count trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to define a cycle count or a cycle count range.
/// HIPAR cycleMin/Specifies a cycle count - the number of the current FlexRay cycle - 
/// HIPAR cycleMin/or sets the the start value of an cycle count range.
/// HIPAR cycleMax/Sets the the end value of a cycle count range if "Condition" is "In range" and "Out of range".
/// HIPAR cycleStep/Specifies a step to trigger on each n-th cycle inside the given range.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerCycleCount (ViSession instrSession,
                                                             ViInt32 trigger,
                                                             ViInt32 condition,
                                                             ViInt32 cycleMin,
                                                             ViInt32 cycleMax,
                                                             ViInt32 cycleStep)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
	ViChar      rep_cap_trig[15]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
                         
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Cycle");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 condition), 3, "Condition");
                                                 
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Min");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CYCLE_MIN_MAX,
                                                 cycleMin), 4, "Cycle Min");
    
    if (condition == RSSCOPE_VAL_COND_IN || condition == RSSCOPE_VAL_COND_OUT)
    {
        strcpy(rep_cap, rep_cap_trig);
    	strcat(rep_cap, ",Max");
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CYCLE_MIN_MAX,
                                                     cycleMax), 5, "Cycle Max");
		
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_trig,
                                                     RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CYCLE_STEP,
                                                     cycleStep), 5, "Cycle Step");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures conditions for data trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR condition/Sets the operator to set a specific data pattern or a data pattern range.
/// HIPAR dataMin/Sets a data pattern, or sets the the start value of a data pattern range.
/// HIPAR dataMax/Sets the the end value of an identifier range if "Condition" "In range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerData (ViSession instrSession,
                                                       ViInt32 trigger,
                                                       ViInt32 condition,
                                                       ViString dataMin,
                                                       ViString dataMax)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
                         
    strcat(rep_cap, ",Data");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 condition), 3, "Condition");
                                                 
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_PATTERN_MIN,
                                                 dataMin), 4, "Data Min");
    
    if (condition == RSSCOPE_VAL_COND_IN || condition == RSSCOPE_VAL_COND_OUT)
    {
        viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_PATTERN_MAX,
                                                     dataMax), 5, "Data Max");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function sets the position of the first byte of data bit pattern within the payload segment.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Sets the operator for the payload length trigger setting.
/// HIPAR condition/Document parameter here.
/// HIPAR positionMin/Sets the number of data bytes to be skipped after start of the payload segment.
/// HIPAR positionMax/Defines the last byte of interest,if "Condition" is "In range" and "Out of range".
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerDataPosition (ViSession instrSession,
                                                               ViInt32 trigger,
                                                               ViInt32 condition,
                                                               ViInt32 positionMin,
                                                               ViInt32 positionMax)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[15] = "";
	ViChar      rep_cap_trig[15]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
                         
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Position");
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_CONDITION,
                                                 condition), 3, "Condition");
                                                 
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",Min");
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_POSITION_MIN_MAX,
                                                 positionMin), 4, "Position Min");
    
    if (condition == RSSCOPE_VAL_COND_IN)
    {
        strcpy(rep_cap, rep_cap_trig);
    	strcat(rep_cap, ",Max");
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                     RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_POSITION_MIN_MAX,
                                                     positionMax), 5, "Position Max");
    }
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function triggers on a symbol or on a wakeup pattern.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR symbol/Selects the trigger on symbol or on a wakeup pattern.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerSymbol (ViSession instrSession,
                                                         ViInt32 trigger,
                                                         ViInt32 symbol)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, trigger, RSSCOPE_VAL_TRIGGER_A, RSSCOPE_VAL_TRIGGER_R) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Trigger");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_SYMBOL,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap), 2, "Trigger");
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_SYMBOL,
                                                 symbol), 3, "Symbol");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures conditions for Error Condition trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR trigger/Selects trigger event.
/// HIPAR FSS/Triggers on Error in a Frame Start Sequence.
/// HIPAR BSS/Triggers on error in ByteStart Sequence.
/// HIPAR FES/Triggers on error in Frame End Sequence.
/// HIPAR headerCRC/Triggers on error in the Cyclic Redundancy Check of the header data.
/// HIPAR payloadCRC/Triggers on error in the Cyclic Redundancy Check of the payload data.
ViStatus _VI_FUNC rsscope_ConfigureFlexRayTriggerErrorConditions (ViSession instrSession,
                                                                  ViInt32 trigger,
                                                                  ViBoolean FSS,
                                                                  ViBoolean BSS,
                                                                  ViBoolean FES,
                                                                  ViBoolean headerCRC,
                                                                  ViBoolean payloadCRC)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[50] = "";
	ViChar      rep_cap_trig[50]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4"))) 
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_TYPE,
                                                 "Trigger",
                                                 trigger - 1,
                                                 10,
                                                 rep_cap_trig), 2, "Trigger");
                         
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, rep_cap_trig,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_TYPE,
                                                 RSSCOPE_VAL_FLEXRAY_ERR_COND));
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",FSS");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_ERROR,
                                                 FSS), 3, "FSS");
                                                 
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",BSS");
	viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_ERROR,
                                                 BSS), 4, "BSS");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",FES");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_ERROR,
                                                 FES), 5, "FES");
                                                 
    strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",HeaderCRC");
	viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_ERROR,
                                                 headerCRC), 6, "Header CRC");
	
	strcpy(rep_cap, rep_cap_trig);
    strcat(rep_cap, ",PayloadCRC");
	viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_TRIGGER_ERROR,
                                                 payloadCRC), 7, "Payload CRC");
    
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the number of decoded frames.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Returns the number of decoded frames.
ViStatus _VI_FUNC rsscope_QueryFlexRayFrameCount (ViSession instrSession,
                                                  ViInt32 serialBus,
                                                  ViInt32 *count)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_COUNT,
                                                 count), 3, "Count");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the number of the current FlexRay cycle.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR count/Returns number of the current FlexRay cycles.
ViStatus _VI_FUNC rsscope_QueryFlexRayCycleCount (ViSession instrSession,
                                                  ViInt32 serialBus,
												  ViInt32 frame,
                                                  ViInt32 *count)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      rep_cap_frame[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_CYCLE_COUNT,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_CYCLE_COUNT,
                                                 "Frame",
                                                 frame - 1,
                                                 5,
                                                 rep_cap_frame), 3, "Frame");
	
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_frame);
	
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_CYCLE_COUNT,
                                                 count), 4, "Count");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the overall state of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR frameStatus/Returns the overall state of the frame.
/// HIPAR frameStart/Returns time of frame start.
/// HIPAR frameStop/Returns time of frame stop.
/// HIPAR frameType/Returns the frame type of the selected frame.
ViStatus _VI_FUNC rsscope_QueryFlexRayFrameStatus (ViSession instrSession,
                                                   ViInt32 serialBus,
                                                   ViInt32 frame,
                                                   ViInt32 *frameStatus,
                                                   ViReal64 *frameStart,
                                                   ViReal64 *frameStop,
                                                   ViInt32 *frameType)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_bus[20]="";
	ViChar      rep_cap_frame[20]="";
    ViChar      rep_cap[30]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_STATUS,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_STATUS,
                                                 "Frame",
                                                 frame - 1,
                                                 5,
                                                 rep_cap_frame), 3, "Frame");
	
	strcat (rep_cap_bus, ",");
	strcat (rep_cap_bus, rep_cap_frame);
	viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_STATUS,
                                                 frameStatus), 4, "Frame Status");
	
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",Start");
	viCheckParm (rsscope_GetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_START_STOP,
                                                 frameStart), 5, "Frame Start");
												 
	strcpy(rep_cap, rep_cap_bus);
    strcat(rep_cap, ",Stop");
	viCheckParm (rsscope_GetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_START_STOP,
                                                 frameStop), 6, "Frame Stop");
	
	viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_TYPE,
                                                 frameType), 4, "Frame Type");
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the parameters of selected field of the frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR field/This control selects the field which will be queried.
/// HIPAR fieldValue/Returns the value of selected field for the specified frame.
/// HIPAR fieldStatus/Returns the field state of the selected frame.
ViStatus _VI_FUNC rsscope_QueryFlexRayFrameField (ViSession instrSession,
                                                  ViInt32 serialBus,
                                                  ViInt32 frame, ViInt32 field,
                                                  ViInt32 *fieldValue,
                                                  ViInt32 *fieldStatus)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[30]="";
	ViChar      rep_cap_frame[20]="";
	ViChar      rep_cap_field[20]="";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

	
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_FIELD_VALUE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 30,
                                                 rep_cap), 2, "Serial Bus");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_FIELD_VALUE,
                                                 "Frame",
                                                 frame - 1,
                                                 20,
                                                 rep_cap_frame), 3, "Frame");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_FIELD_VALUE,
                                                 "FieldValue",
                                                 field,
                                                 20,
                                                 rep_cap_field), 4, "Field");
	
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_frame);
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_field);
	
	viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_FIELD_VALUE,
                                                 fieldValue), 4, "Field Value");
	
	if (field == RSSCOPE_VAL_FLEXRAY_FIELD_HCRC || field == RSSCOPE_VAL_FLEXRAY_FIELD_FCRC)
		viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_PROTOCOL_FLEXRAY_FRAME_FIELD_STATUS,
                                                 fieldStatus), 4, "Field Status");
	
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Queries the data bytes of the specified frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR arraySize/Pass the number of values allocated for Data result array.
/// HIPAR data/Array of decimal values of the data bytes.
/// HIPAR returnedValues/Returns number of results returned from the instrument.
ViStatus _VI_FUNC rsscope_QueryFlexRayFrameAllData (ViSession instrSession,
                                                    ViInt32 serialBus,
                                                    ViInt32 frame,
                                                    ViInt32 arraySize,
                                                    ViInt32 data[],
                                                    ViInt32 *returnedValues)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt; 
    ViInt32     i=0;
    ViInt32     value_count = 0;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:FLXR:FRAM%d:DATA?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength (instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    
    value_count = atoi (p2buf);
    
    arraySize = (arraySize < value_count) ? arraySize : value_count;
    
    p2buf = strtok(NULL, ",");
    
    while (p2buf && (i < arraySize))
    {                  
        data[i] = atol(p2buf);
        p2buf = strtok(NULL, ",");
        i++;
    }
    *returnedValues = i;
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function returns the symbolic label of the specified frame if the 
/// HIFN  label list is enabled.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR frame/This control selects the frame.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Translation'.
/// HIPAR label/String with symbolic name of the identifier.
ViStatus _VI_FUNC rsscope_QueryFlexRayFrameLabel (ViSession instrSession,
                                                  ViInt32 serialBus,
                                                  ViInt32 frame,
                                                  ViInt32 bufferSize,
                                                  ViChar label[])
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K4") || rsscope_CheckOption (instrSession,"K0")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
    
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "", 
                                             RSSCOPE_ATTR_SET_QUERY_PATTERN_FORMAT, 
                                             RSSCOPE_VAL_PATTERN_DEC));
    
    viCheckErr( viPrintf(instrSession, "BUS%d:FLXR:FRAM%d:SYMB?", serialBus, frame));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt));
	
	if ((ViUInt32) bufferSize < ret_cnt) ret_cnt = (ViUInt32) bufferSize;
		
	strncpy (label, extBuf, ret_cnt);
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
	if (extBuf) free (extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;;
}

/// HIFN  This function defines a destination file for the hadcopy output.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR name/Defines the file name when an image of the display is stored to a file 
/// HIPAR name/rather than printed to a printer using the HCOPy:IMMediate command.
ViStatus _VI_FUNC rsscope_HardcopySetFileName(
    ViSession    instrSession,
    ViString    name
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_HARDCOPY_FILE_NAME,
                                                name
                                                ), 2, "Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function defines a destination file for the hadcopy output.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR device/Sets the device number.
/// HIPAR destination/Defines the output associated with device configuration.
/// HIPAR color/Defines the color mode for printing.
/// HIPAR pageOrientation/Defines the page orientation.
ViStatus _VI_FUNC rsscope_ConfigureHardcopyDevice(
    ViSession    instrSession,
    ViInt32        device,
    ViInt32        destination,
    ViBoolean    color,
    ViInt32        pageOrientation
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, device, 1, 2) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Device");
    }
    
    if (rsscope_invalidViInt32Range (instrSession, destination, RSSCOPE_VAL_HARDCOPY_DESTINATION_PNG, 
                                                  RSSCOPE_VAL_HARDCOPY_DESTINATION_PRN) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Destination");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HARDCOPY_DEVICE_DESTINATION,
                                                 "Destination",
                                                 device,
                                                 5,
                                                 rep_cap), 2, "Device");
    
    switch (destination)
    {
        case RSSCOPE_VAL_HARDCOPY_DESTINATION_PNG:
        case RSSCOPE_VAL_HARDCOPY_DESTINATION_JPG:
        case RSSCOPE_VAL_HARDCOPY_DESTINATION_BMP:
        case RSSCOPE_VAL_HARDCOPY_DESTINATION_TIFF:
            
            viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HARDCOPY_DEVICE_DESTINATION,
                                               RSSCOPE_VAL_HARDCOPY_DEVICE_MEM
                                               ), 3, "Destination");
            
            viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HARDCOPY_DEVICE_LANGUAGE_OUTPUT_FORMAT,
                                               destination
                                               ), 3, "Destination");
            break;
        
        case RSSCOPE_VAL_HARDCOPY_DESTINATION_CLP:
            viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HARDCOPY_DEVICE_DESTINATION,
                                               RSSCOPE_VAL_HARDCOPY_DEVICE_CLIPBOARD
                                               ), 3, "Destination");
            break;
        
        case RSSCOPE_VAL_HARDCOPY_DESTINATION_PRN:
            viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HARDCOPY_DEVICE_DESTINATION,
                                               RSSCOPE_VAL_HARDCOPY_DEVICE_PRINT
                                               ), 3, "Destination");
            
            viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_HARDCOPY_DEVICE_ORIENTATION,
                                               pageOrientation
                                               ), 5, "Page Orientation");
            break;
            
        default: break;
    }
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_HARDCOPY_COLOR,
                                                 color
                                                 ), 4, "Color");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function prints an image of the display to the printer or saves 
/// HIFN  an image to a file or the clipboard.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_HardcopyPrint(
    ViSession    instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_HARDCOPY_PRINT,
                                                VI_NULL
                                                ), 1, "Session");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the list of printers under Windows.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bufferSize/This control indicates the allocated memory in Printer List.
/// HIPAR printerList/This control returns list of printers available under  Windows NT 
/// HIPAR printerList/system. Names are separated using commas (,).
ViStatus _VI_FUNC rsscope_HardcopyGetPrinterList(
    ViSession    instrSession,
    ViInt32        bufferSize,
    ViChar        printerList[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar      *p2buf;
    ViInt32     count;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    p2buf=printerList;
    count=0;     
    
    viCheckErr (rsscope_GetAttributeViString (instrSession, "", RSSCOPE_ATTR_HARDCOPY_GET_FIRST_PRINTER,
                RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    while (strlen (buffer) > 0)
    {
        count+=(ViUInt32) strlen(buffer);  
        count++; //add one position for comma
        if (count<=bufferSize)
            p2buf += sprintf (p2buf, "%s,", buffer);
        buffer[0] = '\0';
        viCheckErr (rsscope_GetAttributeViString (instrSession, "", RSSCOPE_ATTR_HARDCOPY_GET_NEXT_PRINTER,
                RSSCOPE_IO_BUFFER_SIZE, buffer));      
    }
    *--p2buf='\0';
    
    if (count>bufferSize)
        error = count;     

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function selects a configured printer. To determine which 
/// HIFN  printers are installed, use the rsscope_HardcopyGetPrinterList 
/// HIFN  function.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR device/Sets the device number.
/// HIPAR printerName/Selects a configured printer.
ViStatus _VI_FUNC rsscope_HardcopySetPrinter(
    ViSession    instrSession,
    ViInt32        device,
    ViString    printerName
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar        rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, device, 1, 2) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Device");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HARDCOPY_DEVICE_DESTINATION,
                                                 "Destination",
                                                 device,
                                                 5,
                                                 rep_cap), 2, "Device");    
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_HARDCOPY_SELECT_PRINTER,
                                                printerName
                                                ), 3, "Printer Name");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function starts the shutdown of the firmware.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_FirmwareShutdown(
    ViSession    instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_FIRMWARE_SHUTDOWN,
                                                VI_NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the computer name that is currently defined. 
/// HIFN  The computer name is required when configuring a network.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR computerName/Configures the computer name that is currently defined. The computer 
/// HIPAR computerName/name is required when configuring a network.
ViStatus _VI_FUNC rsscope_ConfigureComputerName(
    ViSession    instrSession,
    ViString    computerName
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_COMPUTER_NAME,
                                                computerName
                                                ), 2, "Computer Name");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the firmware version, material number and serial 
/// HIFN  number .
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR firmwaveVersion/Returns the firmware version that is currently installed on the 
/// HIPAR firmwaveVersion/instrument.
/// HIPAR materialNumber/Returns the material number of your instrument. This number is 
/// HIPAR materialNumber/required to order a new option, and in case of service.
/// HIPAR serialNumber/Returns the serial number of your instrument. This number is required 
/// HIPAR serialNumber/to order a new option, and in case of service.
ViStatus _VI_FUNC rsscope_QueryInstrumentInformation(
    ViSession    instrSession,
    ViInt32     bufferSize,
    ViChar        firmwaveVersion[],
    ViChar        materialNumber[],
    ViChar        serialNumber[]
)
{
    ViStatus    error = VI_SUCCESS;
    
    viCheckParm (rsscope_GetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_FIRMWARE_VERSION,
                                                bufferSize,
                                                firmwaveVersion
                                                ), 3, "Firmwave Version");
    
    viCheckParm (rsscope_GetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_MATERIAL_NUMBER,
                                                bufferSize,
                                                materialNumber
                                                ), 3, "Material Number");
    
    viCheckParm (rsscope_GetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_SERIAL_NUMBER,
                                                bufferSize,
                                                serialNumber
                                                ), 3, "Serial Number");

Error:
    return error;
}

/// HIFN  This function starts the selftest.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_StartSelftest(
    ViSession    instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_START_SELFTEST,
                                                VI_NULL));
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the summary result of the selftest.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR selftestStatus/Returns the summary result of the selftest.
ViStatus _VI_FUNC rsscope_SelftestStatus(
    ViSession    instrSession,
    ViInt32*    selftestStatus
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, "",
                                               RSSCOPE_ATTR_SELFTEST_STATUS,
                                               selftestStatus
                                               ), 2, "Selftest Status");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function sets the value of a ViInt32 attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to set the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value to which you want to set the attribute.
ViStatus _VI_FUNC rsscope_SetAttributeViInt32 (ViSession instrSession, ViString channelName,
                                                ViUInt32 attributeId, ViInt32 value)
{
    return Rs_SetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function sets the value of a ViReal64 attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to set the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value to which you want to set the attribute.
ViStatus _VI_FUNC rsscope_SetAttributeViReal64 (ViSession instrSession, ViString channelName,
                                                 ViUInt32 attributeId, ViReal64 value)
{
     return Rs_SetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function sets the value of a ViString attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to set the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value to which you want to set the attribute.
ViStatus _VI_FUNC rsscope_SetAttributeViString (ViSession instrSession, ViString channelName,
                                                 ViUInt32 attributeId, ViString value)
{
    return Rs_SetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, value);
}

/// HIFN  This function sets the value of a ViBoolean attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to set the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value to which you want to set the attribute.
ViStatus _VI_FUNC rsscope_SetAttributeViBoolean (ViSession instrSession, ViString channelName,
                                                  ViUInt32 attributeId, ViBoolean value)
{
    return Rs_SetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function sets the value of a ViSession attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to set the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value to which you want to set the attribute.
ViStatus _VI_FUNC rsscope_SetAttributeViSession (ViSession instrSession, ViString channelName,
                                                  ViUInt32 attributeId, ViSession value)
{
    return Rs_SetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function queries the value of a ViInt32 attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to obtain the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Returns the current value of the attribute.  Pass the address of a 
/// HIPAR value/ViInt32 variable.
ViStatus _VI_FUNC rsscope_GetAttributeViInt32 (ViSession instrSession, ViString channelName,
                                                ViUInt32 attributeId, ViInt32 *value)
{
    return Rs_GetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL,
                            (ViInt32) sizeof (ViInt32), (ViInt32 *)value);
}

/// HIFN  This function queries the value of a ViReal64 attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to obtain the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Returns the current value of the attribute.  Pass the address of a 
/// HIPAR value/ViReal64 variable.
ViStatus _VI_FUNC rsscope_GetAttributeViReal64 (ViSession instrSession, ViString channelName,
                                                 ViUInt32 attributeId, ViReal64 *value)
{
    return Rs_GetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL,
                            (ViInt32) sizeof (ViReal64), (ViReal64 *)value);
}

/// HIFN  This function queries the value of a ViString attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to obtain the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR bufSize/Pass the number of bytes in the ViChar array you specify for the 
/// HIPAR bufSize/Attribute Value parameter.  
/// HIPAR value/The buffer in which the function returns the current value of the 
/// HIPAR value/attribute.  The buffer must be of type ViChar and have at least as many 
/// HIPAR value/bytes as indicated in the Buffer Size parameter.
ViStatus _VI_FUNC rsscope_GetAttributeViString (ViSession instrSession, ViString channelName,
                                                 ViUInt32 attributeId, ViInt32 bufSize,
                                                 ViChar value[])
{
    return Rs_GetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL,
                            bufSize, value);
}

/// HIFN  This function queries the value of a ViBoolean attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to obtain the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Returns the current value of the attribute.  Pass the address of a 
/// HIPAR value/ViBoolean variable.
ViStatus _VI_FUNC rsscope_GetAttributeViBoolean (ViSession instrSession, ViString channelName,
                                                  ViUInt32 attributeId, ViBoolean *value)
{
    return Rs_GetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL,
                            (ViInt32) sizeof (ViBoolean), (ViBoolean *)value);
}

/// HIFN  This function queries the value of a ViSession attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to obtain the value of the attribute. If the 
/// HIPAR channelName/attribute is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Returns the current value of the attribute.  Pass the address of a 
/// HIPAR value/ViSession variable.
ViStatus _VI_FUNC rsscope_GetAttributeViSession (ViSession instrSession, ViString channelName,
                                                  ViUInt32 attributeId, ViSession *value)
{
    return Rs_GetAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL,
                            (ViInt32) sizeof (ViSession), (ViSession *)value);
}

/// HIFN  This function checks the validity of a value you specify for a ViInt32 
/// HIFN  attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to check the attribute value. If the attribute 
/// HIPAR channelName/is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value which you want to verify as a valid value for the 
/// HIPAR value/attribute.
ViStatus _VI_FUNC rsscope_CheckAttributeViInt32 (ViSession instrSession, ViString channelName,
                                                  ViUInt32 attributeId, ViInt32 value)
{
    return Rs_CheckAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function checks the validity of a value you specify for a 
/// HIFN  ViReal64 attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to check the attribute value. If the attribute 
/// HIPAR channelName/is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value which you want to verify as a valid value for the 
/// HIPAR value/attribute.
ViStatus _VI_FUNC rsscope_CheckAttributeViReal64 (ViSession instrSession, ViString channelName,
                                                   ViUInt32 attributeId, ViReal64 value)
{
    return Rs_CheckAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function checks the validity of a value you specify for a 
/// HIFN  ViString attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to check the attribute value. If the attribute 
/// HIPAR channelName/is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value which you want to verify as a valid value for the 
/// HIPAR value/attribute.
ViStatus _VI_FUNC rsscope_CheckAttributeViString (ViSession instrSession, ViString channelName,
                                                   ViUInt32 attributeId, ViString value)
{
    return Rs_CheckAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, value);
}

/// HIFN  This function checks the validity of a value you specify for a 
/// HIFN  ViBoolean attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to check the attribute value. If the attribute 
/// HIPAR channelName/is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value which you want to verify as a valid value for the 
/// HIPAR value/attribute.
ViStatus _VI_FUNC rsscope_CheckAttributeViBoolean (ViSession instrSession, ViString channelName,
                                                    ViUInt32 attributeId, ViBoolean value)
{
    return Rs_CheckAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN  This function checks the validity of a value you specify for a 
/// HIFN  ViSession attribute.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channelName/If the attribute is channel-based, this parameter specifies the name 
/// HIPAR channelName/of the channel on which to check the attribute value. If the attribute 
/// HIPAR channelName/is not channel-based, then pass VI_NULL or an empty string.
/// HIPAR attributeId/Pass the ID of an attribute.
/// HIPAR value/Pass the value which you want to verify as a valid value for the 
/// HIPAR value/attribute.
ViStatus _VI_FUNC rsscope_CheckAttributeViSession (ViSession instrSession, ViString channelName,
                                                    ViUInt32 attributeId, ViSession value)
{
    return Rs_CheckAttribute (instrSession, channelName, attributeId, RS_VAL_DIRECT_USER_CALL, &value);
}

/// HIFN This function returns the repeated capability id(s) that belongs
/// HIFN to the attribute you specify. More then one id is listed in
/// HIFN comma separated string.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR attributeID/Pass the ID of an attribute.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the Repeated Capability Id(s) parameter.
/// HIPAR repeatedCapabilityIds/The buffer in which the function returns the repeated capability id(s) belonging to the attribute.
ViStatus _VI_FUNC rsscope_GetAttributeRepeatedCapabilityIds (ViSession instrSession,
                                                            ViUInt32 attributeID,
                                                            ViInt32 bufferSize,
                                                            ViChar _VI_FAR repeatedCapabilityIds[])
{
    ViStatus    error = VI_SUCCESS;
    ViChar      repCapNameId[RS_MAX_MESSAGE_BUF_SIZE] = "";

    if (bufferSize <= 0)
        viCheckParm(RS_ERROR_INVALID_PARAMETER, 3, "Buffer Size");

    viCheckErr (Rs_GetAttributeRepCapNameId (instrSession, attributeID, repCapNameId));

    strncpy (repeatedCapabilityIds, repCapNameId, RS_MAX_MESSAGE_BUF_SIZE);
    repeatedCapabilityIds[(bufferSize > RS_MAX_MESSAGE_BUF_SIZE) ?
        RS_MAX_MESSAGE_BUF_SIZE : bufferSize] = '\0';

Error:
    return error;
}

/// HIFN This function returns the repeated capability name(s) that
/// HIFN belongs to the attribute and single repeated capability id you
/// HIFN may specify. More then one name is listed in comma separated
/// HIFN string.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR attributeID/Pass the ID of an attribute.
/// HIPAR repeatedCapabilityId/If the attribute applies to a repeated capability such as a trace, this parameter defines the Id of the repeated capability on which to query repeated capability id name(s).
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the Repeated Capability Id Name(s) parameter.
/// HIPAR repeatedCapabilityIdNames/The buffer in which the function returns the repeated capability id name(s) belonging to the attribute.
ViStatus _VI_FUNC rsscope_GetAttributeRepeatedCapabilityIdNames (ViSession instrSession,
                                                                ViUInt32 attributeID,
                                                                ViString repeatedCapabilityId,
                                                                ViInt32 bufferSize,
                                                                ViChar _VI_FAR repeatedCapabilityIdNames[])
{
    ViStatus    error = VI_SUCCESS;
    ViChar      repCapName[RS_MAX_MESSAGE_BUF_SIZE] = "";

    if (bufferSize <= 0)
        viCheckParm(RS_ERROR_INVALID_PARAMETER, 4, "Buffer Size");

    viCheckErr (Rs_GetAttributeRepCapName (instrSession,
                                           attributeID,
                                           repeatedCapabilityId,
                                           repCapName));

    strncpy (repeatedCapabilityIdNames, repCapName, RS_MAX_MESSAGE_BUF_SIZE);
    repeatedCapabilityIdNames[(bufferSize >= RS_MAX_MESSAGE_BUF_SIZE) ?
        RS_MAX_MESSAGE_BUF_SIZE - 1 : bufferSize - 1] = '\0';

Error:
    return error;
}

/// HIFN  Enables the math waveform display.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR mathEnabled/Enables the math waveform display.
ViStatus _VI_FUNC rsscope_ConfigureMathEnabled(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViBoolean   mathEnabled
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap [5];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MATH_WAVEFORM_ENABLED,
                                                 mathEnabled), 3, "Math Enabled");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Configures general mathematics parameters.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR calculationMethod/Selects the method to build the resulting math waveform from 
/// HIPAR calculationMethod/consecutive acquisitions. The processing is similar to the waveform 
/// HIPAR calculationMethod/arithmetics - instead of the acquired waveforms the math waveforms are 
/// HIPAR calculationMethod/used to create envelope and average.
/// HIPAR expression/Defines the math expression to be calculated for the specified math 
/// HIPAR expression/channel.
ViStatus _VI_FUNC rsscope_ConfigureMathSetup(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViInt32 calculationMethod,
    ViString    expression
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_MATH_ACQUISITION_TYPE,
                                               calculationMethod), 3, "Calculation Method");
    
    viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_MATH_EXPRESSION,
                                                expression), 4, "Expression");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the range of FFT values to be displayed.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR verticalRange/Defines the range of FFT values to be displayed.
ViStatus _VI_FUNC rsscope_ConfigureMathVerticalRange(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViReal64    verticalRange
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_MATH_VERTICAL_RANGE,
                                                verticalRange), 3, "Vertical Range");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the scale of the y-axis in the math function diagram. The 
/// HIFN  value is defined as "V per division", e.g. 50V/div. In this case, the 
/// HIFN  horizontal grid lines are displayed in intervals of 50 V.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR verticalScale/Defines the scale of the y-axis in the math function diagram. The 
/// HIPAR verticalScale/value is defined as "V per division", e.g. 50V/div. In this case, the 
/// HIPAR verticalScale/horizontal grid lines are displayed in intervals of 50 V.
ViStatus _VI_FUNC rsscope_ConfigureMathVerticalScale(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViReal64    verticalScale
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_MATH_VERTICAL_SCALE,
                                                verticalScale), 3, "Vertical Scale");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Sets a voltage offset to adjust the vertical position of the math 
/// HIFN  function on the screen.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR verticalOffset/Sets a voltage offset to adjust the vertical position of the math 
/// HIPAR verticalOffset/function on the screen.
ViStatus _VI_FUNC rsscope_ConfigureMathVerticalOffset(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViReal64    verticalOffset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_MATH_VERTICAL_OFFSET,
                                                verticalOffset), 3, "Vertical Offset");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Forces the immediate restart of the envelope and average calculation 
/// HIFN  for all waveforms.     
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_MathReset (ViSession instrSession)
{
	ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
    viCheckErr (rsscope_SetAttributeViString (instrSession, "",
                         			RSSCOPE_ATTR_MATH_RESET, NULL));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the number of acquired waveforms after which the envelope and 
/// HIFN  average evaluation restarts.      
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR resetMode/Defines when the envelope and average evaluation restarts.
/// HIPAR envelopeTimeout/Defines the time after which the envelope and average evaluation 
/// HIPAR envelopeTimeout/restarts.
/// HIPAR acquiredWaveforms/Defines the number of acquired waveforms after which the envelope and 
/// HIPAR acquiredWaveforms/average evaluation restarts.
ViStatus _VI_FUNC rsscope_ConfigureMathResetMode (ViSession instrSession,
                                                  ViInt32 resetMode,
                                                  ViReal64 envelopeTimeout,
                                                  ViInt32 acquiredWaveforms)
{
	ViStatus    error = VI_SUCCESS;
    

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                RSSCOPE_ATTR_MATH_RESET_MODE,
                                                resetMode), 2, "Reset Mode");

    if (resetMode == RSSCOPE_VAL_MATH_RESET_TIME)
	{
		viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                RSSCOPE_ATTR_MATH_ENVELOPE_TIMEOUT,
                                                envelopeTimeout), 3, "Envelope Timeout");
    }
	if (resetMode == RSSCOPE_VAL_MATH_RESET_WFMS)
	{
    	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                RSSCOPE_ATTR_MATH_ACQUIRED_WAVEFORMS,
                                                acquiredWaveforms), 4, "Acquired Waveforms");
    }
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the frequency range by means of center frequency and frequency 
/// HIFN  span.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR centerFrequency/Defines the position of the displayed frequency range, which is 
/// HIPAR centerFrequency/(Center - Span/2) to (Center + Span/2).
/// HIPAR frequencySpan/Defines the stop frequency of the displayed frequency span.
ViStatus _VI_FUNC rsscope_ConfigureFFTFrequencyCenterSpan(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViReal64    centerFrequency,
    ViReal64    frequencySpan
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_CENTER_FREQUENCY,
                                                centerFrequency), 3, "Center Frequency");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_FREQUENCY_SPAN,
                                                frequencySpan), 4, "Frequency Span");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Performs FFT calculation for the full frequency span.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
ViStatus _VI_FUNC rsscope_ConfigureFFTFrequencySpanFull(
    ViSession   instrSession,
    ViInt32 mathNumber
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_FULL_SPAN, NULL));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the frequency range by means of start and stop frequency.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR startFrequency/Defines the start frequency of the displayed frequency span.
/// HIPAR stopFrequency/Defines the stop frequency of the displayed frequency span.
ViStatus _VI_FUNC rsscope_ConfigureFFTFrequencyStartStop(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViReal64    startFrequency,
    ViReal64    stopFrequency
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_START_FREQUENCY,
                                                startFrequency), 3, "Start Frequency");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_STOP_FREQUENCY,
                                                stopFrequency), 4, "Stop Frequency");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the FFT frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR rbwandSpanCouplingEnabled/Couples the frequency span to the RBW.
/// HIPAR rbwRatio/Defines the ratio resolution bandwidth (Hz) / span (Hz).
/// HIPAR resolutionBandwidth/Defines the resolution bandwidth.
ViStatus _VI_FUNC rsscope_ConfigureFFTResolutionBandwidth(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViBoolean   rbwandSpanCouplingEnabled,
    ViInt32 rbwRatio,
    ViReal64    resolutionBandwidth
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_FFT_RESOLUTION_BANDWIDTH_COUPLING_ENABLED,
                                                 rbwandSpanCouplingEnabled), 3, "RBW and Span Coupling Enabled");

    if (rbwandSpanCouplingEnabled == VI_TRUE)
    {
        viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                   RSSCOPE_ATTR_FFT_RESOLUTION_BANDWIDTH_RATIO,
                                                   rbwRatio), 4, "RBW Ratio");
    }
    else
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_FFT_RESOLUTION_BANDWIDTH,
                                                    resolutionBandwidth), 5, "Resolution Bandwidth");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Queries the effective resolution bandwidth.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR adjustedRBW/Queries the effective resolution bandwidth.
ViStatus _VI_FUNC rsscope_QueryFFTAdjustedResolutionBandwidth(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViReal64*   adjustedRBW
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_GetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_EFFECTIVE_RESOLUTION_BANDWIDTH,
                                                adjustedRBW), 3, "Adjusted RBW");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the FFT window.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR windowType/Windowing helps minimize the discontinuities at the end of the 
/// HIPAR windowType/measured signal interval and thus reduces the effect of spectral 
/// HIPAR windowType/leakage, increasing the frequency resolution.
ViStatus _VI_FUNC rsscope_ConfigureFFTWindowType(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViInt32 windowType
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_WINDOW_TYPE,
                                               windowType), 3, "Window Type");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Defines the FFT frame.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR arithmetic/The arithmetic mode defines how the final FFT result is calculated 
/// HIPAR arithmetic/from the individual frame results.
/// HIPAR overlapFactor/Defines the minimum factor by which two neighboring frames overlap. If 
/// HIPAR overlapFactor/the required number of frames to cover the input values allows for more 
/// HIPAR overlapFactor/overlap, the factor is increased.
/// HIPAR maxFrameCount/Restricts the maximum number of frames to be calculated. Due to the 
/// HIPAR maxFrameCount/other parameter settings, the required number of frames may become very 
/// HIPAR maxFrameCount/high, thus slowing performance. By restricting the number of frames, 
/// HIPAR maxFrameCount/you can avoid performance loss without changing the other parameters.
ViStatus _VI_FUNC rsscope_ConfigureFFTFrameSetup(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViInt32 arithmetic,
    ViInt32 overlapFactor,
    ViInt32 maxFrameCount
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_FRAME_ARITHMETIC,
                                               arithmetic), 3, "Arithmetic");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_FRAME_OVERLAP_FACTOR,
                                               overlapFactor), 4, "Overlap Factor");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_FRAME_MAX_FRAME_COUNT,
                                               maxFrameCount), 5, "Max Frame Count");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Due to the restriction of the number of frames, the waveform may only 
/// HIFN  be analyzed partially. This control queries the percentage of the trace 
/// HIFN  that was analyzed, i.e. which part of the trace was included in the 
/// HIFN  frame calculation.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR frameCoverage/Due to the restriction of the number of frames, the waveform may only 
/// HIPAR frameCoverage/be analyzed partially. This control queries the percentage of the trace 
/// HIPAR frameCoverage/that was analyzed, i.e. which part of the trace was included in the 
/// HIPAR frameCoverage/frame calculation.
ViStatus _VI_FUNC rsscope_QueryFFTFrameCoverage(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViInt32*    frameCoverage
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_FRAME_COVERAGE,
                                               frameCoverage), 3, "Frame Coverage");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the settings for the magnitude of the frequencies.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR magnitudeUnit/Defines the scaling of the y-axis. The display values are valid for 
/// HIPAR magnitudeUnit/50Ohm termination impendance.
/// HIPAR referenceLevel/Defines the reference level for dB scaling.
/// HIPAR magnitudeRange/Defines the vertical value range in spectrum mode.
ViStatus _VI_FUNC rsscope_ConfigureFFTMagnitude(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViInt32 magnitudeUnit,
    ViReal64    referenceLevel,
    ViInt32 magnitudeRange
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_MAGNITUDE_UNIT,
                                               magnitudeUnit), 3, "Magnitude Unit");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_REFERENCE_LEVEL,
                                                referenceLevel), 4, "Reference Level");
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_MAGNITUDE_RANGE,
                                               magnitudeRange), 5, "Magnitude Range");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Define the settings for the phase of the frequencies.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR phaseUnit/Defines the scaling unit for phase display.
/// HIPAR phaseUnwrapEnabled/If enabled, phase shifts due to a limitation of the value range are 
/// HIPAR phaseUnwrapEnabled/eliminated.
/// HIPAR suppressionEnabled/Enables noise suppression.
/// HIPAR suppressionThreshold/Defines the minimum frequency magnitude for which phases are 
/// HIPAR suppressionThreshold/calculated.
ViStatus _VI_FUNC rsscope_ConfigureFFTPhase(
    ViSession   instrSession,
    ViInt32 mathNumber,
    ViInt32 phaseUnit,
    ViBoolean   phaseUnwrapEnabled,
    ViBoolean   suppressionEnabled,
    ViReal64    suppressionThreshold
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    sprintf (rep_cap, "M%ld", mathNumber);  

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_PHASE_UNIT,
                                               phaseUnit), 3, "Phase Unit");
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_FFP_PHASE_UNWRAP_ENABLED,
                                                 phaseUnwrapEnabled), 4, "Phase Unwrap Enabled");

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_FFT_NOISE_SUPPRESSION_ENABLED,
                                                 suppressionEnabled), 5, "Suppression Enabled");

    if (suppressionEnabled == VI_TRUE)
    {
        viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                    RSSCOPE_ATTR_FFT_NOISE_SUPPRESSION_THRESHOLD,
                                                    suppressionThreshold), 6, "Suppression Threshold");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the state of the FFT gating.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR useGate/Enables FFT gating.
ViStatus _VI_FUNC rsscope_ConfigureFFTGateState(
    ViSession    instrSession,
    ViInt32        mathNumber,
    ViBoolean    useGate
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_GATE_ENABLED,
                                                 "Math",
                                                 mathNumber -1,
                                                 5,
                                                 rep_cap), 2, "Math Number");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_FFT_GATE_ENABLED, useGate
                                                 ), 3, "Use Gate");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether the gate area is displayed in the 
/// HIFN  source diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR showGate/Indicates the gate area in the source diagram.
ViStatus _VI_FUNC rsscope_ConfigureFFTGateShow(
    ViSession    instrSession,
    ViInt32        mathNumber,
    ViBoolean    showGate
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_GATE_DISPLAY_ENABLED,
                                                 "Math",
                                                 mathNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Math Number");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_FFT_GATE_DISPLAY_ENABLED, showGate
                                                 ), 3, "Show Gate");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures whether the gate area is defined identically 
/// HIFN  to the zoom area for the selected active zoom diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR zoomCoupling/If enabled, the gate area is defined identically to the zoom area for 
/// HIPAR zoomCoupling/the zoom diagram.
/// HIPAR zoomDiagram/This control is reserved for future use.
ViStatus _VI_FUNC rsscope_ConfigureFFTGateDefinitionZoom(
    ViSession    instrSession,
    ViInt32        mathNumber,
    ViBoolean    zoomCoupling,
    ViInt32        zoomDiagram
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";
    zoomDiagram;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_GATE_ZOOM_COUPLING_ENABLED,
                                                 "Math",
                                                 mathNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Math Number");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_FFT_GATE_ZOOM_COUPLING_ENABLED, zoomCoupling
                                                 ), 3, "Zoom Coupling");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the start and end values for the gate.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR start/Defines the starting value for the gate.
/// HIPAR stop/Defines the ending value for the gate.
ViStatus _VI_FUNC rsscope_ConfigureFFTGateDefinitionStartStop(
    ViSession    instrSession,
    ViInt32        mathNumber,
    ViInt32        mode,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap_m[5] = "";
    ViChar    rep_cap_t[15] = "";
    ViChar    rep_cap[30] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_GATE_MODE,
                                                 "Math",
                                                 mathNumber - 1,
                                                 5,
                                                 rep_cap_m), 2, "Math Number");     
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_GATE_START,
                                                 "AbsRel",
                                                 mode,
                                                 15,
                                                 rep_cap_t), 3, "Mode");    

    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_t);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_m,
                                               RSSCOPE_ATTR_FFT_GATE_MODE, mode
                                               ), 3, "Mode");    

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_GATE_START, start
                                                ), 4, "Start");

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_FFT_GATE_STOP, stop
                                                ), 5, "Stop");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the behaviour of the record length or RBW 
/// HIFN  value in dependancy to the other FFT parameters.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR coupling/Defines the behaviour of the record length or RBW value in dependancy 
/// HIPAR coupling/to the other FFT parameters.
ViStatus _VI_FUNC rsscope_ConfigureFFTGateRecordLengthRBWCoupling(
    ViSession    instrSession,
    ViInt32    mathNumber,
    ViInt32    coupling
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, mathNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Math Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_RESOLUTION_BANDWIDTH_GATE_COUPLING,
                                                 "Math",
                                                 mathNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Math Number");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_FFT_RESOLUTION_BANDWIDTH_GATE_COUPLING, coupling
                                               ), 3, "Coupling");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the required acquisition time. If FFT gating is 
/// HIFN  used and the resolution BW is set to constant, record length can be 
/// HIFN  extended to acquire the required number of samples. In this case, the 
/// HIFN  required acquisition time differs from the adjusted acquisition time.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR requiredAcquisitionTime/Queries the required acquisition time. If FFT gating is used and the 
/// HIPAR requiredAcquisitionTime/resolution BW is set to constant, record length can be extended to 
/// HIPAR requiredAcquisitionTime/acquire the required number of samples. In this case, the required 
/// HIPAR requiredAcquisitionTime/acquisition time differs from the adjusted acquisition time.
ViStatus _VI_FUNC rsscope_QueryFFTGateRequiredAcquisitionTime(
    ViSession    instrSession,
    ViReal64*    requiredAcquisitionTime
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, "",
                                             RSSCOPE_ATTR_ACQUISITION_TIME, requiredAcquisitionTime
                                             ), 3, "Required Acquisition Time");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Selects the source waveform to be used as a reference.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
/// HIPAR source/Selects the source waveform to be used as a reference.
ViStatus _VI_FUNC rsscope_ConfigureReferenceWaveformSource(
    ViSession    instrSession,
    ViInt32    referenceNumber,
    ViInt32    source
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_SOURCE,
                                                 "ReferenceWfm",
                                                 referenceNumber,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_SOURCE, source
                                               ), 3, "Source");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Copies the selected source waveform with all its settings to the 
/// HIFN  memory of the reference waveform
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
ViStatus _VI_FUNC rsscope_UpdateReferenceWaveformWithSelectedSource(
    ViSession    instrSession,
    ViInt32    referenceNumber
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_UPDATE,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_UPDATE, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables the reference waveform display in the diagram.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR displayEnabled/If enabled, the reference waveform is displayed in the diagram.
/// HIPAR referenceNumber/Selects the reference waveform.
ViStatus _VI_FUNC rsscope_ConfigureReferenceWaveformDisplayState(
    ViSession    instrSession,
    ViInt32        referenceNumber,
    ViBoolean    displayEnabled
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_DISPLAY_ENABLED,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_DISPLAY_ENABLED, displayEnabled
                                                 ), 3, "Display Enabled");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  The selected reference waveform is no longer displayed, its memory is 
/// HIFN  deleted.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
ViStatus _VI_FUNC rsscope_ClearReferenceWaveform(
    ViSession    instrSession,
    ViInt32        referenceNumber
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_CLEAR,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_CLEAR, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Enables the math waveform display.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
/// HIPAR waveformName/Defines the name of the reference waveform file to be loaded, saved or 
/// HIPAR waveformName/deleted.
/// HIPAR operation/This control selects the type of waveform operation to be performed.
ViStatus _VI_FUNC rsscope_ReferenceWaveformFileOperations(
    ViSession    instrSession,
    ViInt32        referenceNumber,
    ViString    waveformName,
    ViInt32        operation
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_NAME,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    switch (operation)
    {
        case RSSCOPE_VAL_WAV_SELECT:
            viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_NAME, waveformName
                                                ), 3, "Waveform Name");
        break;
        
        case RSSCOPE_VAL_WAV_OPEN:
            viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_LOAD, NULL));
        break;
        
        case RSSCOPE_VAL_WAV_SAVE:
            viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_SAVE, NULL));
        break;
        
        case RSSCOPE_VAL_WAV_DELETE:
            viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_DELETE, NULL));
        break;
        
        default: 
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 4, "Operation");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical scaling of the reference 
/// HIFN  waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
/// HIPAR verticalCoupling/Selects the coupling of vertical settings.
/// HIPAR verticalScale/Sets the scale factor for the reference waveform.
/// HIPAR verticalPosition/Moves the reference waveform and its horizontal axis up or down in the 
/// HIPAR verticalPosition/diagram, if vertical scaling is set to "Independent".
ViStatus _VI_FUNC rsscope_ConfigureReferenceWaveformVerticalScaling(
    ViSession    instrSession,
    ViInt32        referenceNumber,
    ViInt32        verticalCoupling,
    ViReal64    verticalScale,
    ViReal64    verticalPosition
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_COUPLING,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_COUPLING, verticalCoupling
                                               ), 3, "Vertical Coupling");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_SCALE, verticalScale
                                                ), 4, "Vertical Scale");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_POSITION, verticalPosition
                                                ), 5, "Vertical Position");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Restores the settings of the source waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
ViStatus _VI_FUNC rsscope_ReferenceWaveformVerticalScalingSetToOriginal(
    ViSession    instrSession,
    ViInt32        referenceNumber
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_RESTORE,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_RESTORE, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the vertical stretching of the reference 
/// HIFN  waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
/// HIPAR verticalStretchingEnabled/Enables and disables the vertical stretching. Stretching changes the 
/// HIPAR verticalStretchingEnabled/display of the waveform independent of the vertical scale and position.
/// HIPAR factor/Defines the vertical stretching factor. A factor greater than 1 
/// HIPAR factor/stretches the waveform vertically, a factor lower than 1 compresses the 
/// HIPAR factor/curve.
/// HIPAR offset/Moves the reference waveform vertically. Like vertical offset of 
/// HIPAR offset/channel waveforms, the offset of a reference waveform is subtracted 
/// HIPAR offset/from the measured value.
ViStatus _VI_FUNC rsscope_ConfigureReferenceWaveformVerticalStretching(
    ViSession    instrSession,
    ViInt32        referenceNumber,
    ViBoolean    verticalStretchingEnabled,
    ViReal64    factor,
    ViReal64    offset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_STRETCHING_ENABLED,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_STRETCHING_ENABLED, verticalStretchingEnabled
                                                 ), 3, "Vertical Stretching Enabled");

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_FACTOR, factor
                                                ), 4, "Factor");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_VERTICAL_OFFSET, offset
                                                ), 5, "Offset");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the coupling of horizontal settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
/// HIPAR horizontalCoupling/Selects the coupling of horizontal settings.
ViStatus _VI_FUNC rsscope_ConfigureReferenceWaveformHorizontalScaling(
    ViSession    instrSession,
    ViInt32        referenceNumber,
    ViInt32        horizontalCoupling
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_HORZ_COUPLING,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_REFERENCE_WAVEFORM_HORZ_COUPLING, horizontalCoupling
                                               ), 3, "Horizontal Coupling");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the horizontal stretching of the reference 
/// HIFN  waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR referenceNumber/Selects the reference waveform.
/// HIPAR horizontalStretchingEnabled/Enables and disables the horizontal stretching. Stretching changes the 
/// HIPAR horizontalStretchingEnabled/display of the waveform independent of the horizontal settings of the 
/// HIPAR horizontalStretchingEnabled/source waveform and of the horizontal diagram settings.
/// HIPAR factor/A factor greater than 1 stretches the waveform horizontally, a factor 
/// HIPAR factor/lower than 1 compresses the curve.
/// HIPAR offset/Moves the waveform horizontally. Positive values shift the waveform to 
/// HIPAR offset/the right, negative values shift it to the left.
ViStatus _VI_FUNC rsscope_ConfigureReferenceWaveformHorizontalStretching(
    ViSession    instrSession,
    ViInt32    referenceNumber,
    ViBoolean    horizontalStretchingEnabled,
    ViReal64    factor,
    ViReal64    offset
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar    rep_cap[5] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, referenceNumber, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Reference Number");
    }

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_HORZ_STRETCHING_ENABLED,
                                                 "ReferenceWfm",
                                                 referenceNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Reference Number");       

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_REFERENCE_WAVEFORM_HORZ_STRETCHING_ENABLED,
                                                 horizontalStretchingEnabled), 3, "Horizontal Stretching Enabled");

    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_HORZ_FACTOR, factor
                                                ), 4, "Factor");
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_HORZ_OFFSET, offset
                                                ), 5, "Offset");    
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates an acquisition on the channels that you enable 
/// HIFN  with the rsscope_ConfigureChannel function.  It then waits for the 
/// HIFN  acquisition to complete, and returns the waveform for the channel you 
/// HIFN  specify.  You call the rsscope_FetchWaveform function to obtain the 
/// HIFN  waveforms for each of the remaining enabled channels without initiating 
/// HIFN  another acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveformSize/Pass the number of elements in the Waveform Array parameter.
/// HIPAR maximumTime/Pass the maximum length of time in which to allow the read waveform 
/// HIPAR maximumTime/operation to complete.    
/// HIPAR waveformArray/Returns the waveform that the oscilloscope acquires.  
/// HIPAR actualPoints/Indicates the number of points the function places in the Waveform 
/// HIPAR actualPoints/Array parameter.
/// HIPAR initialX/Indicates the time of the first point in the Waveform Array.  The time 
/// HIPAR initialX/is relative to the trigger event.  
/// HIPAR xIncrement/Indicates the length of time between points in the Waveform Array.  
ViStatus _VI_FUNC rsscope_ReadWaveform(
    ViSession   instrSession,
    ViInt32 channel,
    ViInt32 waveform,
    ViInt32 waveformSize,
    ViInt32 maximumTime,
    ViReal64  waveformArray[],
    ViInt32*    actualPoints,
    ViReal64*   initialX,
    ViReal64*   xIncrement
)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32     oldOPC = 10000;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetOPCTimeout (instrSession, &oldOPC));
    checkErr (
		rsscope_SetOPCTimeout (instrSession, maximumTime));
    checkErr (rsscope_InitiateAcquisition (instrSession, RSSCOPE_VAL_INIT_SINGLE));
    checkErr (rsscope_SetOPCTimeout (instrSession, oldOPC));
    
    checkErr (rsscope_FetchWaveform (instrSession, channel, waveform, waveformSize,
                                     waveformArray, actualPoints, initialX,
                                     xIncrement));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates an acquisition on the channels that you enable 
/// HIFN  with the rsscope_ConfigureChannel function.  It then waits for the 
/// HIFN  acquisition to complete, obtains a main waveform measurement on the channel 
/// HIFN  you specify, and returns the measurement value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR maximumTime/Pass the maximum length of time in which to allow the read waveform 
/// HIPAR maximumTime/operation to complete.    
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_ReadMainWaveformMeasurement (ViSession instrSession,
                                                       ViInt32 measurement,
                                                       ViInt32 statisticType,
                                                       ViInt32 maximumTime,
                                                       ViReal64 *measurementResult)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32     oldOPC = 10000;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetOPCTimeout (instrSession, &oldOPC));
    checkErr (rsscope_SetOPCTimeout (instrSession, maximumTime));
    checkErr (rsscope_InitiateAcquisition (instrSession, RSSCOPE_VAL_INIT_SINGLE));
    
    checkErr (rsscope_FetchMainWaveformMeasurement (instrSession, measurement,
                                                             statisticType,
                                                             measurementResult));
    checkErr (rsscope_SetOPCTimeout (instrSession, oldOPC));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates an acquisition on the channels that you enable 
/// HIFN  with the rsscope_ConfigureChannel function.  It then waits for the 
/// HIFN  acquisition to complete, obtains a waveform measurement on the channel 
/// HIFN  you specify, and returns the measurement value.  You specify a 
/// HIFN  particular measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.  You can call the rsscope_FetchAmplitudeTimeWaveformMeasurement 
/// HIFN  function separately for any other waveform measurement that you want to 
/// HIFN  obtain on a specific channel without initiating another acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR maximumTime/Pass the maximum length of time in which to allow the read waveform 
/// HIPAR maximumTime/operation to complete.    
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_ReadAmplitudeTimeWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViInt32 maximumTime,
    ViReal64*   measurementResult
)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32     oldOPC = 10000;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetOPCTimeout (instrSession, &oldOPC));
    checkErr (rsscope_SetOPCTimeout (instrSession, maximumTime));
    checkErr (rsscope_InitiateAcquisition (instrSession, RSSCOPE_VAL_INIT_SINGLE));
    checkErr (rsscope_SetOPCTimeout (instrSession, oldOPC));
    
    checkErr (rsscope_FetchAmplitudeTimeWaveformMeasurement (instrSession, measurement,
                                                             measurementFunction,
                                                             statisticType,
                                                             measurementResult));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates an acquisition on the channels that you enable 
/// HIFN  with the rsscope_ConfigureChannel function.  It then waits for the 
/// HIFN  acquisition to complete, obtains a waveform measurement on the channel 
/// HIFN  you specify, and returns the measurement value.  You specify a 
/// HIFN  particular measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.  You can call the rsscope_FetchEyeJitterMeasurement 
/// HIFN  function separately for any other waveform measurement that you want to 
/// HIFN  obtain on a specific channel without initiating another acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR maximumTime/Pass the maximum length of time in which to allow the read waveform 
/// HIPAR maximumTime/operation to complete.    
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_ReadEyeJitterWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViInt32 maximumTime,
    ViReal64*   measurementResult
)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32     oldOPC = 10000;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetOPCTimeout (instrSession, &oldOPC));
    checkErr (rsscope_SetOPCTimeout (instrSession, maximumTime));
    checkErr (rsscope_InitiateAcquisition (instrSession, RSSCOPE_VAL_INIT_SINGLE));
    checkErr (rsscope_SetOPCTimeout (instrSession, oldOPC));
    
    checkErr (rsscope_FetchEyeJitterWaveformMeasurement (instrSession, measurement,
                                                         measurementFunction,
                                                         statisticType,
                                                         measurementResult));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates an acquisition on the channels that you enable 
/// HIFN  with the rsscope_ConfigureChannel function.  It then waits for the 
/// HIFN  acquisition to complete, obtains a waveform measurement on the channel 
/// HIFN  you specify, and returns the measurement value.  You specify a 
/// HIFN  particular measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.  You can call the rsscope_FetchHistogramMeasurement 
/// HIFN  function separately for any other waveform measurement that you want to 
/// HIFN  obtain on a specific channel without initiating another acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR maximumTime/Pass the maximum length of time in which to allow the read waveform 
/// HIPAR maximumTime/operation to complete.    
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_ReadHistogramWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViInt32 maximumTime,
    ViReal64*   measurementResult
)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32     oldOPC = 10000;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetOPCTimeout (instrSession, &oldOPC));
    checkErr (rsscope_SetOPCTimeout (instrSession, maximumTime));
    checkErr (rsscope_InitiateAcquisition (instrSession, RSSCOPE_VAL_INIT_SINGLE));
    checkErr (rsscope_SetOPCTimeout (instrSession, oldOPC));
    
    checkErr (rsscope_FetchHistogramWaveformMeasurement (instrSession, measurement,
                                                         measurementFunction,
                                                         statisticType,
                                                         measurementResult));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates an acquisition on the channels that you enable 
/// HIFN  with the rsscope_ConfigureChannel function.  It then waits for the 
/// HIFN  acquisition to complete, obtains a waveform measurement on the channel 
/// HIFN  you specify, and returns the measurement value.  You specify a 
/// HIFN  particular measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.  You can call the rsscope_FetchSpectrumMeasurement 
/// HIFN  function separately for any other waveform measurement that you want to 
/// HIFN  obtain on a specific channel without initiating another acquisition.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR maximumTime/Pass the maximum length of time in which to allow the read waveform 
/// HIPAR maximumTime/operation to complete.    
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_ReadSpectrumWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViInt32 maximumTime,
    ViReal64*   measurementResult
)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32     oldOPC = 10000;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetOPCTimeout (instrSession, &oldOPC));
    checkErr (rsscope_SetOPCTimeout (instrSession, maximumTime));
    checkErr (rsscope_InitiateAcquisition (instrSession, RSSCOPE_VAL_INIT_SINGLE));
    checkErr (rsscope_SetOPCTimeout (instrSession, oldOPC));
    
    checkErr (rsscope_FetchSpectrumWaveformMeasurement (instrSession, measurement,
                                                        measurementFunction,
                                                        statisticType,
                                                        measurementResult));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns selected reference level measurement.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR levelType/Selects level type to be read.
/// HIPAR referenceLevelResult/Returns the reference level value based on the selected Level Type 
/// HIPAR referenceLevelResult/cotrol.
ViStatus _VI_FUNC rsscope_ReadReferenceLevelResult(
    ViSession    instrSession,
    ViInt32        measurement,
    ViInt32        levelType,
    ViReal64*    referenceLevelResult
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap_m[5] = "";
    ViChar      rep_cap_l[20] = "";
    ViChar      rep_cap[32] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_RESULT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 5,
                                                 rep_cap_m), 2, "Measurement");
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_REFERENCE_LEVEL_RESULT,
                                                 "RefLevelMeas",
                                                 levelType,
                                                 20,
                                                 rep_cap_l), 3, "Level Type");    
    
    strcpy (rep_cap, rep_cap_m);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_l);
    
    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_REFERENCE_LEVEL_RESULT, referenceLevelResult), 4, "Reference Level Result");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function initiates a waveform acquisition.  After you call this 
/// HIFN  function, the oscilloscope leaves the Idle state and waits for a 
/// HIFN  trigger.  The oscilloscope acquires a waveform for each channel you 
/// HIFN  have enabled with the  rsscope_ConfigureChannel function.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR action/Select action to be performed.
ViStatus _VI_FUNC rsscope_InitiateAcquisition(
    ViSession   instrSession,
    ViInt32 action
)
{
    ViStatus    error = VI_SUCCESS;
    ViUInt32    attr = RSSCOPE_ATTR_RUN_SINGLE;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    switch (action)
    {
        case RSSCOPE_VAL_INIT_SINGLE:
            attr = RSSCOPE_ATTR_RUN_SINGLE;
            break;
        case RSSCOPE_VAL_INIT_CONTINUOUS:
            attr = RSSCOPE_ATTR_RUN_CONTINUOUS;
            break;
        case RSSCOPE_VAL_INIT_FORCE:
            attr = RSSCOPE_ATTR_FORCE;
            break;
        default:
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Action");
    }

    viCheckErr (rsscope_SetAttributeViString (instrSession, "", attr, NULL));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Sends software trigger and waits for operation complete.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR maximumTime/Pass the maximum length of time (in milliseconds) in which to allow 
/// HIPAR maximumTime/the read waveform operation to complete.    
ViStatus _VI_FUNC rsscope_SendSoftwareTrigger(
    ViSession   instrSession,
    ViInt32 maximumTime
)
{
    ViStatus    error = VI_SUCCESS;
    ViInt32     timeout = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    checkErr (rsscope_GetAttributeViInt32 (instrSession, "",
                                           RS_ATTR_OPC_TIMEOUT, &timeout));
    checkErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                           RS_ATTR_OPC_TIMEOUT, maximumTime));
    
    viCheckErr (rsscope_SetAttributeViString (instrSession, "",
                                              RSSCOPE_ATTR_SEND_SW_TRIGGER_AND_WAIT,
                                              NULL));

Error:
    checkErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                           RS_ATTR_OPC_TIMEOUT, timeout));
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the waveform the oscilloscope acquires for the 
/// HIFN  channel you specify.  The waveform is from an acquisition that you 
/// HIFN  previously initiated.  
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/Selects the waveform.
/// HIPAR waveformSize/Pass the number of elements in the Waveform Array parameter.
/// HIPAR waveformArray/Returns the waveform that the oscilloscope acquires.  
/// HIPAR actualPoints/Indicates the number of points the function places in the Waveform 
/// HIPAR actualPoints/Array parameter.
/// HIPAR initialX/Indicates the time of the first point in the Waveform Array.  The time 
/// HIPAR initialX/is relative to the trigger event.  
/// HIPAR xIncrement/Indicates the length of time between points in the Waveform Array.  
ViStatus _VI_FUNC rsscope_FetchWaveform(
    ViSession   instrSession,
    ViInt32 channel,
    ViInt32 waveform,
    ViInt32 waveformSize,
    ViReal64    waveformArray[],
    ViInt32*    actualPoints,
    ViReal64*   initialX,
    ViReal64*   xIncrement
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   header[RSSCOPE_IO_BUFFER_SIZE] = "";
    initialX;
    xIncrement;
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    // Use header to fetch horizontal parameters
    // reuse 'header', it's no longer needed
    // range checking of 'channel' and 'waveform' already done in rsscope_FetchWaveformHeader
    sprintf (header, ":CHAN%ld:WAV%ld:DATA?", channel, waveform);
    checkErr (rsscope_dataReadTrace (instrSession, header, waveformSize, waveformArray, actualPoints));
    checkErr (rsscope_CheckStatus (instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the header of channel waveform data. The header contains setup 
/// HIFN  and acquisition settings.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR waveform/Selects the waveform.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Waveform Header'.
/// HIPAR waveformHeader/Returns the header of channel waveform data. The header contains setup 
/// HIPAR waveformHeader/and acquisition settings.
ViStatus _VI_FUNC rsscope_FetchWaveformHeader(
    ViSession   instrSession,
    ViInt32 channel,
    ViInt32 waveform,
    ViInt32 bufferSize,
    ViChar  waveformHeader[]
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_channel[25] = "";
    ViChar   rep_cap_waveform[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (channel > RSSCOPE_VAL_CHANNEL4)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WAVEFORM_HEADER,
                                                 "Channel",
                                                 channel-1,
                                                 25,
                                                 rep_cap_channel), 2, "Channel");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_WAVEFORM_HEADER,
                                                 "Waveform",
                                                 waveform,
                                                 25,
                                                 rep_cap_waveform), 3, "Waveform");

    strcpy (rep_cap, rep_cap_channel);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_waveform);

    viCheckParm(rsscope_GetAttributeViString(instrSession, rep_cap,
        RSSCOPE_ATTR_WAVEFORM_HEADER, bufferSize, waveformHeader), 5, "Waveform Header");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the data of the math waveform points.  
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR mathNumber/Selects the math waveform.
/// HIPAR waveformSize/Pass the number of elements in the Waveform Array parameter.
/// HIPAR waveformArray/Returns the vertical values - voltages of recorded waveform samples, 
/// HIPAR waveformArray/or magnitudes of a spectrum.  
/// HIPAR actualPoints/Indicates the number of points the function places in the Waveform 
/// HIPAR actualPoints/Array parameter.
ViStatus _VI_FUNC rsscope_FetchMathWaveform(
    ViSession    instrSession,
    ViInt32        mathNumber,
    ViInt32        waveformSize,
    ViReal64    waveformArray[],
    ViInt32*    actualPoints
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   header[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar   *p2buf  = NULL;
    ViChar   *p2data  = NULL;
    ViUInt32 count = 0;
    ViInt32  i = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    sprintf (header, "CALC:MATH%d:DATA?", mathNumber);
    checkErr (viWrite (instrSession, (ViBuf) header, (ViUInt32) strlen (header), NULL));
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2data, &count));
    checkErr (rsscope_CheckStatus (instrSession));
    
    p2buf = strtok (p2data, ",");
    while (p2buf && (i < waveformSize))
    {
        if (i<waveformSize)
            waveformArray[i++] = atof (p2buf);
        else
            i++;
        p2buf = strtok (NULL, ",");
    }
    *actualPoints = i;
    
Error:
    if (p2data) free (p2data);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the header of math waveform data. The header contains  
/// HIFN  attributes of the waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Waveform Header'.
/// HIPAR mathWaveformHeader/Returns the header of math waveform data. The header contains 
/// HIPAR mathWaveformHeader/attributes of the waveform.
ViStatus _VI_FUNC rsscope_FetchMathWaveformHeader(
    ViSession    instrSession,
    ViInt32        mathNumber,
    ViInt32        bufferSize,
    ViChar        mathWaveformHeader[]
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar   rep_cap[5] = "";
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_FFT_GATE_DISPLAY_ENABLED,
                                                 "Math",
                                                 mathNumber - 1,
                                                 5,
                                                 rep_cap), 2, "Math Number");       

    viCheckParm (rsscope_GetAttributeViString (instrSession, rep_cap,
                                                RSSCOPE_ATTR_MATH_WAVEFORM_HEADER,
                                                bufferSize,
                                                mathWaveformHeader), 3, "Math Waveform Header");    

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the data of the reference waveform points.  

/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR waveformSize/Pass the number of elements in the Waveform Array parameter.
/// HIPAR waveformArray/Returns the vertical values - voltages of recorded waveform samples, 
/// HIPAR waveformArray/or magnitudes of a spectrum.  
/// HIPAR actualPoints/Indicates the number of points the function places in the Waveform 
/// HIPAR actualPoints/Array parameter.
ViStatus _VI_FUNC rsscope_FetchReferenceWaveform(
    ViSession    instrSession,
    ViInt32        waveformSize,
    ViReal64    waveformArray[],
    ViInt32*    actualPoints
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   header[RSSCOPE_IO_BUFFER_SIZE] = "REFC:DATA?";
    ViChar   *p2buf  = NULL;
    ViChar   *p2data  = NULL;
    ViUInt32 count = 0;
    ViInt32  i = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));    
    
    checkErr (viWrite (instrSession, (ViBuf) header, (ViUInt32) strlen (header), NULL));
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2data, &count));
    checkErr (rsscope_CheckStatus (instrSession));
    
    p2buf = strtok (p2data, ",");
    while (p2buf && (i < waveformSize))
    {
        if (i<waveformSize)
            waveformArray[i++] = atof (p2buf);
        else
            i++;
        p2buf = strtok (NULL, ",");
    }
    *actualPoints = i;
    
Error:
    if (p2data) free (p2data);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the header of reference waveform data. The header contains 
/// HIFN  scaling and original attributes of the waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bufferSize/Defines the size of buffer passed to 'Waveform Header'.
/// HIPAR referenceWaveformHeader/Returns the header of reference waveform data. The header contains 
/// HIPAR referenceWaveformHeader/scaling and original attributes of the waveform.
ViStatus _VI_FUNC rsscope_FetchReferenceWaveformHeader(
    ViSession    instrSession,
    ViInt32        bufferSize,
    ViChar        referenceWaveformHeader[]
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeViString (instrSession, "",
                                                RSSCOPE_ATTR_REFERENCE_WAVEFORM_HEADER,
                                                bufferSize,
                                                referenceWaveformHeader), 3, "Reference Waveform Header");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function obtains a main waveform measurement on the channel you 
/// HIFN  specify, and returns the measurement value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_FetchMainWaveformMeasurement (ViSession instrSession,
                                                ViInt32 measurement,
                                                ViInt32 statisticType,
                                                ViReal64 *measurementResult)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_measurement[25] = "";
    ViChar   rep_cap_stat_type[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MAIN_MEASUREMENT_RESULT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MAIN_MEASUREMENT_RESULT,
                                                 "ResultType",
                                                 statisticType,
                                                 25,
                                                 rep_cap_stat_type), 4, "Statistic Type");

    strcpy (rep_cap, rep_cap_measurement);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_stat_type);

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_MAIN_MEASUREMENT_RESULT, measurementResult), 5, "Measurement Result");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function obtains a waveform measurement on the channel you 
/// HIFN  specify, and returns the measurement value.  You specify a particular 
/// HIFN  measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_FetchAmplitudeTimeWaveformMeasurement(
    ViSession   instrSession,
    ViInt32     measurement,
    ViInt32     measurementFunction,
    ViInt32     statisticType,
    ViReal64*   measurementResult
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_measurement[25] = "";
    ViChar   rep_cap_meas_function[25] = "";
    ViChar   rep_cap_stat_type[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_MEASUREMENT_RESULT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_MEASUREMENT_RESULT,
                                                 "AmptMeasurementResult",
                                                 measurementFunction - 1,
                                                 25,
                                                 rep_cap_meas_function), 3, "Measurement Function");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_AMPT_MEASUREMENT_RESULT,
                                                 "ResultType",
                                                 statisticType,
                                                 25,
                                                 rep_cap_stat_type), 4, "Statistic Type");

    strcpy (rep_cap, rep_cap_measurement);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_stat_type);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_meas_function);

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_AMPT_MEASUREMENT_RESULT, measurementResult), 5, "Amplitude Time Measurement Result");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function obtains a waveform measurement on the channel you 
/// HIFN  specify, and returns the measurement value.  You specify a particular 
/// HIFN  measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_FetchEyeJitterWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViReal64*   measurementResult
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_measurement[25] = "";
    ViChar   rep_cap_stat_type[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_MEASUREMENT_RESULT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");

    if ((measurementFunction < RSSCOPE_VAL_MEAS_EXTINCTION_RATIO_PCT) ||
        ((measurementFunction > RSSCOPE_VAL_MEAS_EYE_BASE) && (measurementFunction < RSSCOPE_VAL_MEAS_Q_FACTOR)) ||
        ((measurementFunction > RSSCOPE_VAL_MEAS_Q_FACTOR) && (measurementFunction < RSSCOPE_VAL_MEAS_RMS_NOISE)) ||
        ((measurementFunction > RSSCOPE_VAL_MEAS_EYE_AMPLITUDE) && (measurementFunction < RSSCOPE_VAL_MEAS_PEAK_TO_PEAK_JITTER)) ||
        (measurementFunction > RSSCOPE_VAL_MEAS_RMS_JITTER))
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Measurement Function");
    }
        
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_EYE_MEASUREMENT_RESULT,
                                                 "ResultType",
                                                 statisticType,
                                                 25,
                                                 rep_cap_stat_type), 4, "Statistic Type");

    strcpy (rep_cap, rep_cap_measurement);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_stat_type);
    strcat (rep_cap, ",");
    strcat (rep_cap, eyeMeasArr[measurementFunction]);

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_EYE_MEASUREMENT_RESULT, measurementResult), 5, "Amplitude Time Measurement Result");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function obtains a waveform measurement on the channel you 
/// HIFN  specify, and returns the measurement value.  You specify a particular 
/// HIFN  measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_FetchHistogramWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViReal64*   measurementResult
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_measurement[25] = "";
    ViChar   rep_cap_meas_function[25] = "";
    ViChar   rep_cap_stat_type[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_MEASUREMENT_RESULT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_MEASUREMENT_RESULT,
                                                 "HistogramMeasurementResult",
                                                 measurementFunction - 1,
                                                 25,
                                                 rep_cap_meas_function), 3, "Measurement Function");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_HISTOGRAM_MEASUREMENT_RESULT,
                                                 "ResultType",
                                                 statisticType,
                                                 25,
                                                 rep_cap_stat_type), 4, "Statistic Type");

    strcpy (rep_cap, rep_cap_measurement);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_stat_type);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_meas_function);

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_HISTOGRAM_MEASUREMENT_RESULT, measurementResult), 5, "Amplitude Time Measurement Result");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function obtains a waveform measurement on the channel you 
/// HIFN  specify, and returns the measurement value.  You specify a particular 
/// HIFN  measurement type, such as rise time, frequency, and voltage 
/// HIFN  peak-to-peak.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR measurement/Selects waveform measurement.
/// HIPAR measurementFunction/Selects measurement to be read.
/// HIPAR measurementResult/Returns the measured value.  
/// HIPAR statisticType/Select statistic result of measurement to be read.
ViStatus _VI_FUNC rsscope_FetchSpectrumWaveformMeasurement(
    ViSession   instrSession,
    ViInt32 measurement,
    ViInt32 measurementFunction,
    ViInt32 statisticType,
    ViReal64*   measurementResult
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_measurement[25] = "";
    ViChar   rep_cap_meas_function[25] = "";
    ViChar   rep_cap_stat_type[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_MEASUREMENT_RESULT,
                                                 "Measurement",
                                                 measurement - 1,
                                                 25,
                                                 rep_cap_measurement), 2, "Measurement");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_MEASUREMENT_RESULT,
                                                 "SpectrumMeasurementResult",
                                                 measurementFunction - 1,
                                                 25,
                                                 rep_cap_meas_function), 3, "Measurement Function");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_SPECTRUM_MEASUREMENT_RESULT,
                                                 "ResultType",
                                                 statisticType,
                                                 25,
                                                 rep_cap_stat_type), 4, "Statistic Type");

    strcpy (rep_cap, rep_cap_measurement);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_stat_type);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_meas_function);

    viCheckParm(rsscope_GetAttributeViReal64(instrSession, rep_cap,
        RSSCOPE_ATTR_SPECTRUM_MEASUREMENT_RESULT, measurementResult), 5, "Amplitude Time Measurement Result");
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function aborts an acquisition and returns the oscilloscope to 
/// HIFN  the Idle state.  You initiate an acquisition with the 
/// HIFN  rsscope_InitiateAcquisition function.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
ViStatus _VI_FUNC rsscope_Abort(
    ViSession   instrSession
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (rsscope_SetAttributeViString (instrSession, "",
                                              RSSCOPE_ATTR_STOP, NULL));
Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function enables the indicated parallel bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR state/Enables the indicated parallel bus.
ViStatus _VI_FUNC rsscope_ConfigureMSOBusState (ViSession instrSession,
                                                ViInt32 serialBus,
                                                ViBoolean state)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_BUS_STATE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 15,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_BUS_STATE,
                                                 state), 3, "State");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures display settings of the indicated parallel bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR showDigitalSignals/If enabled, the selected digital signals are shown in the diagram.
/// HIPAR showBus/Shows or hides the indicated parallel bus.
/// HIPAR busRepresentation/Selects the display type of the indicated parallel bus.
ViStatus _VI_FUNC rsscope_ConfigureMSOVisualization (ViSession instrSession,
                                                     ViInt32 serialBus,
                                                     ViBoolean showDigitalSignals,
                                                     ViBoolean showBus,
                                                     ViInt32 busRepresentation)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      rep_cap_bus[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_DISPLAY_SHOW_SETTINGS,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap_bus), 2, "Serial Bus");
	strcpy (rep_cap, rep_cap_bus);
	strcat (rep_cap, ",Signals");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_DISPLAY_SHOW_SETTINGS,
                                                 showDigitalSignals), 3, "Show Digital Signals");
	
	strcpy (rep_cap, rep_cap_bus);
	strcat (rep_cap, ",Bus");
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_DISPLAY_SHOW_SETTINGS,
                                                 showBus), 3, "Show Bus");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap_bus,
                                                 RSSCOPE_ATTR_MSO_DISPLAY_REPRESENTATION,
                                                 busRepresentation), 3, "Bus Representation");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Defines if the bus is a clocked bus - one of the digital channels 
/// HIFN  serves as clock of the bus.     
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bus/This control selects the bus.
/// HIPAR enableClockedBus/Defines if the bus is a clocked bus - one of the digital channels 
/// HIPAR enableClockedBus/serves as clock of the bus.
ViStatus _VI_FUNC rsscope_ConfigureMSOClockedBusState (ViSession instrSession,
                                                       ViInt32 bus,
                                                       ViBoolean enableClockedBus)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, bus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_2) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_CLOCKED_BUS_STATE,
                                                 "SerialBus",
                                                 bus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_CLOCKED_BUS_STATE,
                                                 enableClockedBus), 3, "Enable Clocked Bus");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function selects the digital channel used as clock of the indicated parallel bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR clockSource/Selects the digital channel used as clock of the indicated parallel bus.
ViStatus _VI_FUNC rsscope_ConfigureMSOClockedBus (ViSession instrSession,
                                                  ViInt32 serialBus,
                                                  ViInt32 clockSource)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_CLOCKED_BUS,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_CLOCKED_BUS,
                                                 clockSource), 3, "Clock Source");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Selects the slope of the clock signal at which all digital channels of 
/// HIFN  the bus are analyzed.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bus/This control selects the bus.
/// HIPAR clockSlope/Selects the slope of the clock signal at which all digital channels of 
/// HIPAR clockSlope/the bus are analyzed.
ViStatus _VI_FUNC rsscope_ConfigureMSOClockedBusSlope (ViSession instrSession,
                                                       ViInt32 bus,
                                                       ViInt32 clockSlope)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    if (rsscope_invalidViInt32Range (instrSession, bus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_2) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_CLOCKED_BUS_SLOPE,
                                                 "SerialBus",
                                                 bus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_CLOCKED_BUS_SLOPE,
                                                 clockSlope != 0), 3, "Clock Slope");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function assigns the selected digital channel to the indicated bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR assignState/Assigns the selected digital channel to the indicated bus.
ViStatus _VI_FUNC rsscope_ConfigureMSOAssignChannels (ViSession instrSession,
                                                      ViInt32 serialBus,
                                                      ViInt32 digitalChannel,
                                                      ViBoolean assignState)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      rep_cap_channel[5] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_ASSIGN_STATE,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 20,
                                                 rep_cap), 2, "Serial Bus");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_ASSIGN_STATE,
                                                 "DigitalChannel",
                                                 digitalChannel,
                                                 5,
                                                 rep_cap_channel), 3, "Digital Channel");
	
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_channel);
	
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_ASSIGN_STATE,
                                                 assignState), 4, "Assign State");
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function selects and configure the digital channels that are used in the selected bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR label/Sets a name for the indicated digital channel.
/// HIPAR deskew/Sets an individual delay for each digital channel to time-align it with other digital channels.
ViStatus _VI_FUNC rsscope_ConfigureMSOSignalSelection (ViSession instrSession,
                                                       ViInt32 digitalChannel,
                                                       ViString label,
                                                       ViReal64 deskew)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_LABEL,
                                                 "DigitalChannel",
                                                 digitalChannel,
                                                 20,
                                                 rep_cap), 2, "Digital Channel");
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_DESKEW,
                                                 deskew), 4, "Deskew");

	viCheckParm (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_LABEL,
                                                 label), 3, "Label");
	
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function sets a general delay for all digital channels.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bus/This control selects the bus.
/// HIPAR deskew/Sets a general delay for all digital channels.
ViStatus _VI_FUNC rsscope_ConfigureMSODeskew (ViSession instrSession,
                                              ViInt32 bus, ViReal64 deskew)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_DESKEW_ALL_CHANNELS,
                                                 "SerialBus",
                                                 bus - 1,
                                                 20,
                                                 rep_cap), 2, "Bus");
	
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_SIGNAL_DESKEW_ALL_CHANNELS,
                                                 deskew), 4, "Deskew");
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function sets the threshold voltage for various types of 
/// HIFN  integrated circuits and applies it to all digital channels.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR technology/Selects the threshold voltage for various types of integrated circuits 
/// HIPAR technology/and applies it to all digital channels.
ViStatus _VI_FUNC rsscope_ConfigureMSOTechnology (ViSession instrSession,
                                                  ViInt32 digitalChannel,
                                                  ViInt32 technology)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_TECHNOLOGY,
                                                 "DigitalChannel",
                                                 digitalChannel,
                                                 20,
                                                 rep_cap), 2, "Digital Channel");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_TECHNOLOGY,
                                                 technology), 4, "Technology"); 
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function sets the logical threshold and hysteresis.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR treshold/Sets the logical threshold for the indicated digital channel.
/// HIPAR hysteresis/This control defines the size of the hysteresis to avoid the
/// HIPAR hysteresis/change of signal states due to noise.
ViStatus _VI_FUNC rsscope_ConfigureMSOTresholdSetup (ViSession instrSession,
                                                     ViInt32 digitalChannel,
                                                     ViReal64 treshold,
                                                     ViInt32 hysteresis)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_TRESHOLD,
                                                 "DigitalChannel",
                                                 digitalChannel,
                                                 20,
                                                 rep_cap), 2, "Digital Channel");
	
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_TRESHOLD,
                                                 treshold), 3, "treshold");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_HYSTERESIS,
                                                 hysteresis), 4, "hysteresis");
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function sets the logical threshold and hysteresis.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bus/This control selects the bus.
/// HIPAR treshold/Sets the logical threshold for the indicated channel group.
/// HIPAR channelGroup/This control selects the channel group for treshold and hystersis.
/// HIPAR hysteresis/This control defines the size of the hysteresis for the channel group 
/// HIPAR hysteresis/to avoid the change of signal states due to noise.
/// HIPAR technology/Selects the threshold voltage for various types of integrated circuits 
/// HIPAR technology/and applies it to all digital channels.
ViStatus _VI_FUNC rsscope_ConfigureMSOTresholdAllChannels (ViSession instrSession,
                                                           ViInt32 bus,
                                                           ViInt32 technology,
                                                           ViInt32 channelGroup,
                                                           ViReal64 treshold,
                                                           ViInt32 hysteresis)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      rep_cap_group[20] = "";
	

    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_TECHNOLOGY_ALL_CHANNELS,
                                                 "SerialBus",
                                                 bus - 1,
                                                 20,
                                                 rep_cap), 2, "Serial Bus");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_TRESHOLD_ALL_CHANNELS,
                                                 "ChannelGroup",
                                                 channelGroup - 1,
                                                 20,
                                                 rep_cap_group), 4, "Digital Channel");
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_TECHNOLOGY_ALL_CHANNELS,
                                                 technology), 3, "technology");
	
	strcat (rep_cap, ",");
	strcat (rep_cap, rep_cap_group);
	
	if (technology == RSSCOPE_VAL_MAN)
	{
		viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_TRESHOLD_ALL_CHANNELS,
                                                 treshold), 5, "treshold");
	}
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_HYSTERESIS_ALL_CHANNELS,
                                                 hysteresis), 6, "hysteresis");
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function enables the channel coupling.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR serialBus/This control selects the serial bus.
/// HIPAR coupling/Enables the channel coupling.
ViStatus _VI_FUNC rsscope_ConfigureMSOChannelCoupling (ViSession instrSession,
                                                       ViInt32 serialBus,
                                                       ViBoolean coupling)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_CHANNEL_COUPLING,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_CHANNEL_COUPLING,
                                                 coupling), 3, "Coupling");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function removes all assigned digital channels from the bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR serialBus/This control selects the serial bus.
ViStatus _VI_FUNC rsscope_MSORemoveAllAssignedChannels (ViSession instrSession,
                                                        ViInt32 serialBus)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[15] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    if (rsscope_invalidViInt32Range (instrSession, serialBus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_CHANNEL_COUPLING,
                                                 "SerialBus",
                                                 serialBus - 1,
                                                 5,
                                                 rep_cap), 2, "Serial Bus");
	
    viCheckErr (rsscope_SetAttributeViString (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_REMOVE_ALL_ASSIGNED_CHANNELS,
                                                 NULL));

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function reads signals from defined digital channel
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR arraySize/Pass the number of elements in the Signal Array parameter.
/// HIPAR maximumTime/Maximum length of time in which to allow the read waveformoperation to complete
/// HIPAR signalArray/Returns the signal data (zeroes and ones).
/// HIPAR actualPoints/Indicates the number of points the function places in the Signal Array parameter.
ViStatus _VI_FUNC rsscope_ReadSignals (ViSession instrSession,
                                       ViInt32 digitalChannel, ViUInt32 arraySize,
                                       ViInt32 maximumTime,
                                       ViBoolean signalArray[],
                                       ViInt32 *actualPoints)
{
	ViChar *extBuf = NULL;
	ViChar *p2buf = NULL;
	ViUInt32 ret_cnt = 0;
	ViUInt32 old_timeout = 0;
	ViStatus	error = VI_SUCCESS;
	ViUInt32 i = 0;

	viCheckErr (rsscope_GetOPCTimeout (instrSession, &old_timeout));
	viCheckErr (rsscope_SetOPCTimeout (instrSession, maximumTime));
	viCheckErr (viPrintf (instrSession, ":FORM ASC;*CLS\n"));
	viCheckErr (viPrintf (instrSession, "DIG%ld:DATA?;*OPC\n", digitalChannel));
	viCheckErr (rsscope_WaitForOPCCallback (instrSession));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt));
	viCheckErr (rsscope_CheckStatus(instrSession));

	p2buf = strtok (extBuf, ",");
	while (p2buf) 
    {
        if (i < arraySize)
        {
            signalArray[i] = (ViBoolean) atol (p2buf);
        }   
        p2buf = strtok(NULL, ",");  
        i++;
    }
	*actualPoints = i;

Error:
	if (extBuf) free (extBuf);
	rsscope_SetOPCTimeout (instrSession, old_timeout);
	return error;
}

/// HIFN This function configures MSO trigger type.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerType/Selects the MSO trigger type.
ViStatus _VI_FUNC rsscope_ConfigureMSOTrigger (ViSession instrSession,
                                               ViInt32 triggerType)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_TYPE,
                                                 triggerType), 2, "Trigger Type");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function defines the edge - the state transition - of the signal to trigger on a single digital
/// HIFN channel (a logic bit), or a logical combination of digital channels.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR triggerSlope/Sets the slope for the MSO edge trigger.
/// HIPAR expression/Defines a logical combination of several digital channels as trigger condition.
ViStatus _VI_FUNC rsscope_ConfigureMSOEdgeTriggerSource (ViSession instrSession,
                                                         ViInt32 triggerSource,
                                                         ViInt32 triggerSlope,
                                                         ViString expression)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_EDGE_TRIGGER_SLOPE,
                                                 triggerSlope), 3, "Trigger Slope");
	
	if (triggerSource == RSSCOPE_VAL_MSO_DALL)
		viCheckParm (rsscope_SetAttributeViString (instrSession, "Edge",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_EXPRESSION,
                                                 expression), 4, "Expression");

Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures the MSO width trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR widthPolarity/Sets the polarity of the pulse.
/// HIPAR widthCondition/Selects how the range of a pulse width is defined.
/// HIPAR width/For the ranges "Within" and "Outside", the width defines the center of a range which 
/// HIPAR width/is defined by the limits "+/-Delta". For the ranges "Shorter" and "Longer", 
/// HIPAR width/the width defines the maximum and minimum pulse width, respectively.
/// HIPAR widthDelta/Defines a range around the width value.
/// HIPAR expression/Defines a logical combination of several digital channels as trigger condition.
ViStatus _VI_FUNC rsscope_ConfigureMSOWidthTriggerSource (ViSession instrSession,
                                                          ViInt32 triggerSource,
                                                          ViInt32 widthPolarity,
                                                          ViInt32 widthCondition,
                                                          ViReal64 width,
                                                          ViReal64 widthDelta,
                                                          ViString expression)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_WIDTH_TRIGGER_POLARITY,
                                                 widthPolarity), 3, "Width Polarity");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_WIDTH_TRIGGER_CONDITION,
                                                 widthCondition), 4, "Width Condition"); 
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_WIDTH_TRIGGER_WIDTH,
                                                 width), 5, "Width");
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_WIDTH_TRIGGER_DELTA,
                                                 widthDelta), 6, "Width Delta");
	
	if (triggerSource == RSSCOPE_VAL_MSO_DALL)
		viCheckParm (rsscope_SetAttributeViString (instrSession, "Width",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_EXPRESSION,
                                                 expression), 7, "Expression");

Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures the MSO timeout trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR expression/Defines a logical combination of several digital channels as trigger condition
/// HIPAR timeoutValue/Defines the time limit for the timeout at which the instrument triggers.
/// HIPAR timeoutCondition/Defines the relation of the signal level to the trigger level.
ViStatus _VI_FUNC rsscope_ConfigureMSOTimeoutTriggerSource (ViSession instrSession,
                                                            ViInt32 triggerSource,
                                                            ViReal64 timeoutValue,
                                                            ViInt32 timeoutCondition,
															ViString expression)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");

	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TIMEOUT_TRIGGER_VALUE,
                                                 timeoutValue), 3, "Timeout Value");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TIMEOUT_TRIGGER_CONDITION,
                                                 timeoutCondition), 4, "Timeout Condition"); 

	if (triggerSource == RSSCOPE_VAL_MSO_DALL)
		viCheckParm (rsscope_SetAttributeViString (instrSession, "Timeout",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_EXPRESSION,
                                                 expression), 5, "Expression");

Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures the Data2Clock trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR clockSource/Sets the clock signal source.
/// HIPAR data2ClockPolarity/Sets the edge of the clock signal to define the time reference 
/// HIPAR data2ClockPolarity/point for the setup and hold time.
/// HIPAR holdTime/Sets the minimum time after the clock edge while the data signal must stay 
/// HIPAR holdTime/steady above or below the data level.
/// HIPAR setupTime/Sets the minimum time before the clock edge while the data
/// HIPAR setupTime/signal must stay steady above or below the data level.
ViStatus _VI_FUNC rsscope_ConfigureMSOData2ClockTriggerSource (ViSession instrSession,
                                                               ViInt32 triggerSource,
                                                               ViInt32 clockSource,
                                                               ViInt32 data2ClockPolarity,
                                                               ViReal64 holdTime,
                                                               ViReal64 setupTime)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "Data2Clock",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_CLOCK_SOURCE,
                                                 clockSource), 3, "Clock Source");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "Data2Clock",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_POLARITY,
                                                 data2ClockPolarity), 4, "Data2Clock Polarity"); 
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_DATA2CLOCK_TRIGGER_HOLD_TIME,
                                                 holdTime), 5, "Hold Time");
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_DATA2CLOCK_TRIGGER_SETUP_TIME,
                                                 setupTime), 6, "Setup Time");  

Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures MSO state trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR clockSource/Sets the edge of the clock signal to define the time reference
/// HIPAR clockSource/point for the setup and hold time.
/// HIPAR clockPolarity/Document parameter here.
/// HIPAR expression/Defines a logical combination of several digital channels as trigger condition 
ViStatus _VI_FUNC rsscope_ConfigureMSOStateTriggerSource (ViSession instrSession,
                                                          ViInt32 triggerSource,
                                                          ViInt32 clockSource,
                                                          ViInt32 clockPolarity,
                                                          ViString expression)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");

	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "State",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_CLOCK_SOURCE,
                                                 clockSource), 3, "Clock Source");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "State",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_POLARITY,
                                                 clockPolarity), 4, "Clock Polarity"); 

	if (triggerSource == RSSCOPE_VAL_MSO_DALL)
		viCheckParm (rsscope_SetAttributeViString (instrSession, "State",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_EXPRESSION,
                                                 expression), 5, "Expression");

Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function sets the required state for each digital channel that is used in the bus..
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR triggerType/Sets the MSO trigger type.
/// HIPAR statusBit/Sets the required state for each digital channel that is used in the bus.
ViStatus _VI_FUNC rsscope_ConfigureMSOTriggerChannelState (ViSession instrSession,
                                                           ViInt32 digitalChannel,
                                                           ViInt32 triggerType,
                                                           ViInt32 statusBit)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      rep_cap[20] = "";
	ViChar      rep_cap_channel[20] = "";
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
	if (rsscope_invalidViInt32Range (instrSession, triggerType, RSSCOPE_VAL_MSO_STATE_TRIGGER, RSSCOPE_VAL_MSO_PATTERN_TRIGGER) == VI_TRUE)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Trigger Type");
    
	if (triggerType == RSSCOPE_VAL_MSO_STATE_TRIGGER)
		sprintf (rep_cap, "State,");
	else
		sprintf (rep_cap, "Pattern,");
	
	viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_MSO_TRIGGER_CHANNEL_STATUS_BIT,
                                                 "DigitalChannel",
                                                 digitalChannel,
                                                 20,
                                                 rep_cap_channel), 2, "Digital Channel");
	
	strcat (rep_cap, rep_cap_channel);
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                                 RSSCOPE_ATTR_MSO_TRIGGER_CHANNEL_STATUS_BIT,
                                                 statusBit), 4, "Status Bit");
	
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function defines the MSO pattern trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR patternMode/Sets the mode of the timing condition.
/// HIPAR timeoutCondition/Sets the state condition for the timeout qualification.
/// HIPAR timeout/Defines how long the result of the pattern condition must be true or false.
/// HIPAR patternWidth/For the ranges "Within" and "Outside", the width defines the center of a range 
/// HIPAR patternWidth/which is defined by the limits "Delta". For the ranges "Shorter" and "Longer", 
/// HIPAR patternWidth/the width defines the maximum and minimum pulse width, respectively.
/// HIPAR patternDelta/Defines a range around the width value.
/// HIPAR patternCondition/Defines how the range of a pulse width is defined for keeping up
/// HIPAR patternCondition/the true result of the pattern condition.
/// HIPAR expression/Defines a logical combination of several digital channels as trigger condition 
ViStatus _VI_FUNC rsscope_ConfigureMSOPatternTriggerSource (ViSession instrSession,
                                                            ViInt32 triggerSource,
                                                            ViInt32 patternMode,
                                                            ViInt32 timeoutCondition,
                                                            ViReal64 timeout,
                                                            ViReal64 patternWidth,
                                                            ViReal64 patternDelta,
                                                            ViInt32 patternCondition,
                                                            ViString expression)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_PATTERN_TRIGGER_MODE,
                                                 patternMode), 3, "Pattern Mode");
	
	if (patternMode == RSSCOPE_VAL_PATTERN_TIMEOUT)
	{
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
	                                                 RSSCOPE_ATTR_MSO_PATTERN_TRIGGER_TIMEOUT_MODE,
	                                                 timeoutCondition), 4, "Timeout Condition"); 
	
		viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
	                                                 RSSCOPE_ATTR_MSO_PATTERN_TRIGGER_TIMEOUT,
	                                                 timeout), 5, "Timeout");
	}
	if (patternMode == RSSCOPE_VAL_PATTERN_WIDTH)
	{
		viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
	                                                 RSSCOPE_ATTR_MSO_PATTERN_TRIGGER_WIDTH,
	                                                 patternWidth), 6, "Pattern Width");
	
		viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
	                                                 RSSCOPE_ATTR_MSO_PATTERN_TRIGGER_DELTA,
	                                                 patternDelta), 7, "Pattern Delta");
	
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
	                                                 RSSCOPE_ATTR_MSO_PATTERN_TRIGGER_CONDITION,
	                                                 patternCondition), 8, "Pattern Condition");
	}
	
	if (triggerSource == RSSCOPE_VAL_MSO_DALL)
		viCheckParm (rsscope_SetAttributeViString (instrSession, "Pattern",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_EXPRESSION,
                                                 expression), 9, "Expression");

Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN This function configures MSO serial pattern trigger.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR triggerSource/Sets the trigger source for the selected trigger type.
/// HIPAR patternPolarity/Sets the edge of the clock signal. The bit value is determined 
/// HIPAR patternPolarity/at the crossing of the clock edge and the logical threshold.
/// HIPAR clockSource/Sets the edge of the clock signal to define the time reference
/// HIPAR clockSource/point for the setup and hold time.
/// HIPAR pattern/The pattern contains the bits of the serial data to be found in the data stream.
/// HIPAR expression/Defines a logical combination of several digital channels as trigger condition
ViStatus _VI_FUNC rsscope_ConfigureMSOSerialPatternTriggerSource (ViSession instrSession,
                                                                  ViInt32 triggerSource,
                                                                  ViInt32 patternPolarity,
                                                                  ViInt32 clockSource,
                                                                  ViString pattern,
                                                                  ViString expression)
{
	ViStatus    error = VI_SUCCESS;
	ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];

    checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_SOURCE,
                                                 triggerSource), 2, "Trigger Source");

	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "SPattern",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_POLARITY,
                                                 patternPolarity), 3, "Pattern Polarity");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "SPattern",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_CLOCK_SOURCE,
                                                 clockSource), 3, "Clock Source");
	
	if (triggerSource == RSSCOPE_VAL_MSO_DALL)
		viCheckParm (rsscope_SetAttributeViString (instrSession, "SPattern",
                                                 RSSCOPE_ATTR_MSO_TRIGGER_EXPRESSION,
                                                 expression), 5, "Expression");
	viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                 RSSCOPE_ATTR_MSO_SERIAL_PATTERN_TRIGGER_PATTERN,
                                                 pattern), 5, "pattern");


Error:
    (void) Rs_UnlockSession (instrSession, VI_NULL);
    return error;
}

/// HIFN  Returns the data of the indicated parallel bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bus/This control selects the bus.
/// HIPAR arraySize/Pass the number of elements in the Results parameter.
/// HIPAR results/Array of the recorded parallel bus data.
/// HIPAR numberOfResults/Indicates the number of results the function places in the Results 
/// HIPAR numberOfResults/parameter.
ViStatus _VI_FUNC rsscope_QueryMSOBusData (ViSession instrSession,
                                           ViInt32 bus, ViInt32 arraySize,
                                           ViReal64 results[],
                                           ViInt32 *numberOfResults)
{
	ViStatus error = VI_SUCCESS;
	ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar   command [RSSCOPE_IO_BUFFER_SIZE] = "";
    
	checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	if (rsscope_invalidViInt32Range (instrSession, bus, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Bus");
    }
    
    sprintf (command, "BUS%ld:PAR:DATA?", bus);
    checkErr (rsscope_dataReadTrace (instrSession, command, arraySize, results, numberOfResults));
    checkErr (rsscope_CheckStatus (instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the data of the indicated parallel bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR arraySize/Pass the number of elements in the Results parameter.
/// HIPAR results/Array of the recorded digital channel data.
/// HIPAR numberOfResults/Indicates the number of results the function places in the Results 
/// HIPAR numberOfResults/parameter.
ViStatus _VI_FUNC rsscope_QueryMSOChannelData (ViSession instrSession,
                                               ViInt32 digitalChannel,
                                               ViInt32 arraySize,
                                               ViReal64 results[],
                                               ViInt32 *numberOfResults)
{
	ViStatus error = VI_SUCCESS;
	ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar   command [RSSCOPE_IO_BUFFER_SIZE] = "";
    
	checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	if (rsscope_invalidViInt32Range (instrSession, digitalChannel, 0, 15) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Digital Channel");
    }
    
    sprintf (command, "DIG%ld:DATA?", digitalChannel);
    checkErr (rsscope_dataReadTrace (instrSession, command, arraySize, results, numberOfResults));
    checkErr (rsscope_CheckStatus (instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the header of data of the indicated bus.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR bus/This control selects the bus.
/// HIPAR xStart/Acquisition time before trigger, in s
/// HIPAR xStop/Acquisition time after trigger, in s
/// HIPAR recordLength/Record length of the waveform in Samples
/// HIPAR numberOfValues/Number of values per sample interval.
ViStatus _VI_FUNC rsscope_QueryMSOBusDataHeader (ViSession instrSession,
                                                 ViInt32 bus, ViReal64 *xStart,
                                                 ViReal64 *xStop,
                                                 ViInt32 *recordLength,
                                                 ViInt32 *numberOfValues)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt; 
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, bus, RSSCOPE_VAL_SERIAL_BUS_1, RSSCOPE_VAL_SERIAL_BUS_4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Serial Bus");
    }
    
    viCheckErr( viPrintf(instrSession, "BUS%ld:PAR:DATA:HEAD?", bus));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    *xStart = atof (p2buf);
    
    p2buf = strtok(NULL, ",");
	*xStop = atof (p2buf);
	
	p2buf = strtok(NULL, ",");
	*recordLength = atoi (p2buf);
	
	p2buf = strtok(NULL, ",");
	*numberOfValues = atoi (p2buf); 
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Returns the header of data of the indicated digital channel.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR digitalChannel/This control selects the digital channel.
/// HIPAR xStart/Acquisition time before trigger, in s
/// HIPAR xStop/Acquisition time after trigger, in s
/// HIPAR recordLength/Record length of the waveform in Samples
/// HIPAR numberOfValues/Number of values per sample interval.
ViStatus _VI_FUNC rsscope_QueryMSOChannelDataHeader (ViSession instrSession,
                                                     ViInt32 digitalChannel,
                                                     ViReal64 *xStart,
                                                     ViReal64 *xStop,
                                                     ViInt32 *recordLength,
                                                     ViInt32 *numberOfValues)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt; 
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"B1")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, digitalChannel, 0, 15) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Digital Channel");
    }
    
    viCheckErr( viPrintf(instrSession, "DIG%ld:DATA:HEAD?", digitalChannel));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    *xStart = atof (p2buf);
    
    p2buf = strtok(NULL, ",");
	*xStop = atof (p2buf);
	
	p2buf = strtok(NULL, ",");
	*recordLength = atoi (p2buf);
	
	p2buf = strtok(NULL, ",");
	*numberOfValues = atoi (p2buf); 
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Activates the I/Q mode of the instrument.      
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR state/Activates the I/Q mode of the instrument.
ViStatus _VI_FUNC rsscope_ConfigureIQModeState (ViSession instrSession,
                                                ViBoolean state)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL)); 
    
    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_IQ_MODE_STATE,
                                                 state), 2, "State");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Sets the relative bandwidth, sample rate and record length.   
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR relativeBandwidth/Sets the bandwidth factor to define the filter bandwidth.
/// HIPAR sampleRate/Sets the required sample rate of the output I/Q data.
/// HIPAR recordLength/Sets the required record length of the output I/Q data.
ViStatus _VI_FUNC rsscope_ConfigureIQSamplingInputSettings (ViSession instrSession,
                                                            ViReal64 relativeBandwidth,
                                                            ViReal64 sampleRate,
                                                            ViInt32 recordLength)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL)); 
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_IQ_RELATIVE_BANDWIDTH,
                                                 relativeBandwidth), 2, "Relative Bandwidth");
	
	viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_IQ_SAMPLE_RATE,
                                                 sampleRate), 3, "Sample Rate");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_IQ_RECORD_LENGTH,
                                                 recordLength), 4, "Record Length");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Returns the filter bandwidth.     
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR filterBandwidth/Returns the filter bandwidth.
ViStatus _VI_FUNC rsscope_QueryIQSamplingFilterBandwidth (ViSession instrSession,
                                                          ViInt32 *filterBandwidth)
{
	ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL)); 
    
    viCheckParm (rsscope_GetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_IQ_FILTER_BANDWIDTH,
                                                 filterBandwidth), 2, "filterBandwidth");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  "Input type" sets the format of the input signal. "Input mode" selects 
/// HIFN  the frequency band of a complex input signal.      
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR inputType/Sets the type of the input signal.
/// HIPAR inputMode/Selects the frequency band of a complex input signal.
ViStatus _VI_FUNC rsscope_ConfigureIQSamplingInputType (ViSession instrSession,
                                                        ViInt32 channel,
                                                        ViInt32 inputType,
                                                        ViInt32 inputMode)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));
	
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_IQ_INPUT_TYPE,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_IQ_INPUT_TYPE,
                                               inputType), 3, "Input Type");
	
	if (inputType == RSSCOPE_VAL_IQ_INPUT_TYPE_COMPLEX)
	{
		viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_IQ_INPUT_MODE,
                                               inputMode), 3, "Input Mode");
	}
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function sets the real input.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR carrierFrequency/Sets the carrier frequency of the modulated RF signal.
/// HIPAR sideband/Defines the frequency position of the RF spectrum in the input signal: 
/// HIPAR sideband/normal or inverse. The position is important for correct 
/// HIPAR sideband/down-conversion and filtering.
ViStatus _VI_FUNC rsscope_ConfigureIQSamplingRealInput (ViSession instrSession,
                                                        ViInt32 channel,
                                                        ViReal64 carrierFrequency,
                                                        ViInt32 sideband)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_IQ_CARRIER_FREQUENCY,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_IQ_CARRIER_FREQUENCY,
                                               carrierFrequency), 3, "Carrier Frequency");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_IQ_REAL_SIDEBAND,
                                               sideband), 4, "Sideband");
	
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function sets the complex intermediate frequency (RFIF) input.    
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/This control selects the channel.
/// HIPAR carrierFrequency/Sets the carrier frequency of the modulated RF signal.
/// HIPAR sideband/Defines the sideband and the frequency position of complex modulated 
/// HIPAR sideband/input signal in IF range.
ViStatus _VI_FUNC rsscope_ConfigureIQSamplingComplexInput (ViSession instrSession,
                                                           ViInt32 channel,
                                                           ViReal64 carrierFrequency,
                                                           ViInt32 sideband)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      rep_cap[10] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_IQ_CARRIER_FREQUENCY,
                                                 "Channel",
                                                 channel - 1,
                                                 10,
                                                 rep_cap), 2, "Channel"); 
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_IQ_CARRIER_FREQUENCY,
                                               carrierFrequency), 3, "Carrier Frequency");
	
	viCheckParm (rsscope_SetAttributeViInt32 (instrSession, rep_cap,
                                               RSSCOPE_ATTR_IQ_COMPLEX_SIDEBAND,
                                               sideband), 4, "Sideband");
	
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the recorded I/Q data.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/Selects the input channel.
/// HIPAR arraySize/Pass the number of elements in the Results parameter.
/// HIPAR i/Array of the recorded I data.
/// HIPAR i/Array of the recorded Q data.
/// HIPAR numberOfResults/Indicates the number of results the function places in the each of I and Q 
/// HIPAR numberOfResults/parameters.
ViStatus _VI_FUNC rsscope_QueryIQData (ViSession instrSession,
                                       ViInt32 channel, ViInt32 arraySize,
                                       ViReal64 i[],
                                       ViReal64 q[],
									   ViInt32 *numberOfResults)
{
	ViStatus error = VI_SUCCESS;
	ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar   command [RSSCOPE_IO_BUFFER_SIZE] = "";
    
	checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K11")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	if (rsscope_invalidViInt32Range (instrSession, channel, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }
    
    sprintf (command, "CHAN%ld:IQ:DATA?", channel);
    checkErr (rsscope_dataReadTraceIQ (instrSession, command, arraySize, i, q, numberOfResults));
    checkErr (rsscope_CheckStatus (instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the specified samples of recorded I/Q data. 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/Selects the input channel.
/// HIPAR skippedSamples/Number of samples to be skipped.
/// HIPAR returnedSamples/Number of samples to be returned.
/// HIPAR arraySize/Pass the number of elements in the Results parameter.
/// HIPAR i/Array of the recorded I data.
/// HIPAR q/Array of the recorded Q data.
/// HIPAR numberOfResults/Indicates the number of results the function places in each of I and Q 
/// HIPAR numberOfResults/parameters.
ViStatus _VI_FUNC rsscope_QueryIQDataMemory (ViSession instrSession,
                                             ViInt32 channel,
                                             ViInt32 skippedSamples,
                                             ViInt32 returnedSamples,
                                             ViInt32 arraySize, ViReal64 i[],
                                             ViReal64 q[],
                                             ViInt32 *numberOfResults)
{
	ViStatus error = VI_SUCCESS;
	ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE]; 
    ViChar   command [RSSCOPE_IO_BUFFER_SIZE] = "";
    
	checkErr (Rs_LockSession (instrSession, VI_NULL));

	checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K11")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
	
	if (rsscope_invalidViInt32Range (instrSession, channel, 1, 4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }
    
    sprintf (command, "CHAN%ld:IQ:DATA:MEM? %ld,%ld", channel, skippedSamples, returnedSamples);
    checkErr (rsscope_dataReadTraceIQ (instrSession, command, arraySize, i, q, numberOfResults));
    checkErr (rsscope_CheckStatus (instrSession));
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function returns the header of I/Q data.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR channel/Selects the input channel.
/// HIPAR xStart/Acquisition time before trigger, in s
/// HIPAR xStop/Acquisition time after trigger, in s
/// HIPAR recordLength/Record length of the waveform in Samples
/// HIPAR numberOfValues/Number of values per sample interval.
ViStatus _VI_FUNC rsscope_QueryIQDataHeader (ViSession instrSession,
                                             ViInt32 channel, ViReal64 *xStart,
                                             ViReal64 *xStop,
                                             ViInt32 *recordLength,
                                             ViInt32 *numberOfValues)
{
	ViStatus    error = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE];
    ViChar      *p2buf  = NULL; 
    ViChar      *extBuf=VI_NULL; 
    ViUInt32    ret_cnt; 
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    checkErr (rsscope_GetAttributeViString (instrSession, "", RS_ATTR_OPTIONS_LIST, RSSCOPE_IO_BUFFER_SIZE, buffer));
    
    if (!(rsscope_CheckOption (instrSession,"K11")))
    {
        viCheckErr (RS_ERROR_INSTRUMENT_OPTION);
    }
        
    if (rsscope_invalidViInt32Range (instrSession, channel, 1,4) == VI_TRUE)
    {
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Channel");
    }
    
    viCheckErr( viPrintf(instrSession, "CHAN%ld:IQ:DATA:HEAD?", channel));
    viCheckErr (Rs_ReadDataUnknownLength(instrSession, &extBuf, &ret_cnt)); 
    
    p2buf = strtok(extBuf, ",");
    *xStart = atof (p2buf);
    
    p2buf = strtok(NULL, ",");
	*xStop = atof (p2buf);
	
	p2buf = strtok(NULL, ",");
	*recordLength = atoi (p2buf);
	
	p2buf = strtok(NULL, ",");
	*numberOfValues = atoi (p2buf); 
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    if (extBuf) free(extBuf);
    Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function resets the instrument to a known state and sends initialization commands to the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
ViStatus _VI_FUNC rsscope_reset (ViSession instrSession)
{
    ViStatus    error   = VI_SUCCESS;

    checkErr( Rs_LockSession (instrSession, VI_NULL));

    if (Rs_Simulating(instrSession) == 0)                /* call only when locked */
        {
        viCheckErr( viPrintf (instrSession, "*CLS;*RST;*WAI\n"));
        }

    checkErr( rsscope_DefaultInstrSetup (instrSession));
    checkErr( rsscope_CheckStatus (instrSession));

Error:

    (void) Rs_UnlockSession (instrSession, VI_NULL);

    return error;
}

/// HIFN This function runs the instrument's self test routine and returns the test result(s).
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR testResult/Contains the value returned from the instrument self test.
/// HIPAR testMessage/Returns the self-test response string from the instrument.
ViStatus _VI_FUNC rsscope_self_test (ViSession instrSession, ViInt16 *testResult, 
                                      ViChar testMessage[])
{
    ViStatus    error   = VI_SUCCESS;
    ViInt32     result = 0;
    
    checkErr( Rs_LockSession (instrSession, VI_NULL));

    if (testResult == NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 2, "Null address for Test Result");
    if (testMessage == NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 3, "Null address for Test Message");

    viCheckErr (rsscope_GetAttributeViInt32 (instrSession, NULL, RSSCOPE_ATTR_SELF_TEST_QUERY, &result));
    if (*testResult == 0)
        strcpy (testMessage, "Self-Test Passed.");
    else
        strcpy (testMessage, "Self-Test Failed.");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function returns the driver and instrument revisions.
/// HIRET /// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR driverRev/Returns the instrument driver software revision numbers in the form of a string.
/// HIPAR instrRev/Returns the instrument firmware revision numbers in the form of a string.
ViStatus _VI_FUNC rsscope_revision_query (ViSession instrSession, ViChar driverRev[], 
                                           ViChar instrRev[])
{
    ViStatus    error   = VI_SUCCESS;

    checkErr( Rs_LockSession (instrSession, VI_NULL));

    if (driverRev == VI_NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 2, "Null address for Driver Revision");
    if (instrRev == VI_NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 3, "Null address for Instrument Revision");

    checkErr( Rs_GetAttribute (instrSession, VI_NULL, RSSCOPE_ATTR_SPECIFIC_DRIVER_REVISION,
                                        0, 256, driverRev));
    checkErr( Rs_GetAttribute (instrSession, "", RSSCOPE_ATTR_INSTRUMENT_FIRMWARE_REVISION,
                                        0, 256, instrRev));
    checkErr( rsscope_CheckStatus (instrSession));

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function reads an error code and a message from the
/// HIFN instrument's error queue.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR errCode/Returns the error code read from the instrument's error queue.
/// HIPAR errMessage/Returns the error message string read from the instrument's error message queue.
ViStatus _VI_FUNC rsscope_error_query (ViSession instrSession, ViInt32 *errCode, 
                                        ViChar errMessage[])
{
    ViStatus    error   = VI_SUCCESS;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    
    checkErr( Rs_LockSession (instrSession, VI_NULL));

    if (errCode == NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 2, "Null address for Error Code");
    if (errMessage == NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 3, "Null address for Error Message");

    if (Rs_Simulating(instrSession) == 0)                /* call only when locked */
        {
        viCheckErr (rsscope_GetAttributeViString( instrSession, "", RSSCOPE_ATTR_SYSTEM_ERROR, RSSCOPE_IO_BUFFER_SIZE, buffer));
        if  (sscanf (buffer, "%ld,\"%256[^\"]", errCode, errMessage) != 2)
            viCheckErr(RS_ERROR_UNEXPECTED_RESPONSE);

        }
    else
        {
            /* Simulate Error Query */
        *errCode = 0;
        strcpy (errMessage, "No error.");
        }

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function converts a status code returned by an instrument driver function into a user-readable string.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR errorCode/Pass the Status parameter that is returned from any of the instrument driver functions.
/// HIPAR errorMessage/Returns the user-readable message string that corresponds to the status code you specify.
ViStatus _VI_FUNC rsscope_error_message (ViSession instrSession, ViStatus errorCode,
                                          ViChar errorMessage[256])
{
    ViStatus    error   = VI_SUCCESS;

    static      RsStringValueTable errorTable =
        {
            RSSCOPE_ERROR_CODES_AND_MSGS,
            {VI_NULL, VI_NULL}
        };

    (void) Rs_LockSession(instrSession, VI_NULL);

        /* all VISA and RS error codes are handled as well as codes in the table */
    if (errorMessage == VI_NULL)
        viCheckParm( RS_ERROR_INVALID_PARAMETER, 3, "Null address for Error Message");

    checkErr( Rs_GetSpecificDriverStatusDesc(instrSession, errorCode, errorMessage, errorTable));

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function sets the Enable, NTransition, and PTransition bits     
/// HIFN  of the questionable registers.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR questionableRegister/This control selects the registers that will be configured. 
/// HIPAR enable/This control sets the enable bits of the status register.  
/// HIPAR ptransition/This control sets the PTransition bits (edge detectors) of the status 
/// HIPAR ptransition/register.  
/// HIPAR ntransition/This control sets the NTransition bits (edge detectors) of the status 
/// HIPAR ntransition/register.  
ViStatus _VI_FUNC rsscope_SetStatusRegister(
    ViSession   instrSession,
    ViInt32 questionableRegister,
    ViInt32 enable,
    ViInt32 ptransition,
    ViInt32 ntransition
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_reg[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_QUESTIONABLE_REGISTER,
                                                 "QRegister",
                                                 questionableRegister,
                                                 25,
                                                 rep_cap_reg), 2, "Questionable Register");

    strcpy (rep_cap, rep_cap_reg);
    strcat (rep_cap, ",");
    strcat (rep_cap, "RegEnable");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_QUESTIONABLE_REGISTER, enable), 3, "Enable");
    
    strcpy (rep_cap, rep_cap_reg);
    strcat (rep_cap, ",");
    strcat (rep_cap, "RegNTR");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_QUESTIONABLE_REGISTER, ntransition), 5, "NTR Transition");

    strcpy (rep_cap, rep_cap_reg);
    strcat (rep_cap, ",");
    strcat (rep_cap, "RegPTR");

    viCheckParm(rsscope_SetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_QUESTIONABLE_REGISTER, ptransition), 4, "PTR Transition");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function queries the status reporting system.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR questionableRegister/This control selects the registers that will be configured. 
/// HIPAR registerPart/Selects register part to be queried.
/// HIPAR registerValue/Returns content of selected register.
ViStatus _VI_FUNC rsscope_GetStatusRegister(
    ViSession   instrSession,
    ViInt32 questionableRegister,
    ViInt32 registerPart,
    ViInt32*    registerValue
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rep_cap_reg[25] = "";
    ViChar   rep_cap_part[25] = "";
    ViChar   rep_cap[75] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_QUESTIONABLE_REGISTER,
                                                 "QRegister",
                                                 questionableRegister,
                                                 25,
                                                 rep_cap_reg), 2, "Questionable Register");
    viCheckParm (rsscope_GetAttributeRepCapName (instrSession,
                                                 RSSCOPE_ATTR_QUESTIONABLE_REGISTER,
                                                 "RegisterPart",
                                                 registerPart,
                                                 25,
                                                 rep_cap_part), 3, "Register Part");

    strcpy (rep_cap, rep_cap_reg);
    strcat (rep_cap, ",");
    strcat (rep_cap, rep_cap_part);

    viCheckParm(rsscope_GetAttributeViInt32(instrSession, rep_cap,
        RSSCOPE_ATTR_QUESTIONABLE_REGISTER, registerValue), 4, "Register Value");

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN This function switches ON/OFF various error checkings performed inside of the driver.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR optionChecking/This control switches option checking On or Off.
/// HIPAR rangeChecking/This control enables or disables range checking.
/// HIPAR statusChecking/This control enables or disables instrument state checking
ViStatus _VI_FUNC rsscope_ConfigureErrorChecking (ViSession instrSession,
                                                  ViBoolean optionChecking,
                                                  ViBoolean rangeChecking,
                                                  ViBoolean statusChecking)
{
    ViStatus    error = VI_SUCCESS;
    ViInt32     p2value         = 0;
    RsSessionPropertiesPtr  sessionProperties = Rs_ViSession (instrSession);

    sessionProperties -> optionChecking = optionChecking;
    p2value = (ViInt32) statusChecking;
    checkErr (Rs_SetAttribute (instrSession, "", RS_ATTR_QUERY_INSTRUMENT_STATUS, 0, &p2value));
    p2value = (ViInt32) rangeChecking;
    checkErr (Rs_SetAttribute (instrSession, "", RS_ATTR_RANGE_CHECK, 0, &p2value));
	
Error:
    return error;
}

/// HIFN This function sets OPC timeout value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR timeout/Timeout value
ViStatus _VI_FUNC rsscope_SetOPCTimeout(ViSession instrSession, ViUInt32 timeout)
{
    ViStatus    error = VI_SUCCESS; 
    
    checkErr( Rs_SetAttribute (instrSession, VI_NULL, RS_ATTR_OPC_TIMEOUT, 0, &timeout));  
    
Error:    
    return error;
}

/// HIFN This function gets OPC timeout value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR timeout/Timeout value
ViStatus _VI_FUNC rsscope_GetOPCTimeout(ViSession instrSession, ViUInt32 *timeout)
{
    ViStatus    error = VI_SUCCESS; 
    
    checkErr( Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_OPC_TIMEOUT, 0, (unsigned int) sizeof(timeout), timeout));  
    
Error:    
    return error;
}


/// HIFN This function retrieves and then clears the error information
/// HIFN for the session or the current execution thread.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR errorCode/Returns the error code for the session or execution thread.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the Description parameter.
/// HIPAR description/Returns the error description for the session or execution thread. If there is no description, the function returns an empty string.
ViStatus _VI_FUNC rsscope_GetError (ViSession instrSession, 
                                     ViStatus *errorCode, 
                                     ViInt32 bufferSize,
                                     ViChar description[])  
{
    ViStatus    error       = VI_SUCCESS;
    ViStatus    primary     = VI_SUCCESS,
                secondary   = VI_SUCCESS;
    ViChar      elaboration[RS_MAX_MESSAGE_BUF_SIZE]    = "";
    ViChar      errorMessage[RS_MAX_MESSAGE_BUF_SIZE]  = "";
    ViChar     *appendPoint = errorMessage;
    ViInt32     actualSize  = 0;
    ViBoolean   locked      = VI_FALSE;
    RsSessionPropertiesPtr  sessionProperties = Rs_ViSession (instrSession);

    /* Lock Session */
    checkErr( Rs_LockSession(instrSession, &locked));

    /* Test for nulls and acquire error data */
    if (bufferSize != 0)
    {
        if (errorCode == VI_NULL)
        {
            viCheckParm( RS_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
        }
        if (sessionProperties == NULL)
        {
            primary = VI_ERROR_RSRC_NFOUND;
            secondary = 0;
        }
        else
        {
            checkErr( Rs_GetErrorInfo (instrSession, &primary, &secondary, elaboration));
        }
    }

    else
        {
            if (sessionProperties == NULL)
            {
                (void) Rs_UnlockSession (instrSession, &locked);
                return 1024;
            }
            else
            {
                checkErr( Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_ERROR_ELABORATION, 0, 256, elaboration));
                checkErr( Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_SECONDARY_ERROR, 0, (ViInt32) sizeof (secondary), &secondary));
                checkErr( Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_PRIMARY_ERROR, 0, (ViInt32) sizeof (primary), &primary));
            }
        }

    /* Format data */
    if (primary != VI_SUCCESS)
        {
        ViChar msg[256] = "";
        checkErr( rsscope_error_message (instrSession, primary, msg));
        appendPoint += sprintf(appendPoint, "Primary Error: (Hex 0x%08X) %s\n", (unsigned int) primary, msg);
        }

    if (secondary != VI_SUCCESS)
        {
        ViChar msg[256] = "";
        checkErr( rsscope_error_message (instrSession, secondary, msg));
        appendPoint += sprintf(appendPoint, "Secondary Error: (Hex 0x%08X) %s\n", (unsigned int) secondary, msg);
        }

    if (strlen (elaboration) > 0)
        {
        sprintf(appendPoint, "Elaboration: %s", elaboration);
        }

    actualSize = (ViInt32) (strlen(errorMessage) + 1);

    /* Prepare return values */
    if (bufferSize == 0)
        {
        error = (ViStatus) actualSize;
        }
    else
        {
        if (bufferSize > 0)
            {
            if (actualSize > bufferSize)
                {
                error = actualSize;
                actualSize = bufferSize;
                }
            }
        if (description == VI_NULL)
            {
            viCheckParm( RS_ERROR_INVALID_PARAMETER, 4, "Null address for Description");
            }
        memcpy(description, errorMessage, (size_t)(actualSize-1));
        description[actualSize-1] = '\0';
        }

    if (errorCode)
        {
        *errorCode = primary;
        }

Error:
    /* Unlock Session */
    (void) Rs_UnlockSession (instrSession, &locked);
    return error;
}

/// HIFN This function clears the error code and error description for
/// HIFN the session.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
ViStatus _VI_FUNC rsscope_ClearError (ViSession instrSession)                                                        
{                                                                                                           
    return Rs_ClearErrorInfo (instrSession);                                                                             
}

/// HIFN This function writes a user-specified string to the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR writeBuffer/Pass the string to be written to the instrument.
ViStatus _VI_FUNC rsscope_WriteInstrData (ViSession instrSession, ViString writeBuffer)
{
    return Rs_WriteInstrData (instrSession, writeBuffer);
}

/// HIFN Document your function here.
/// HIFN You may use multiple lines for documentation.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR numBytes/Pass the maximum number of bytes to read from the instruments.
/// HIPAR rdBuf/After this function executes, this parameter contains the data that was read from the instrument.
/// HIPAR bytesRead/Returns the number of bytes actually read from the instrument and stored in the Read Buffer.
ViStatus _VI_FUNC rsscope_ReadInstrData (ViSession instrSession, ViInt32 numBytes,
                                          ViChar rdBuf[], ViUInt32 *bytesRead)
{
    return Rs_ReadInstrData (instrSession, numBytes, rdBuf, bytesRead);
}

/// HIFN This function queries the ViBoolean value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR command/The query to be sent to the instrument.
/// HIPAR value/Returns the ViBoolean value.
ViStatus _VI_FUNC rsscope_QueryViBoolean (ViSession instrSession,
                                           ViString command, 
                                           ViBoolean *value)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr( Rs_LockSession (instrSession, VI_NULL)); 
    if (strlen(command)==0)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Command");
    if (value==VI_NULL)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Value");
    viCheckErr (viQueryf (instrSession, "%s\n", "%d", command, value));
    checkErr( rsscope_CheckStatus (instrSession)); 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the ViInt32 value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR command/The query to be sent to the instrument.
/// HIPAR value/Returns the ViInt32 value.
ViStatus _VI_FUNC rsscope_QueryViInt32 (ViSession instrSession,
                                         ViString command, 
                                         ViInt32 *value)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr( Rs_LockSession (instrSession, VI_NULL)); 
    if (strlen(command)==0)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Command");
    if (value==VI_NULL)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Value");
    viCheckErr (viQueryf (instrSession, "%s\n", "%ld", command, value));
    checkErr( rsscope_CheckStatus (instrSession)); 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the ViReal64 value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR command/The query to be sent to the instrument.
/// HIPAR value/Returns the ViReal64 value.
ViStatus _VI_FUNC rsscope_QueryViReal64 (ViSession instrSession,
                                          ViString command, 
                                          ViReal64 *value)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr( Rs_LockSession (instrSession, VI_NULL)); 
    if (strlen(command)==0)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Command");
    if (value==VI_NULL)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Value");
    viCheckErr (viQueryf (instrSession, "%s\n", "%le", command, value));
    checkErr( rsscope_CheckStatus (instrSession)); 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function queries the ViString value.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
/// HIPAR command/The query to be sent to the instrument.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the Value parameter.
/// HIPAR value/Returns the string value.
ViStatus _VI_FUNC rsscope_QueryViString (ViSession instrSession,
                                          ViString command, 
                                          ViInt32 bufferSize,
                                          ViChar _VI_FAR value[])
{
    ViStatus    error = VI_SUCCESS;
    ViChar      *pbuffer = NULL;
    ViUInt32        bytesRead;
    
    checkErr( Rs_LockSession (instrSession, VI_NULL)); 
    if (strlen(command)==0)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Command");
    if (value==VI_NULL)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Value");
    viCheckErr (viPrintf (instrSession, "%s\n", command));
    viCheckErr(Rs_ReadDataUnknownLength (instrSession, &pbuffer, &bytesRead));  
    if (bytesRead>=(ViUInt32)bufferSize)
    {
        strncpy(value, pbuffer, (size_t) (bufferSize-1));
        value[bufferSize-1]='\0';
        error = (ViStatus) (bytesRead+1);
    } 
    else
    {
        strncpy(value, pbuffer, (size_t) bytesRead); 
        value[bytesRead]='\0';   
    }
    checkErr( rsscope_CheckStatus (instrSession)); 
Error:
    if (pbuffer) free (pbuffer);
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function provides mass storage capabilities for the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR operation/This control selects the type of memory operation to be performed.
/// HIPAR source/This control specifies the source of the operation to be performed. If 
/// HIPAR source/the operation requires a single parameter, this control specifies that 
/// HIPAR source/parameter.
/// HIPAR destination/This control specifies the destination of the operation to be 
/// HIPAR destination/performed.
ViStatus _VI_FUNC rsscope_FileManagerOperations(
    ViSession   instrSession,
    ViInt32 operation,
    ViString    source,
    ViString    destination
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    switch (operation)
    {
        case RSSCOPE_VAL_FILE_COPY:
            sprintf (buffer, "MMEM:COPY '%s','%s'\n", source, destination);
            checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
            checkErr (rsscope_CheckStatus (instrSession));
            break;
        case RSSCOPE_VAL_FILE_MOVE:
            sprintf (buffer, "MMEM:MOVE '%s','%s'\n", source, destination);
            checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
            checkErr (rsscope_CheckStatus (instrSession));
            break;
        case RSSCOPE_VAL_FILE_DELETE:
            viCheckParm (rsscope_SetAttributeViString(instrSession, "",
                RSSCOPE_ATTR_DELETE_FILE, source), 3, "Source");
            break;
        case RSSCOPE_VAL_FILE_NEW_DIR:
            viCheckParm (rsscope_SetAttributeViString(instrSession, "",
                RSSCOPE_ATTR_CREATE_DIRECTORY, source), 3, "Source");
            break;
        case RSSCOPE_VAL_FILE_CDIR:
            viCheckParm (rsscope_SetAttributeViString(instrSession, "",
                RSSCOPE_ATTR_CURRENT_DIRECTORY, source), 3, "Source");
            break;
        case RSSCOPE_VAL_FILE_RDIR:
            viCheckParm (rsscope_SetAttributeViString(instrSession, "",
                RSSCOPE_ATTR_REMOVE_DIRECTORY, source), 3, "Source");
            break;
        case RSSCOPE_VAL_FILE_CDRIVE:
            viCheckParm (rsscope_SetAttributeViString(instrSession, "",
                RSSCOPE_ATTR_CHANGE_DRIVE, source), 3, "Source");
            break;
        default:
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Operation");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the number of files and subdirectories of the current or of a 
/// HIFN  specified directory. The number includes the parent directory strings 
/// HIFN  "." and ".." so that it corresponds to the number of strings returned 
/// HIFN  by the rsscope_FileDirectoryContent function after the initial numeric 
/// HIFN  parameters.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR directory/This control specifies the directory in which the command will be 
/// HIPAR directory/performed.
/// HIPAR numberofFilesAndFolders/Returns the number of files and subdirectories of the current or of a 
/// HIPAR numberofFilesAndFolders/specified directory.
ViStatus _VI_FUNC rsscope_FileCount(
    ViSession   instrSession,
    ViString    directory,
    ViInt32*    numberofFilesAndFolders
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar *p2buf = NULL;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckAlloc (numberofFilesAndFolders);
    
    p2buf = buffer + sprintf (buffer, "MMEM:CAT:LENG?");
    
    if ((directory != NULL) && (strlen (directory) > 0))
        p2buf += sprintf (p2buf, " '%s'", directory);
    
    strcat (buffer, "\n");
    checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
    checkErr (viScanf (instrSession, "%ld", numberofFilesAndFolders));
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function reads the indicated directory. According to DOS 
/// HIFN  convention, wild card characters can be entered in order to query eg. a 
/// HIFN  list of all file of a certain type.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR directory/This control specifies the directory in which the command will be 
/// HIPAR directory/performed.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the 
/// HIPAR bufferSize/Output parameter.  
/// HIPAR output/This indicator returns the files in the indicated directory as comma 
/// HIPAR output/separated strings, for example: 'SPOOL1.WMF','SPOOL2.WMF','SPOOL3.WMF'
ViStatus _VI_FUNC rsscope_FileDirectoryContent(
    ViSession   instrSession,
    ViString    directory,
    ViInt32 bufferSize,
    ViChar    output[]
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar   *p2buf = NULL;
    ViUInt32  count = 0;
    ViUInt32  length = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckAlloc (output);
    
    p2buf = buffer + sprintf (buffer, "MMEM:CAT?");
    
    if ((directory != NULL) && (strlen (directory) > 0))
        p2buf += sprintf (p2buf, " '%s'", directory);
    
    strcat (buffer, "\n");
    checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
    p2buf = NULL;
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2buf, &count));
    
    length = ((ViInt32)count > bufferSize) ? bufferSize : count;
    memcpy (output, p2buf, length);
    
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    if (p2buf != NULL) free (p2buf);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the number of subdirectories of the current or of a specified 
/// HIFN  directory. The number includes the parent directory strings "." and 
/// HIFN  ".." so that it corresponds to the number of strings returned by the 
/// HIFN  rsscope_FileSubdirectories.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR directory/This control specifies the directory in which the command will be 
/// HIPAR directory/performed.
/// HIPAR numberofSubdirectories/Returns the number of files and subdirectories of the current or of a 
/// HIPAR numberofSubdirectories/specified directory.
ViStatus _VI_FUNC rsscope_FileSubdirectoriesCount(
    ViSession   instrSession,
    ViString    directory,
    ViInt32*    numberofSubdirectories
)
{
    ViStatus    error = VI_SUCCESS;
    ViChar  buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar *p2buf = NULL;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckAlloc (numberofSubdirectories);
    
    p2buf = buffer + sprintf (buffer, "MMEM:DCAT:LENG?");
    
    if ((directory != NULL) && (strlen (directory) > 0))
        p2buf += sprintf (p2buf, " '%s'", directory);
    
    strcat (buffer, "\n");
    checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
    checkErr (viScanf (instrSession, "%ld", numberofSubdirectories));
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns the subdirectories of the current or of a specified directory.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR directory/This control specifies the directory in which the command will be 
/// HIPAR directory/performed.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the 
/// HIPAR bufferSize/Output parameter.  
/// HIPAR output/This indicator returns the files in the indicated directory as comma 
/// HIPAR output/separated strings, for example: 'SPOOL1.WMF','SPOOL2.WMF','SPOOL3.WMF'
ViStatus _VI_FUNC rsscope_FileSubdirectories(
    ViSession   instrSession,
    ViString    directory,
    ViInt32 bufferSize,
    ViChar    output[]
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViChar   *p2buf = NULL;
    ViUInt32  count = 0;
    ViUInt32  length = 0;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckAlloc (output);
    
    p2buf = buffer + sprintf (buffer, "MMEM:DCAT?");
    
    if ((directory != NULL) && (strlen (directory) > 0))
        p2buf += sprintf (p2buf, " '%s'", directory);
    
    strcat (buffer, "\n");
    checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
    p2buf = NULL;
    checkErr (Rs_ReadDataUnknownLength (instrSession, &p2buf, &count));
    
    length = ((ViInt32)count > bufferSize) ? bufferSize : count;
    memcpy (output, p2buf, length);
    
    checkErr (rsscope_CheckStatus (instrSession));

Error:
    if (p2buf != NULL) free (p2buf);
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  Returns a list of the drives of the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR output/Returns a list of the drives of the instrument.
/// HIPAR bufferSize/Pass the number of bytes in the ViChar array you specify for the 
/// HIPAR bufferSize/Output parameter.  
ViStatus _VI_FUNC rsscope_FileDrives(
    ViSession   instrSession,
    ViInt32   bufferSize,
    ViChar    output[]
)
{
    ViStatus    error = VI_SUCCESS;

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm(rsscope_GetAttributeViString(instrSession, "",
        RSSCOPE_ATTR_DRIVES, bufferSize, output), 2, "Drives");
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function is used to read data from the instrument and write it to 
/// HIFN  a user specified file on the host computer.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR source/This control selects file for the data transfer from instrument to 
/// HIPAR source/control computer.
/// HIPAR destination/This control defines destination file to which the data transfer from 
/// HIPAR destination/instrument to control computer applies.
ViStatus _VI_FUNC rsscope_ReadToFileFromInstrument(
    ViSession   instrSession,
    ViString    source,
    ViString    destination
)
{
    ViStatus    error = VI_SUCCESS;
    ViInt32     count = 0;
    ViUInt32    ret_count = 0;
    ViUInt32    length = 0;
    ViChar      buffer[RSSCOPE_IO_BUFFER_SIZE] = "";
    ViUInt16    intfc = VI_INTF_GPIB;     
    
    checkErr( Rs_LockSession (instrSession, VI_NULL));
    if (!source)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    if (!destination)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Destination");    
    checkErr (viGetAttribute (instrSession, VI_ATTR_INTF_TYPE, &intfc));
    switch (intfc)
    {
        case VI_INTF_ASRL: /* Serial intfc. */
            viCheckErr( viSetAttribute (instrSession, VI_ATTR_ASRL_END_IN, VI_ASRL_END_NONE));
        break;
    }
    viCheckErr( viSetAttribute (instrSession, VI_ATTR_TERMCHAR_EN, VI_FALSE));
    
    viCheckErr (viPrintf(instrSession, ":MMEMory:DATA? '%s'\n", source));
    //Read header       
    viCheckErr (viRead(instrSession, (ViPBuf)buffer, 2,  &ret_count));
    if (sscanf (buffer, "#%1ld", &count) != 1)
        checkErr(RS_ERROR_UNEXPECTED_RESPONSE); 
    viCheckErr (viRead (instrSession, (ViPBuf)buffer, (ViUInt32) count, &ret_count));
    if (sscanf (buffer, "%lu", &length)  != 1)
        checkErr(RS_ERROR_UNEXPECTED_RESPONSE);     
    viCheckErr(Rs_ReadToFile(instrSession, destination, (ViInt32) length, RS_VAL_TRUNCATE, &count)); 
    //Read \n and \r
    viCheckErr (viRead (instrSession, (ViPBuf)buffer, 2, &ret_count)); 
    if (count!=(ViInt32) length)
        checkErr(RS_ERROR_UNEXPECTED_RESPONSE);         
    viSetAttribute (instrSession, VI_ATTR_TERMCHAR_EN, VI_TRUE);        
    checkErr( rsscope_CheckStatus (instrSession));
  
Error:
    viSetAttribute (instrSession, VI_ATTR_TERMCHAR_EN, VI_TRUE);
    switch (intfc)
    {
        case VI_INTF_ASRL:
            viSetAttribute (instrSession, VI_ATTR_ASRL_END_IN, VI_ASRL_END_TERMCHAR);
        break;    
    }  
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    
    return error;
}

/// HIFN  This function is used to read data from the host computer and write it 
/// HIFN  to a user specified file in the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR source/This control selects file for the data transfer from control computer 
/// HIPAR source/to instrument.
/// HIPAR destination/This control defines destination file to which the data transfer from 
/// HIPAR destination/control computer to instrument applies.
ViStatus _VI_FUNC rsscope_WriteFromFileToInstrument(
    ViSession   instrSession,
    ViString    source,
    ViString    destination
)
{
    ViStatus    error = VI_SUCCESS;
    ViInt32     count = 0;
    ViUInt32    digits = 0;
    FILE        *sourceFile = NULL;
    ViUInt32    fileSize = 0;
    
    checkErr( Rs_LockSession (instrSession, VI_NULL));
    if (!source)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Source");
    if (!destination)
        viCheckParm (RS_ERROR_INVALID_PARAMETER, 3, "Destination");  
        
    /* Open source file from host controller */
    if ((sourceFile = fopen (source, "rb")) == NULL)
        viCheckErr(RS_ERROR_CANNOT_OPEN_FILE);

    /* Get size of file */
    (void) fseek (sourceFile, 0, SEEK_END);
    fileSize = (ViUInt32) ftell (sourceFile);
    (void) fseek (sourceFile, 0, SEEK_SET);

    /* Create command header */
    digits = (ViUInt32) ((int)floor(log10((double)fileSize))) + 1;
    viCheckErr (viPrintf (instrSession, ":MMEM:DATA '%s',#%ld%ld", destination, digits, fileSize));
    
    viCheckErr (Rs_WriteFromFile(instrSession, source, (ViInt32) fileSize, 0, &count));
    if (count!=(ViInt32) fileSize)
        viCheckErr (RS_ERROR_WRITING_FILE);     
        
    checkErr( rsscope_CheckStatus (instrSession));
 
 Error:
    if (sourceFile) (void) fclose (sourceFile);
    
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    
    return error;
}

/// HIFN  This function allows to provide data set operation for Save/Recall 
/// HIFN  items of memory subsystem.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/This control accepts the Instrument Handle returned by the Initialize 
/// HIPAR instrSession/function to select the desired instrument driver session.
/// HIPAR operation/This control selects the type of memory operation to be performed.
/// HIPAR stateNumber/Defines save and recall state position.
/// HIPAR path/This control specifies the source of the operation to be performed. 
ViStatus _VI_FUNC rsscope_DataSetFileOperations(
    ViSession   instrSession,
    ViInt32 operation,
    ViInt32 stateNumber,
    ViString    path
)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[RSSCOPE_IO_BUFFER_SIZE] = "";

    checkErr (Rs_LockSession (instrSession, VI_NULL));

    switch (operation)
    {
        case RSSCOPE_VAL_MEM_SAVE:
            sprintf (buffer, "MMEM:STOR:STAT %ld,'%s'\n", stateNumber, path);
            checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
            checkErr (rsscope_CheckStatus (instrSession));
            break;
        case RSSCOPE_VAL_MEM_RECALL:
            sprintf (buffer, "MMEM:LOAD:STAT %ld,'%s'\n", stateNumber, path);
            checkErr (viWrite (instrSession, (ViBuf) buffer, (ViUInt32) strlen (buffer), NULL));
            checkErr (rsscope_CheckStatus (instrSession));
            break;
        default:
            viCheckParm (RS_ERROR_INVALID_PARAMETER, 2, "Operation");
    }
    
Error:
    Rs_UnlockSession(instrSession, VI_NULL);    
    return error;
}

/// HIFN  This function configures the source waveform for export from the 
/// HIFN  active waveforms of input channels, math signals and reference 
/// HIFN  waveforms.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR source/Waveform to be assigned.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportSource(
    ViSession   instrSession,
    ViInt32     source
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SOURCE,
                                                 source), 2, "Source");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the zoom area to be used for limited data 
/// HIFN  export. The data included in the zoom area are saved, if at least one 
/// HIFN  zoom is defined for the source waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR diagramName/Name of the zoom diagram
/// HIPAR zoomName/Name of the diagram on which the zoom area is based.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportScopeZoom(
    ViSession   instrSession,
    ViString    diagramName,
    ViString    zoomName
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));
    
    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE,
                                                 RSSCOPE_VAL_WAV_EXPORT_ZOOM));

    viCheckErr (viPrintf (instrSession, "EXP:WAV:ZOOM '%s','%s'", diagramName, zoomName));
    
    checkErr (rsscope_CheckStatus (instrSession));
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures the cursor set to be used for limited data 
/// HIFN  export. The data between the cursor lines are saved, if at least one 
/// HIFN  cursor measurement is defined for the source waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR cursor/This control selects the cursor set to be used for limited data 
/// HIPAR cursor/export.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportScopeCursor(
    ViSession   instrSession,
    ViInt32     cursor
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE,
                                                 RSSCOPE_VAL_WAV_EXPORT_CURSOR));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE_CURSOR,
                                                 cursor
                                                 ), 2, "Cursor");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures gate to be used for limited data export. The 
/// HIFN  data included in the measurement gate are saved, if a gated measurement 
/// HIFN  is defined for the source waveform.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR measurement/Selects the measurement for which the gate is defined.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportScopeGate(
    ViSession   instrSession,
    ViInt32     measurement
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE,
                                                 RSSCOPE_VAL_WAV_EXPORT_GATE));
    
    viCheckParm (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE_GATE,
                                                 measurement
                                                 ), 2, "Measurement");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures manual interval used for limited data export. 
/// HIFN  The data are saved between user-defined "Start" and "Stop" values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR start/Sets the start value of the waveform section for export.
/// HIPAR stop/Sets the end value of the waveform section for export.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportScopeManual(
    ViSession   instrSession,
    ViReal64    start,
    ViReal64    stop
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE,
                                                 RSSCOPE_VAL_WAV_EXPORT_MANUAL));
    
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE_START,
                                                 start
                                                 ), 2, "Start");
                                                 
    viCheckParm (rsscope_SetAttributeViReal64 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE_STOP,
                                                 stop
                                                 ), 3, "Stop");
                                                 
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function configures export to save the complete waveform record.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportScopeComplete(
    ViSession   instrSession
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckErr (rsscope_SetAttributeViInt32 (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_SCOPE,
                                                 RSSCOPE_VAL_WAV_EXPORT_COMPLETE));

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function enables or disables "Data logging". This enables the 
/// HIFN  export of all waveforms of a running acquisition into one file. The 
/// HIFN  waveform records are written in historical order one after the other, 
/// HIFN  either the complete records or the sections as defined in "Scope". Set 
/// HIFN  the number of acquisitions to be acquired and stored with "Acq. count". 
/// HIFN  The maximum amount of data that can be written is shown in "Max. file 
/// HIFN  size". 
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR dataLogging/Enables the export of several subsequent waveforms into one file.
ViStatus _VI_FUNC rsscope_ConfigureWaveformExportScopeDataLogging(
    ViSession   instrSession,
    ViBoolean   dataLogging
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_DATA_LOGGING,
                                                 dataLogging
                                                 ), 2, "Data Logging");

Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Includes horizontal values in the export data (time or frequency 
/// HIFN  values, depending on the waveform). X and Y-values are written 
/// HIFN  alternately to the file. If disabled, only Y-values - mostly voltage 
/// HIFN  values - are written.     
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR interleavedXY/Includes horizontal values in the export data.
ViStatus _VI_FUNC rsscope_WaveformExportInterleavedXY (ViSession instrSession,
                                                       ViBoolean interleavedXY)
{
	ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_INTERLEAVED_XY,
                                                 interleavedXY), 2, "Interleaved XY");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  Enables the export of raw sample data of the ADC, and sets the data 
/// HIFN  format to integer 8 bit. This format reduces the file size (1 
/// HIFN  Byte/sample instead of 4 Bytes/sample in binary files) but decreases 
/// HIFN  the precision of the values.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR rawValues/Enables the export of raw sample data of the ADC, and sets the data 
/// HIPAR rawValues/format to integer 8 bit.
ViStatus _VI_FUNC rsscope_WaveformExportRawValues (ViSession instrSession,
                                                   ViBoolean rawValues)
{
	ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViBoolean (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_RAW_VALUES,
                                                 rawValues), 2, "Raw Values");
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN  This function saves the waveform(s) to the specified file name and 
/// HIFN  path.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.  The handle identifies a particular 
/// HIPAR instrSession/instrument session.
/// HIPAR file/Stes the file name and path to save the waveform to.
ViStatus _VI_FUNC rsscope_WaveformExportFile(
    ViSession   instrSession,
    ViString    file
)
{
    ViStatus    error = VI_SUCCESS;
    
    checkErr (Rs_LockSession (instrSession, VI_NULL));

    viCheckParm (rsscope_SetAttributeViString (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT_FILE,
                                                 file
                                                 ), 2, "File");
                                                 
    viCheckErr (rsscope_SetAttributeViString (instrSession, "",
                                                 RSSCOPE_ATTR_WAVEFORM_EXPORT, NULL));
    
Error:
    (void) Rs_UnlockSession(instrSession, VI_NULL);
    return error;
}

/// HIFN This function closes the instrument.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
ViStatus _VI_FUNC rsscope_close (ViSession instrSession)
{
    ViStatus    error   = VI_SUCCESS;

    checkErr( Rs_LockSession (instrSession, VI_NULL));
    checkErr( rsscope_RsClose (instrSession));

Error:

    (void) Rs_UnlockSession (instrSession, VI_NULL);
    (void) Rs_Dispose (instrSession);

    return error;
}

/// HIFN This function performs all of the drivers clean-up operations
/// HIFN except for closing the RS session.  This function is called by
/// HIFN rsscope_close or by an RS class driver.
/// HIRET Returns the status code of this operation.
/// HIPAR instrSession/The ViSession handle that you obtain from the rsscope_init or 
/// HIPAR instrSession/rsscope_InitWithOptions function.
ViStatus _VI_FUNC rsscope_RsClose (ViSession instrSession)
{
    ViStatus    error   = VI_SUCCESS;
    ViSession   io      = VI_NULL;

    /* Do not lock here. The caller manages the lock. */

    checkErr( Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_IO_SESSION, 0, (ViInt32) sizeof (io), &io));

Error:

    (void) Rs_SetAttribute (instrSession, VI_NULL, RS_ATTR_IO_SESSION, 0, VI_NULL);
    
    if(io != 0)
        {
        ViSession   rmSession = VI_NULL;

        checkErr( Rs_GetAttribute (instrSession, VI_NULL, RS_ATTR_VISA_RM_SESSION, 0, (ViInt32) sizeof (rmSession), &rmSession));
        
        (void) viClose (io);
        (void) viClose (rmSession);
        }
    
    return error;
}

/*****************************************************************************
 *------------------- End Instrument Driver Source Code ---------------------*
 *****************************************************************************/
